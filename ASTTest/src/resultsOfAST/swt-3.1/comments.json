{"TypedEvent":" ","ISpecifyPropertyPages":" ","IClassFactory2":" ","AccessibleListener":" ","AccessibleControlAdapter":" ","LineBackgroundEvent":" line start offset\r\n  line text\r\n  line background color\r\n ","TextChangingEvent":" ","OLECMDTEXT":" ","Widget":" $NON-NLS-1$   $NON-NLS-1$   $NON-NLS-1$\r\n  widget could be disposed at this point\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$   widget could be disposed at this point\r\n  widget could be disposed at this point\r\n  widget could be disposed at this point\r\n  widget could be disposed at this point\r\n  widget could be disposed at this point\r\n  widget could be disposed at this point\r\n  widget could be disposed at this point\r\n  widget could be disposed at this point\r\n /* Global state flags */\r\n /* Default widths for widgets */\r\n /* Check and initialize the Common Controls DLL */\r\n /*\r\n\t\t\t\t* Feature in Windows.  On Windows CE, DeferWindowPos when called\r\n\t\t\t\t* with SWP_DRAWFRAME always causes a WM_SIZE message, even\r\n\t\t\t\t* when SWP_NOSIZE is set and when the new size is the same as the\r\n\t\t\t\t* old size.  The fix is to clear SWP_DRAWFRAME when the size is\r\n\t\t\t\t* the same.\r\n\t\t\t\t*/\r\n /*\r\n\t\t* Feature in Windows.  On Windows CE, DeferWindowPos always causes\r\n\t\t* a WM_SIZE message, even when the new size is the same as the old\r\n\t\t* size.  The fix is to detect that the size has not changed and set\r\n\t\t* SWP_NOSIZE.\r\n\t\t*/\r\n /*\r\n\t* Note:  It is valid to attempt to dispose a widget\r\n\t* more than once.  If this happens, fail silently.\r\n\t*/\r\n /*\r\n * Returns a short printable representation for the contents\r\n * of a widget. For example, a button may answer the label\r\n * text. This is used by <code>toString</code> to provide a\r\n * more meaningful description of the widget.\r\n *\r\n * @return the contents string for the widget\r\n *\r\n * @see #toString\r\n */\r\n /*\r\n * Returns <code>true</code> if the specified eventType is\r\n * hooked, and <code>false</code> otherwise. Implementations\r\n * of SWT can avoid creating objects and sending events\r\n * when an event happens in the operating system but\r\n * there are no listeners hooked for the event.\r\n *\r\n * @param eventType the event to be checked\r\n *\r\n * @return <code>true</code> when the eventType is hooked and <code>false</code> otherwise\r\n *\r\n * @see #isListening\r\n */\r\n /*\r\n * Returns <code>true</code> when subclassing is\r\n * allowed and <code>false</code> otherwise\r\n *\r\n * @return <code>true</code> when subclassing is allowed and <code>false</code> otherwise\r\n */\r\n /*\r\n * Returns <code>true</code> when the current thread is\r\n * the thread that created the widget and <code>false</code>\r\n * otherwise.\r\n *\r\n * @return <code>true</code> when the current thread is the thread that created the widget and <code>false</code> otherwise\r\n */\r\n /*\r\n * Releases the receiver, a child in a widget hierarchy,\r\n * from its parent.\r\n * <p>\r\n * When a widget is destroyed, it may be necessary to remove\r\n * it from an internal data structure of the parent. When\r\n * a widget has no handle, it may also be necessary for the\r\n * parent to hide the widget or otherwise indicate that the\r\n * widget has been disposed. For example, disposing a menu\r\n * bar requires that the menu bar first be released from the\r\n * shell when the menu bar is active.  This could not be done\r\n * in <code>destroyWidget</code> for the menu bar because the\r\n * parent shell as well as other fields have been null'd out\r\n * already by <code>releaseWidget</code>.\r\n * </p>\r\n * This method is called first when a widget is disposed.\r\n * \r\n * @see #dispose\r\n * @see #releaseChild\r\n * @see #releaseWidget\r\n * @see #releaseHandle\r\n */\r\n /*\r\n * Releases the widget's handle by zero'ing it out.\r\n * Does not destroy or release any operating system\r\n * resources.\r\n * <p>\r\n * This method is called after <code>releaseWidget</code>\r\n * or from <code>destroyWidget</code> when a widget is being\r\n * destroyed to ensure that the widget is marked as destroyed\r\n * in case the act of destroying the widget in the operating\r\n * system causes application code to run in callback that\r\n * could access the widget.\r\n * </p>\r\n *\r\n * @see #dispose\r\n * @see #releaseChild\r\n * @see #releaseWidget\r\n * @see #releaseHandle\r\n */\r\n /*\r\n * Releases any internal resources back to the operating\r\n * system and clears all fields except the widget handle.\r\n * <p>\r\n * When a widget is destroyed, resources that were acquired\r\n * on behalf of the programmer need to be returned to the\r\n * operating system.  For example, if the widget made a\r\n * copy of an icon, supplied by the programmer, this copy\r\n * would be freed in <code>releaseWidget</code>.  Also,\r\n * to assist the garbage collector and minimize the amount\r\n * of memory that is not reclaimed when the programmer keeps\r\n * a reference to a disposed widget, all fields except the\r\n * handle are zero'd.  The handle is needed by <code>destroyWidget</code>.\r\n * </p>\r\n * <p>\r\n * Typically, a widget with children will broadcast this\r\n * message to all children so that they too can release their\r\n * resources.  The <code>releaseHandle</code> method is used\r\n * as part of this broadcast to zero the handle fields of the\r\n * children without calling <code>destroyWidget</code>.  In\r\n * this scenario, the children are actually destroyed later,\r\n * when the operating system destroys the widget tree.\r\n * </p>\r\n * This method is called after <code>releaseChild</code>.\r\n * \r\n * @see #dispose\r\n * @see #releaseChild\r\n * @see #releaseWidget\r\n * @see #releaseHandle\r\n */\r\n /*\r\n\t* Feature in Windows.  When the user presses Ctrl+Backspace\r\n\t* or Ctrl+Enter, Windows sends a WM_CHAR with Delete (0x7F)\r\n\t* and '\\n' instead of '\\b' and '\\r'.  This is the correct\r\n\t* platform behavior but is not portable.  The fix is to detect\r\n\t* these cases and convert the character.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the user presses either the Enter\r\n\t* key or the numeric keypad Enter key, Windows sends a WM_KEYDOWN\r\n\t* with wParam=VK_RETURN in both cases.  In order to distinguish\r\n\t* between the keys, the extended key bit is tested. If the bit\r\n\t* is set, assume that the numeric keypad Enter was pressed. \r\n\t*/\r\n /*\r\n\t\t* Feature in Windows.  The virtual key VK_DELETE is not\r\n\t\t* treated as both a virtual key and an ASCII key by Windows.\r\n\t\t* Therefore, we will not receive a WM_CHAR for this key.\r\n\t\t* The fix is to treat VK_DELETE as a special case and map\r\n\t\t* the ASCII value explictly (Delete is 0x7F).\r\n\t\t*/\r\n /*\r\n\t\t* Feature in Windows.  When the user presses Ctrl+Pause, the\r\n\t\t* VK_CANCEL key is generated and a WM_CHAR is sent with 0x03,\r\n\t\t* possibly to allow an application to look for Ctrl+C and the\r\n\t\t* the Break key at the same time.  This is unexpected and\r\n\t\t* unwanted.  The fix is to detect the case and set the character\r\n\t\t* to zero. \r\n\t\t*/\r\n /*\r\n\t\t\t\t* Feature in Windows.  On Windows CE, SetWindowPos() when called\r\n\t\t\t\t* with SWP_DRAWFRAME always causes a WM_SIZE message, even\r\n\t\t\t\t* when SWP_NOSIZE is set and when the new size is the same as the\r\n\t\t\t\t* old size.  The fix is to clear SWP_DRAWFRAME when the size is\r\n\t\t\t\t* the same.\r\n\t\t\t\t*/\r\n /*\r\n\t\t* Feature in Windows.  On Windows CE, SetWindowPos() always causes\r\n\t\t* a WM_SIZE message, even when the new size is the same as the old\r\n\t\t* size.  The fix is to detect that the size has not changed and set\r\n\t\t* SWP_NOSIZE.\r\n\t\t*/\r\n /*\r\n\t* Do not report a lead byte as a key pressed.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  SHRecognizeGesture() sends an undocumented\r\n\t* WM_CONTEXTMENU notification when the flag SHRG_NOTIFY_PARENT is\r\n\t* not set.  This causes the context menu to be displayed twice,\r\n\t* once by the caller of SHRecognizeGesture() and once from this\r\n\t* method.  The fix is to ignore WM_CONTEXTMENU notifications on\r\n\t* all WinCE platforms.\r\n\t* \r\n\t* NOTE: This only happens on WM2003.  Previous WinCE versions did\r\n\t* not support WM_CONTEXTMENU.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the user presses  WM_NCRBUTTONUP,\r\n\t* a WM_CONTEXTMENU message is generated.  This happens when\r\n\t* the user releases the mouse over a scroll bar.  Normally,\r\n\t* window displays the default scrolling menu but applications\r\n\t* can process WM_CONTEXTMENU to display a different menu.\r\n\t* Typically, an application does not want to supply a special\r\n\t* scroll menu.  The fix is to look for a WM_CONTEXTMENU that\r\n\t* originated from a mouse event and display the menu when the\r\n\t* mouse was released in the client area.\r\n\t*/\r\n /* Show the menu */\r\n /* Ignore repeating modifier keys by testing key down state */\r\n /* Clear last key and last ascii because a new key has been typed */\r\n /*\r\n\t* Do not report a lead byte as a key pressed.\r\n\t*/\r\n /*\r\n\t* Bug in WinCE.  MapVirtualKey() returns incorrect values.\r\n\t* The fix is to rely on a key mappings table to determine\r\n\t* whether the key event must be sent now or if a WM_CHAR\r\n\t* event will follow.  The key mappings table maps virtual\r\n\t* keys to SWT key codes and does not contain mappings for\r\n\t* Windows virtual keys like VK_A.  Virtual keys that are\r\n\t* both virtual and ASCII are a special case.\r\n\t*/\r\n /*\r\n\t* Bug in Windows 95 and NT.  When the user types an accent key such\r\n\t* as ^ to get an accented character on a German keyboard, the accent\r\n\t* key should be ignored and the next key that the user types is the\r\n\t* accented key.  The fix is to detect the accent key stroke (called\r\n\t* a dead key) by testing the high bit of the value returned by\r\n\t* MapVirtualKey().  A further problem is that the high bit on\r\n\t* Windows NT is bit 32 while the high bit on Windows 95 is bit 16.\r\n\t* They should both be bit 32.\r\n\t*\r\n\t* When the user types an accent key that does not correspond to a\r\n\t* virtual key, MapVirtualKey() won't set the high bit to indicate\r\n\t* a dead key.  This happens when an accent key, such as '^' is the\r\n\t* result of a modifier such as Shift key and MapVirtualKey() always\r\n\t* returns the unshifted key.  The fix is to peek for a WM_DEADCHAR\r\n\t* and avoid issuing the event. \r\n\t*/\r\n /*\r\n\t*  Bug in Windows.  Somehow, the widget is becoming disposed after\r\n\t*  calling PeekMessage().  In rare cirucmstances, it seems that\r\n\t*  PeekMessage() can allow SWT listeners to run that might contain\r\n\t*  application code that disposes the widget.  It is not exactly\r\n\t*  clear how this can happen.  PeekMessage() is only looking for\r\n\t*  WM_DEADCHAR.  It is not dispatching any message that it finds\r\n\t*  or removing any message from the queue.  Cross-thread messages\r\n\t*  are disabled.  The fix is to check for a disposed widget and\r\n\t*  return without calling the window proc.\r\n\t*/\r\n /*\r\n\t* If we are going to get a WM_CHAR, ensure that last key has\r\n\t* the correct character value for the key down and key up\r\n\t* events.  It is not sufficient to ignore the WM_KEYDOWN\r\n\t* (when we know we are going to get a WM_CHAR) and compute\r\n\t* the key in WM_CHAR because there is not enough information\r\n\t* by the time we get the WM_CHAR.  For example, when the user\r\n\t* types Ctrl+Shift+6 on a US keyboard, we get a WM_CHAR with \r\n\t* wParam=30.  When the user types Ctrl+Shift+6 on a German \r\n\t* keyboard, we also get a WM_CHAR with wParam=30.  On the US\r\n\t* keyboard Shift+6 is ^, on the German keyboard Shift+6 is &.\r\n\t* There is no way to map wParam=30 in WM_CHAR to the correct\r\n\t* value.  Also, on international keyboards, the control key\r\n\t* may be down when the user has not entered a control character.\r\n\t* \r\n\t* NOTE: On Windows 98, keypad keys are virtual despite the\r\n\t* fact that a WM_CHAR is issued.  On Windows 2000 and XP,\r\n\t* they are not virtual.  Therefore it is necessary to force\r\n\t* numeric keypad keys to be virtual.\r\n\t*/\r\n /*\r\n\t\t* Convert LastKey to lower case because Windows non-virtual\r\n\t\t* keys that are also ASCII keys, such as like VK_A, are have\r\n\t\t* upper case values in WM_KEYDOWN despite the fact that the \r\n\t\t* Shift was not pressed.\r\n\t\t*/\r\n /*\r\n\t\t* Feature in Windows. The virtual key VK_CANCEL is treated\r\n\t\t* as both a virtual key and ASCII key by Windows.  This\r\n\t\t* means that a WM_CHAR with WPARAM=3 will be issued for\r\n\t\t* this key.  In order to distinguish between this key and\r\n\t\t* Ctrl+C, mark the key as virtual.\r\n\t\t*/\r\n /*\r\n\t\t* Some key combinations map to Windows ASCII keys depending\r\n\t\t* on the keyboard.  For example, Ctrl+Alt+Q maps to @ on a\r\n\t\t* German keyboard.  If the current key combination is special,\r\n\t\t* the correct character is placed in wParam for processing in\r\n\t\t* WM_CHAR.  If this is the case, issue the key down event from\r\n\t\t* inside WM_CHAR.\r\n\t\t*/\r\n /*\r\n\t\t\t* When the user types Ctrl+Space, ToAscii () maps this to\r\n\t\t\t* Space.  Normally, ToAscii () maps a key to a different\r\n\t\t\t* key if both a WM_KEYDOWN and a WM_CHAR will be issued.\r\n\t\t\t* To avoid the extra SWT.KeyDown, look for a space and\r\n\t\t\t* issue the event from WM_CHAR.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* Feature in Windows. The virtual key VK_CANCEL is treated\r\n\t\t\t* as both a virtual key and ASCII key by Windows.  This\r\n\t\t\t* means that a WM_CHAR with WPARAM=3 will be issued for\r\n\t\t\t* this key. To avoid the extra SWT.KeyDown, look for\r\n\t\t\t* VK_CANCEL and issue the event from WM_CHAR.\r\n\t\t\t*/\r\n /*\r\n\t\t* If the control key is not down at this point, then\r\n\t\t* the key that was pressed was an accent key or a regular\r\n\t\t* key such as 'A' or Shift+A.  In that case, issue the\r\n\t\t* key event from WM_CHAR.\r\n\t\t*/\r\n /*\r\n\t\t* Get the shifted state or convert to lower case if necessary.\r\n\t\t* If the user types Ctrl+A, LastAscii should be 'a', not 'A'. \r\n\t\t* If the user types Ctrl+Shift+A, LastAscii should be 'A'.\r\n\t\t* If the user types Ctrl+Shift+6, the value of LastAscii will\r\n\t\t* depend on the international keyboard.\r\n\t\t*/\r\n /* Note that Ctrl+'@' is ASCII NUL and is delivered in WM_CHAR */\r\n /*\r\n\t\t* Feature in Windows.  The virtual key VK_DELETE is not\r\n\t\t* treated as both a virtual key and an ASCII key by Windows.\r\n\t\t* Therefore, we will not receive a WM_CHAR for this key.\r\n\t\t* The fix is to treat VK_DELETE as a special case and map\r\n\t\t* the ASCII value explictly (Delete is 0x7F).\r\n\t\t*/\r\n /*\r\n\t\t\t* Feature in Windows.  Calling to ToAscii() or ToUnicode(), clears\r\n\t\t\t* the accented state such that the next WM_CHAR loses the accent.\r\n\t\t\t* This makes is critical that the accent key is detected.  Also,\r\n\t\t\t* these functions clear the character that is entered using the\r\n\t\t\t* special Windows keypad sequence when NumLock is down (ie. typing \r\n\t\t\t* ALT+0231 should gives 'c' with a cedilla when NumLock is down).\r\n\t\t\t*/\r\n /*\r\n\t\t* It is possible to get a WM_CHAR for a virtual key when\r\n\t\t* Num Lock is on.  If the user types Home while Num Lock \r\n\t\t* is down, a WM_CHAR is issued with WPARM=55 (for the\r\n\t\t* character 7).  If we are going to get a WM_CHAR we need\r\n\t\t* to ensure that the last key has the correct value.  Note\r\n\t\t* that Ctrl+Home does not issue a WM_CHAR when Num Lock is\r\n\t\t* down.\r\n\t\t*/\r\n /* Check the bit 30 to get the key state */\r\n /* Check for hardware keys */\r\n /*\r\n\t* If the key up is not hooked, reset last key\r\n\t* and last ascii in case the key down is hooked.\r\n\t*/\r\n /*\r\n\t* Bug in WinCE.  MapVirtualKey() returns incorrect values.\r\n\t* The fix is to rely on a key mappings table to determine\r\n\t* whether the key event must be sent now or if a WM_CHAR\r\n\t* event will follow.  The key mappings table maps virtual\r\n\t* keys to SWT key codes and does not contain mappings for\r\n\t* Windows virtual keys like VK_A.  Virtual keys that are\r\n\t* both virtual and ASCII are a special case.\r\n\t*/\r\n /*\r\n\t* Bug in Windows 95 and NT.  When the user types an accent key such\r\n\t* as ^ to get an accented character on a German keyboard, the accent\r\n\t* key should be ignored and the next key that the user types is the\r\n\t* accented key. The fix is to detect the accent key stroke (called\r\n\t* a dead key) by testing the high bit of the value returned by\r\n\t* MapVirtualKey ().  A further problem is that the high bit on\r\n\t* Windows NT is bit 32 while the high bit on Windows 95 is bit 16.\r\n\t* They should both be bit 32.\r\n\t*/\r\n /*\r\n\t* NOTE: On Windows 98, keypad keys are virtual despite the\r\n\t* fact that a WM_CHAR is issued.  On Windows 2000 and XP,\r\n\t* they are not virtual.  Therefore it is necessary to force\r\n\t* numeric keypad keys to be virtual.\r\n\t*/\r\n /*\r\n\t\t* Feature in Windows. The virtual key VK_CANCEL is treated\r\n\t\t* as both a virtual key and ASCII key by Windows.  This\r\n\t\t* means that a WM_CHAR with WPARAM=3 will be issued for\r\n\t\t* this key.  In order to distingush between this key and\r\n\t\t* Ctrl+C, mark the key as virtual.\r\n\t\t*/\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have disposed the widget in the focus\r\n\t* or deactivate events.  If this happens, end the\r\n\t* processing of the Windows message by returning\r\n\t* zero as the result of the window proc.\r\n\t*/\r\n /*\r\n\t* Feature in Windows. Windows sends the following\r\n\t* messages when the user double clicks the mouse:\r\n\t*\r\n\t*\tWM_LBUTTONDOWN\t\t- mouse down\r\n\t*\tWM_LBUTTONUP\t\t- mouse up\r\n\t*\tWM_LBUTTONDBLCLK\t- double click\r\n\t*\tWM_LBUTTONUP\t\t- mouse up\r\n\t*\r\n\t* Applications that expect matching mouse down/up\r\n\t* pairs will not see the second mouse down.  The\r\n\t* fix is to send a mouse down event.\r\n\t*/\r\n /*\r\n\t\t\t* Feature in Windows.  It's possible that the drag\r\n\t\t\t* operation will not be started while the mouse is\r\n\t\t\t* down, meaning that the mouse should be captured.\r\n\t\t\t* This can happen when the user types the ESC key\r\n\t\t\t* to cancel the drag.  The fix is to query the state\r\n\t\t\t* of the mouse and capture the mouse accordingly.\r\n\t\t\t*/\r\n /*\r\n\t\t* Note: On WinCE PPC, only attempt to recognize the gesture for\r\n\t\t* a context menu when the control contains a valid menu or there\r\n\t\t* are listeners for the MenuDetect event.\r\n\t\t*/\r\n /*\r\n\t\t\t* Feature in Windows.  DragDetect() captures the mouse\r\n\t\t\t* and tracks its movement until the user releases the\r\n\t\t\t* left mouse button, presses the ESC key, or moves the\r\n\t\t\t* mouse outside the drag rectangle.  If the user moves\r\n\t\t\t* the mouse outside of the drag rectangle, DragDetect()\r\n\t\t\t* returns true and a drag and drop operation can be\r\n\t\t\t* started.  When the left mouse button is released or\r\n\t\t\t* the ESC key is pressed, these events are consumed by\r\n\t\t\t* DragDetect() so that application code that matches\r\n\t\t\t* mouse down/up pairs or looks for the ESC key will not\r\n\t\t\t* function properly.  The fix is to send the missing\r\n\t\t\t* events when the drag has not started.\r\n\t\t\t* \r\n\t\t\t* NOTE: For now, don't send a fake WM_KEYDOWN/WM_KEYUP\r\n\t\t\t* events for the ESC key.  This would require computing\r\n\t\t\t* wParam (the key) and lParam (the repeat count, scan code,\r\n\t\t\t* extended-key flag, context code, previous key-state flag,\r\n\t\t\t* and transition-state flag) which is non-trivial.\r\n\t\t\t*/\r\n /*\r\n\t* Feature in Windows. Windows sends the following\r\n\t* messages when the user double clicks the mouse:\r\n\t*\r\n\t*\tWM_MBUTTONDOWN\t\t- mouse down\r\n\t*\tWM_MBUTTONUP\t\t- mouse up\r\n\t*\tWM_MLBUTTONDBLCLK\t- double click\r\n\t*\tWM_MBUTTONUP\t\t- mouse up\r\n\t*\r\n\t* Applications that expect matching mouse down/up\r\n\t* pairs will not see the second mouse down.  The\r\n\t* fix is to send a mouse down event.\r\n\t*/\r\n /*\r\n\t\t\t\t\t\t* Force all outstanding WM_MOUSELEAVE messages to be dispatched before\r\n\t\t\t\t\t\t* issuing a mouse enter.  This causes mouse exit events to be processed\r\n\t\t\t\t\t\t* before mouse enter events.  Note that WM_MOUSELEAVE is posted to the\r\n\t\t\t\t\t\t* event queue by TrackMouseEvent().\r\n\t\t\t\t\t\t*/\r\n /* Exit early - don't draw the background */\r\n /* Issue a paint event */\r\n /*\r\n\t\t* Bug in Windows.  When InvalidateRgn(), InvalidateRect()\r\n\t\t* or RedrawWindow() with RDW_INVALIDATE is called from\r\n\t\t* within WM_PAINT to invalidate a region for a further\r\n\t\t* BeginPaint(), the caret is not properly erased causing\r\n\t\t* pixel corruption.  The fix is to hide and show the\r\n\t\t* caret.\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows. Windows sends the following\r\n\t* messages when the user double clicks the mouse:\r\n\t*\r\n\t*\tWM_RBUTTONDOWN\t\t- mouse down\r\n\t*\tWM_RBUTTONUP\t\t- mouse up\r\n\t*\tWM_RBUTTONDBLCLK\t- double click\r\n\t*\tWM_LBUTTONUP\t\t- mouse up\r\n\t*\r\n\t* Applications that expect matching mouse down/up\r\n\t* pairs will not see the second mouse down.  The\r\n\t* fix is to send a mouse down event.\r\n\t*/\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have disposed the widget in the focus\r\n\t* or activate events.  If this happens, end the\r\n\t* processing of the Windows message by returning\r\n\t* zero as the result of the window proc.\r\n\t*/\r\n /* Do not issue a key down if a menu bar mnemonic was invoked */\r\n /* Call the window proc to determine whether it is a system key or mnemonic */\r\n /* Make sure WM_SYSKEYDOWN was sent by ALT-<aKey>. */\r\n /*\r\n\t* Feature in Windows.  When WM_SYSKEYDOWN is sent,\r\n\t* the user pressed ALT+<key> or F10 to get to the\r\n\t* menu bar.  In order to issue events for F10 but\r\n\t* ignore other key presses when the ALT is not down,\r\n\t* make sure that either F10 was pressed or that ALT\r\n\t* is pressed.\r\n\t*/\r\n /* Ignore well known system keys */\r\n /* Ignore repeating modifier keys by testing key down state */\r\n /* Clear last key and last ascii because a new key has been typed */\r\n /*\r\n\t* Bug in WinCE.  MapVirtualKey() returns incorrect values.\r\n\t* The fix is to rely on a key mappings table to determine\r\n\t* whether the key event must be sent now or if a WM_CHAR\r\n\t* event will follow.  The key mappings table maps virtual\r\n\t* keys to SWT key codes and does not contain mappings for\r\n\t* Windows virtual keys like VK_A.  Virtual keys that are\r\n\t* both virtual and ASCII are a special case.\r\n\t*/\r\n /*\r\n\t\t* Convert LastKey to lower case because Windows non-virtual\r\n\t\t* keys that are also ASCII keys, such as like VK_A, are have\r\n\t\t* upper case values in WM_SYSKEYDOWN despite the fact that the \r\n\t\t* Shift was not pressed.\r\n\t\t*/\r\n /*\r\n\t\t* Feature in Windows 98.  MapVirtualKey() indicates that\r\n\t\t* a WM_SYSCHAR message will occur for Alt+Enter but\r\n\t\t* this message never happens.  The fix is to issue the\r\n\t\t* event from WM_SYSKEYDOWN and map VK_RETURN to '\\r'.\r\n\t\t*/\r\n /*\r\n\t\t* Feature in Windows.  The virtual key VK_DELETE is not\r\n\t\t* treated as both a virtual key and an ASCII key by Windows.\r\n\t\t* Therefore, we will not receive a WM_SYSCHAR for this key.\r\n\t\t* The fix is to treat VK_DELETE as a special case and map\r\n\t\t* the ASCII value explictly (Delete is 0x7F).\r\n\t\t*/\r\n /* When a keypad key is typed, a WM_SYSCHAR is not issued */\r\n /*\r\n\t* Feature in Windows. Windows sends the following\r\n\t* messages when the user double clicks the mouse:\r\n\t*\r\n\t*\tWM_XBUTTONDOWN\t\t- mouse down\r\n\t*\tWM_XBUTTONUP\t\t- mouse up\r\n\t*\tWM_XLBUTTONDBLCLK\t- double click\r\n\t*\tWM_XBUTTONUP\t\t- mouse up\r\n\t*\r\n\t* Applications that expect matching mouse down/up\r\n\t* pairs will not see the second mouse down.  The\r\n\t* fix is to send a mouse down event.\r\n\t*/\r\n","CBannerLayout":" Calculate component sizes\r\n  Add up sizes\r\n /*\r\n\t * The paint events must be flushed in order to make the curve draw smoothly\r\n\t * while the user drags the divider.\r\n\t * On Windows, it is necessary to flush the paints before the children are \r\n\t * resized because otherwise the children (particularly toolbars) will flash.\r\n\t */\r\n","CTabItem":" the tab page\r\n  Appearance\r\n  internal constants\r\n  $NON-NLS-1$   if (!isValidThread ()) error (SWT.ERROR_THREAD_INVALID_ACCESS);\r\n  draw X 9x9\r\n  Draw selection border across all tabs\r\n  just draw bottom line\r\n  draw selected tab background and outline\r\n  first point repeated here because below we reuse shape to draw outline\r\n  first point repeated here because below we reuse shape to draw outline\r\n  fill in tab background\r\n  draw outline\r\n  draw Image\r\n  only draw image if it won't overlap with close button\r\n  draw Text\r\n  draw a Focus rectangle\r\n  Do not draw partial items\r\n  draw border\r\n  draw Image\r\n  only draw image if it won't overlap with close button\r\n  draw Text\r\n  draw close\r\n  checkWidget();\r\n  checkWidget();\r\n  by the curve.\r\n  redraw only the image\r\n ","FORMATETC":" ","CoolBar":" /*\r\n\t* Even though it is legal to create this widget\r\n\t* with scroll bars, they serve no useful purpose\r\n\t* because they do not automatically scroll the\r\n\t* widget's client area.  The fix is to clear\r\n\t* the SWT style.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the control is created,\r\n\t* it does not use the default system font.  A new HFONT\r\n\t* is created and destroyed when the control is destroyed.\r\n\t* This means that a program that queries the font from\r\n\t* this control, uses the font in another control and then\r\n\t* destroys this control will have the font unexpectedly\r\n\t* destroyed in the other control.  The fix is to assign\r\n\t* the font ourselves each time the control is created.\r\n\t* The control will not destroy a font that it did not\r\n\t* create.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When inserting an item at end of a row,\r\n\t* sometimes, Windows will begin to place the item on the right\r\n\t* side of the cool bar.  The fix is to resize the new items to\r\n\t* the maximum size and then resize the next to last item to the\r\n\t* ideal size.\r\n\t*/\r\n /*\r\n\t* Feature in Windows. Is possible that the item at index zero\r\n\t* has the RBBS_BREAK flag set. When a new item is inserted at\r\n\t* position zero, the previous item at position zero moves to\r\n\t* a new line.  The fix is to detect this case and clear the\r\n\t* RBBS_BREAK flag on the previous item before inserting the\r\n\t* new item.\r\n\t*/\r\n /* Insert the item */\r\n /* Resize the next to last item to the ideal size */\r\n /*\r\n\t\t\t* Feature in Windows.  If the last item in a row is\r\n\t\t\t* given its ideal size, it will be placed at the far\r\n\t\t\t* right hand edge of the coolbar.  It is preferred\r\n\t\t\t* that the last item appear next to the second last\r\n\t\t\t* item.  The fix is to size the last item of each row \r\n\t\t\t* so that it occupies all the available space to the\r\n\t\t\t* right in the row.\r\n\t\t\t*/\r\n /*\r\n\t* Feature in Windows.  When Windows removed a rebar\r\n\t* band, it makes the band child invisible.  The fix\r\n\t* is to show the child.\r\n\t*/\r\n /*\r\n\t* When a wrapped item is being deleted, make the next\r\n\t* item in the row wrapped in order to preserve the row.\r\n\t* In order to avoid an unnecessary layout, temporarily\r\n\t* ignore WM_SIZE.  If the next item is wrapped then a\r\n\t* row will be deleted and the WM_SIZE is necessary.\r\n\t*/\r\n /* Restore the visible state tof the control */\r\n /*\r\n\t\t* Bug in Windows.  When the style bit  RBS_BANDBORDERS is not set\r\n\t\t* the rectangle returned by RBS_BANDBORDERS is four pixels too small.\r\n\t\t* The fix is to add four pixels to the result.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  When RB_GETBANDBORDERS is sent\r\n\t* with an index out of range, Windows GP's.  The\r\n\t* fix is to ensure the index is in range.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  For some reason, Windows\r\n\t* does not fully erase the coolbar area and coolbar\r\n\t* items when you set the background.  The fix is\r\n\t* to invalidate the coolbar area.\r\n\t*/\r\n /* Ensure that itemOrder does not contain any duplicates. */\r\n /* Move the item */\r\n /*\r\n * Sets the order that the items in the receiver should \r\n * be displayed in to the given argument which is described\r\n * in terms of the zero-relative ordering of when the items\r\n * were added.\r\n *\r\n * @param itemOrder the new order to display the items in\r\n *\r\n * @exception SWTException <ul>\r\n *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\r\n *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\r\n * </ul>\r\n * @exception IllegalArgumentException <ul>\r\n *    <li>ERROR_NULL_ARGUMENT - if the item order is null</li>\r\n *    <li>ERROR_INVALID_ARGUMENT - if the item order is not the same length as the number of items</li>\r\n * </ul>\r\n */\r\n /*\r\n * Sets the width and height of the receiver's items to the ones\r\n * specified by the argument, which is an array of points whose x\r\n * and y coordinates describe the widths and heights (respectively)\r\n * in the order in which the items are currently being displayed.\r\n *\r\n * @param sizes an array containing the new sizes for each of the receiver's items in visual order\r\n *\r\n * @exception IllegalArgumentException <ul>\r\n *    <li>ERROR_NULL_ARGUMENT - if the array of sizes is null</li>\r\n *    <li>ERROR_INVALID_ARGUMENT - if the array of sizes is not the same length as the number of items</li>\r\n * </ul>\r\n * @exception SWTException <ul>\r\n *    <li>ERROR_WIDGET_DISPOSED - if the receiver has been disposed</li>\r\n *    <li>ERROR_THREAD_INVALID_ACCESS - if not called from the thread that created the receiver</li>\r\n * </ul>\r\n */\r\n /*\r\n\t* Feature in Windows.  When the coolbar window\r\n\t* proc processes WM_COMMAND, it forwards this\r\n\t* message to its parent.  This is done so that\r\n\t* children of this control that send this message \r\n\t* type to their parent will notify not only\r\n\t* this control but also the parent of this control,\r\n\t* which is typically the application window and\r\n\t* the window that is looking for the message.\r\n\t* If the control did not forward the message, \r\n\t* applications would have to subclass the control \r\n\t* window to see the message. Because the control\r\n\t* window is subclassed by SWT, the message\r\n\t* is delivered twice, once by SWT and once when\r\n\t* the message is forwarded by the window proc.\r\n\t* The fix is to avoid calling the window proc \r\n\t* for this control.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  For some reason, Windows\r\n\t* does not fully erase the area that the cool bar\r\n\t* occupies when the size of the cool bar is larger\r\n\t* than the space occupied by the cool bar items.\r\n\t* The fix is to erase the cool bar background.\r\n\t* \r\n\t* NOTE: On versions of Windows prior to XP, for\r\n\t* some reason, the cool bar draws separators in\r\n\t* WM_ERASEBKGND.  Therefore it is essential to run\r\n\t* the cool bar window proc after the background has\r\n\t* been erased.\r\n\t* \r\n\t* On XP, this work around is unnecessary because\r\n\t* the background is drawn using NM_CUSTOMDRAW.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the cool bar window\r\n\t* proc processes WM_NOTIFY, it forwards this\r\n\t* message to its parent.  This is done so that\r\n\t* children of this control that send this message \r\n\t* type to their parent will notify not only\r\n\t* this control but also the parent of this control,\r\n\t* which is typically the application window and\r\n\t* the window that is looking for the message.\r\n\t* If the control did not forward the message, \r\n\t* applications would have to subclass the control \r\n\t* window to see the message. Because the control\r\n\t* window is subclassed by SWT, the message\r\n\t* is delivered twice, once by SWT and once when\r\n\t* the message is forwarded by the window proc.\r\n\t* The fix is to avoid calling the window proc \r\n\t* for this control.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When redraw is turned off, the rebar\r\n\t* control does not call the default window proc.  This means\r\n\t* that the rebar will redraw and children of the rebar will\r\n\t* also redraw.  The fix is to call both the rebar window proc\r\n\t* and the default window proc.\r\n\t*\r\n\t* NOTE: The rebar control can resize itself in WM_SETREDRAW.\r\n\t* When redraw is turned off by the default window proc, this\r\n\t* can leave pixel corruption in the parent.  The fix is to\r\n\t* detect the size change and damage the previous area in the\r\n\t* parent.\r\n\t* \r\n\t* NOTE:  In version 6.00 of COMCTL32.DLL, when WM_SETREDRAW\r\n\t* is off, we cannot detect that the size has changed causing\r\n\t* pixel corruption.  The fix is to disallow WM_SETREDRAW by\r\n\t* not running the default window proc or the rebar window\r\n\t* proc.\r\n\t*/\r\n /*\r\n\t\t\t* Bug in Windows.  When Windows sets the size of the rebar band\r\n\t\t\t* child and the child is a combo box, the size of the drop down\r\n\t\t\t* portion of the combo box is resized to zero.  The fix is to set\r\n\t\t\t* the size of the control to the current size after the rebar has\r\n\t\t\t* already resized it.  If the control is not a combo, this does\r\n\t\t\t* nothing.  If the control is a combo, the drop down portion is\r\n\t\t\t* recalculated.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* Bug in Windows.  On versions of Windows prior to XP,\r\n\t\t\t* drawing the background color in NM_CUSTOMDRAW erases\r\n\t\t\t* the separators.  The fix is to draw the background\r\n\t\t\t* in WM_ERASEBKGND.\r\n\t\t\t*/\r\n","DropTargetListener":" ","Button":" FALL THROUGH\r\n  if ((style & SWT.PUSH) != 0) return true;\r\n  setSelection (true);\r\n /*\r\n\t\t\t* Feature in Windows.  The button control mirrors its image when the\r\n\t\t\t* flag WS_EX_LAYOUTRTL is set. This behaviour is not desirable in SWT.\r\n\t\t\t* The fix is to set a mirrored version of real image in the button.\r\n\t\t\t*/\r\n /*\r\n\t* Feature in Windows.  BM_CLICK sends a fake WM_LBUTTONDOWN and\r\n\t* WM_LBUTTONUP in order to click the button.  This causes the\r\n\t* application to get unexpected mouse events.  The fix is to\r\n\t* ignore mouse events when they are caused by BM_CLICK.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When a Button control is right-to-left and\r\n\t* is disabled, the first pixel of the text is clipped.  The fix\r\n\t* is to append a space to the text.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When a radio button gets focus, \r\n\t* it selects the button in WM_SETFOCUS.  Therefore, it\r\n\t* is not necessary to click the button or send events\r\n\t* because this has already happened in WM_SETFOCUS.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When a radio button gets focus, \r\n\t* it selects the button in WM_SETFOCUS.  The fix is to\r\n\t* not assign focus to an unselected radio button.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When a radio button gets focus, \r\n\t* it selects the button in WM_SETFOCUS.  If the previous\r\n\t* saved focus widget was a radio button, allowing the shell\r\n\t* to automatically restore the focus to the previous radio\r\n\t* button will unexpectedly check that button.  The fix is to\r\n\t* not assign focus to an unselected radio button.\r\n\t*/\r\n /*\r\n\t* Feature in Windows. When BM_SETCHECK is used\r\n\t* to set the checked state of a radio or check\r\n\t* button, it sets the WM_TABSTOP style.  This\r\n\t* is undocumented and unwanted.  The fix is\r\n\t* to save and restore the window style bits.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When a Button control is right-to-left and\r\n\t* is disabled, the first pixel of the text is clipped.  The fix\r\n\t* is to append a space to the text.\r\n\t*/\r\n /*\r\n\t* Feature in Windows. When Windows sets focus to\r\n\t* a radio button, it sets the WM_TABSTOP style.\r\n\t* This is undocumented and unwanted.  The fix is\r\n\t* to save and restore the window style bits.\r\n\t*/\r\n /*\r\n\t\t* NOTE: The normal, hot, pressed and disabled state is\r\n\t\t* computed relying on the fact that the increment between\r\n\t\t* the direction states is invariant (always separated by 4).\r\n\t\t*/\r\n","SHELLEXECUTEINFO":" Optional members\r\n  };\r\n ","OlePropertyChangeSink":" Set up property change notification sink\r\n  register each of the interfaces that this object implements\r\n  disconnect property notification sink\r\n ","SCROLLINFO":" ","IFont":" ","SIZE":" ","PngHuffmanTables":" Repeat 0 11-138 times.\r\n  Repeat 0 3-10 times.\r\n  Repeat the previous code 3-6 times.\r\n  Literal value\r\n /* Tricky, tricky, tricky. The length codes are stored in\r\n\t * a very odd order. (For the order, see the definition of\r\n\t * the static field lengthCodeOrder.) Also, the data may \r\n\t * not contain values for all the codes. It may just contain \r\n\t * values for the first X number of codes. The table should\r\n\t * be of size <LengthCodeTableSize> regardless of the number\r\n\t * of values actually given in the table.\r\n\t */\r\n","JPEGStartOfImage":" ","NMREBARCHILDSIZE":" RECT rcChild;\r\n  RECT rcBand;\r\n ","ShellListener":" ","Transfer":" If name already exists in registry, return its assigned value\r\n ","COMPOSITIONFORM":" POINT ptCurrentPos;\r\n  RECT rcArea;\r\n ","IConnectionPoint":" ","Link":" TEMPORARY CODE\r\n  temporary code to disable text selection\r\n  $NON-NLS-1$\r\n /*\r\n\t* Feature in Windows.  For some reason, setting\r\n\t* LIS_ENABLED state using LM_SETITEM causes the\r\n\t* SysLink to become enabled.  To be specific,\r\n\t* calling IsWindowEnabled() returns true.  The\r\n\t* fix is disable the SysLink after LM_SETITEM.\r\n\t*/\r\n /*\r\n\t\t\t\t* NOTE: Call the window proc with WM_KEYDOWN rather than WM_CHAR\r\n\t\t\t\t* so that the key that was ignored during WM_KEYDOWN is processed.\r\n\t\t\t\t* This allows the application to cancel an operation that is normally\r\n\t\t\t\t* performed in WM_KEYDOWN from WM_CHAR.\r\n\t\t\t\t*/\r\n /*\r\n\t\t\t\t* Ensure that the window proc does not process VK_SPACE,\r\n\t\t\t\t* VK_RETURN or VK_TAB so that it can be handled in WM_CHAR.\r\n\t\t\t\t* This allows the application to cancel an operation that\r\n\t\t\t\t* is normally performed in WM_KEYDOWN from WM_CHAR.\r\n\t\t\t\t*/\r\n","MENUINFO":" ","OleFrame":" Interfaces for this Ole Client Container\r\n  Access to the embedded  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  set up widget attributes\r\n  setup cleanup proc\r\n  inform inplaceactiveobject whenever frame resizes\r\n  inform inplaceactiveobject whenever frame moves\r\n  with them.\r\n  Check for focus change\r\n  ignore popup menus and dialogs\r\n  $NON-NLS-1$\r\n  by the application, zero out message, wParam and lParam\r\n  Create each of the interfaces that this object implements\r\n  method13 EnableModeless - not implemented\r\n  Coordinates must be relative to the window\r\n  locate menu bar\r\n  the OS and the OS will fill in the requested information for each menu.\r\n  item from the OS.\r\n  lpmii.cch gets updated by GetMenuItemInfo to indicate the\r\n  keep track of the number of items\r\n  before each call.\r\n  copy the menu item count information to the pointer\r\n  item from the OS.\r\n  lpmii.cch gets updated by GetMenuItemInfo to indicate the\r\n  keep track of the number of items\r\n  before each call.\r\n  copy the menu item count information to the pointer\r\n  item from the OS.\r\n  lpmii.cch gets updated by GetMenuItemInfo to indicate the\r\n  keep track of the number of items\r\n  before each call.\r\n  copy the menu item count information to the pointer\r\n  free resources used in querying the OS\r\n  implements IUnknown, IOleInPlaceFrame, IOleContainer, IOleInPlaceUIWindow\r\n  get Id from original menubar\r\n  passing NULL as the pborderwidths parameter.\r\n  re-instate the original menu - this occurs on deactivation\r\n /* Allow activeX control to translate accelerators except when a menu is active. */\r\n /* Allow OleClientSite to process key events before activeX control */\r\n /*\r\n\tThe IOleInPlaceUIWindow::GetBorder function, when called on a document or frame window \r\n\tobject, returns the outer rectangle (relative to the window) where the object can put \r\n\ttoolbars or similar controls.\r\n\t*/\r\n","SHRGINFO":" POINT ptDown\r\n ","SHACTIVATEINFO":" :1\r\n  :1\r\n  :1\r\n  :29\r\n ","FontDialog":" /* Get the owner HWND for the dialog */\r\n /* Open the dialog */\r\n /* Make the parent shell be temporary modal */\r\n /* Open the dialog */\r\n /* Clear the temporary dialog modal parent */\r\n /*\r\n\t\t * This will not work on multiple screens or\r\n\t\t * for printing. Should use DC for the proper device.\r\n\t\t */\r\n /*\r\n\t\t\t * Feature in Windows. If the lfHeight of the LOGFONT structure\r\n\t\t\t * is positive, the lfHeight measures the height of the entire\r\n\t\t\t * cell, including internal leading, in logical units. Since the\r\n\t\t\t * height of a font in points does not include the internal leading,\r\n\t\t\t * we must subtract the internal leading, which requires a TEXTMETRIC,\r\n\t\t\t * which in turn requires font creation.\r\n\t\t\t */\r\n /* Compute the result */\r\n /* Free the OS memory */\r\n","CTabFolder2Listener":" ","AccessibleControlEvent":" IN  OUT\r\n  IN  OUT\r\n  IN  OUT\r\n  [OUT]\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n ","StyleRange":" style start offset. 0 based from the document start\r\n  style length.\r\n  may be SWT.NORMAL, SWT.ITALIC or SWT.BOLD\r\n ","BUTTON_IMAGELIST":" ","Font":" ","DisplayRenderer":" used to get content and styles during rendering\r\n  offset of this line?\r\n  render the line break selection\r\n ","MouseListener":" ","TransferData":" ","SWTEventObject":" ","TBBUTTONINFO":" ","VerifyEvent":" remove trailing '}'\r\n ","ProgressBar":" /*\r\n\t\t* Feature in Windows.  The progress bar window class\r\n\t\t* does not include CS_DBLCLKS.  This mean that these\r\n\t\t* controls will not get double click messages such as\r\n\t\t* WM_LBUTTONDBLCLK.  The fix is to register a new \r\n\t\t* window class with CS_DBLCLKS.\r\n\t\t* \r\n\t\t* NOTE:  Screen readers look for the exact class name\r\n\t\t* of the control in order to provide the correct kind\r\n\t\t* of assistance.  Therefore, it is critical that the\r\n\t\t* new window class have the same name.  It is possible\r\n\t\t* to register a local window class with the same name\r\n\t\t* as a global class.  Since bits that affect the class\r\n\t\t* are being changed, it is possible that other native\r\n\t\t* code, other than SWT, could create a control with\r\n\t\t* this class name, and fail unexpectedly.\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows.  The progress bar does\r\n\t* not implement WM_GETDLGCODE.  As a result,\r\n\t* a progress bar takes focus and takes part\r\n\t* in tab traversal.  This behavior, while\r\n\t* unspecified, is unwanted.  The fix is to\r\n\t* implement WM_GETDLGCODE to behave like a\r\n\t* STATIC control.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When a progress bar with the style\r\n\t* PBS_MARQUEE becomes too small, the animation (currently\r\n\t* a small bar moving from right to left) does not have\r\n\t* enough space to draw.  The result is that the progress\r\n\t* bar does not appear to be moving.  The fix is to detect\r\n\t* this case, clear the PBS_MARQUEE style and emulate the\r\n\t* animation using PBM_STEPIT.\r\n\t* \r\n\t* NOTE:  This only happens on Window XP.\r\n\t*/\r\n","Path":" TODO - expose connect?\r\n  TODO - should use GC transformation\r\n /*\r\n\t* Feature in GDI+. CloseFigure() does affect the last\r\n\t* point, so GetLastPoint() does not return the starting\r\n\t* point of the subpath after calling CloseFigure().  The\r\n\t* fix is to remember the subpath starting point and use\r\n\t* it instead.\r\n\t*/\r\n","FormLayout":" TEMPORARY CODE\r\n /*\r\n * Computes the preferred height of the form with\r\n * respect to the preferred height of the control.\r\n * \r\n * Given that the equations for top (T) and bottom (B)\r\n * of the control in terms of the height of the form (X)\r\n * are:\r\n *\t\tT = AX + B\r\n *\t\tB = CX + D\r\n * \r\n * The equation for the height of the control (H)\r\n * is bottom (B) minus top (T) or (H = B - T) or:\r\n * \r\n *\t\tH = (CX + D) - (AX + B)\r\n * \r\n * Solving for (X), the height of the form, we get:\r\n * \r\n *\t\tX = (H + B - D) / (C - A)\r\n * \r\n * When (A = C), (C - A = 0) and the equation has no\r\n * solution for X.  This is a special case meaning that\r\n * the control does not constrain the height of the\r\n * form.  In this case, we need to arbitrarily define\r\n * the height of the form (X):\r\n * \r\n * Case 1: A = C, A = 0, C = 0\r\n *\r\n * \t\tLet X = D, the distance from the top of the form\r\n * \t\tto the bottom edge of the control.  In this case,\r\n * \t\tthe control was attatched to the top of the form\r\n * \t\tand the form needs to be large enough to show the\r\n * \t\tbottom edge of the control.\r\n * \r\n * Case 2: A = C, A = 1, C = 1\r\n * \r\n * \t\tLet X = -B, the distance from the bottom of the\r\n *\t\tform to the top edge of the control.  In this case,\r\n * \t\tthe control was attached to the bottom of the form\r\n * \t\tand the only way that the control would be visible\r\n * \t\tis if the offset is negative.  If the offset is\r\n * \t\tpositive, there is no possible height for the form\r\n * \t\tthat will show the control as it will always be\r\n * \t\tbelow the bottom edge of the form.\r\n * \r\n * Case 3: A = C, A != 0, C != 0 and A != 1, C != 0\r\n * \r\n * \t\tLet X = D / (1 - C), the distance from the top of the \r\n * \t\tform to the bottom edge of the control.  In this case, \r\n * \t\tsince C is not 0 or 1, it must be a fraction, U / V.  \r\n * \t\tThe offset D is the distance from CX to the bottom edge \r\n * \t\tof the control.  This represents a fraction of the form \r\n * \t\t(1 - C)X. Since the height of a fraction of the form is \r\n * \t\tknown, the height of the entire form can be found by setting\r\n * \t\t(1 - C)X = D.  We solve this equation for X in terms of U \r\n * \t\tand V, giving us X = (U * D) / (U - V). Similarily, if the \r\n * \t\toffset D is\tnegative, the control is positioned above CX.\r\n * \t\tThe offset -B is the distance from the top edge of the control\r\n * \t\tto CX. We can find the height of the entire form by setting \r\n * \t\tCX = -B. Solving in terms of U and V gives us X = (-B * V) / U.\r\n */\r\n /*\r\n * Computes the preferred height of the form with\r\n * respect to the preferred height of the control.\r\n */\r\n","JPEGArithmeticConditioningTable":" ","ACC":" ","MouseEvent":" remove trailing '}'\r\n ","TraverseListener":" ","CTabFolderEvent":" remove trailing '}'\r\n ","DragSource":" info for registering as a drag source\r\n  ole interfaces\r\n  workaround - track the operation performed by the drop target for DragEnd event\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  register each of the interfaces that this object implements\r\n  method4 GetDataHere - not implemented\r\n  method6 GetCanonicalFormatEtc - not implemented\r\n  only allow getting of data - SetData is not currently supported\r\n  what types have been registered?\r\n  get matching transfer agent to perform conversion\r\n  is this type supported by the transfer agent?\r\n /* Called by a data consumer to obtain data from a source data object. \r\n\t   The GetData method renders the data described in the specified FORMATETC \r\n\t   structure and transfers it through the specified STGMEDIUM structure. \r\n\t   The caller then assumes responsibility for releasing the STGMEDIUM structure.\r\n\t*/\r\n","StyledTextPrintOptions":" ","ProgressListener":" ","PngChunkReader":" ","Layout":" ","WindowEvent":" ","ToolBar":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n /*\r\n\t* From the Windows SDK for TB_SETBUTTONSIZE:\r\n\t*\r\n\t*   \"If an application does not explicitly\r\n\t*\tset the button size, the size defaults\r\n\t*\tto 24 by 22 pixels\". \r\n\t*/\r\n /*\r\n\t* Ensure that either of HORIZONTAL or VERTICAL is set.\r\n\t* NOTE: HORIZONTAL and VERTICAL have the same values\r\n\t* as H_SCROLL and V_SCROLL so it is necessary to first\r\n\t* clear these bits to avoid scroll bars and then reset\r\n\t* the bits using the original style supplied by the\r\n\t* programmer.\r\n\t* \r\n\t* NOTE: The CCS_VERT style cannot be applied when the\r\n\t* widget is created because of this conflict.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  For some reason, during the processing\r\n\t* of WM_SYSCHAR, the tool bar window proc does not call the\r\n\t* default window proc causing mnemonics for the menu bar\r\n\t* to be ignored.  The fix is to always call the default\r\n\t* window proc for WM_SYSCHAR.\r\n\t*/\r\n /*\r\n\t* On Windows, only flat tool bars can be traversed.\r\n\t*/\r\n /*\r\n\t* A vertical tool bar cannot wrap because TB_SETROWS\r\n\t* fails when the toobar has TBSTYLE_WRAPABLE.\r\n\t*/\r\n /*\r\n\t* Even though it is legal to create this widget\r\n\t* with scroll bars, they serve no useful purpose\r\n\t* because they do not automatically scroll the\r\n\t* widget's client area.  The fix is to clear\r\n\t* the SWT style.\r\n\t*/\r\n /*\r\n\t* From the Windows SDK for TB_SETBUTTONSIZE:\r\n\t*\r\n\t*   \"If an application does not explicitly\r\n\t*\tset the button size, the size defaults\r\n\t*\tto 24 by 22 pixels\". \r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When TBSTYLE_FLAT is used to create\r\n\t* a flat toolbar, for some reason TBSTYLE_TRANSPARENT is\r\n\t* also set.  This causes the toolbar to flicker when it is\r\n\t* moved or resized.  The fix is to clear TBSTYLE_TRANSPARENT.\r\n\t* \r\n\t* NOTE:  This work around is unnecessary on XP.  There is no\r\n\t* flickering and clearing the TBSTYLE_TRANSPARENT interferes\r\n\t* with the XP theme.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the control is created,\r\n\t* it does not use the default system font.  A new HFONT\r\n\t* is created and destroyed when the control is destroyed.\r\n\t* This means that a program that queries the font from\r\n\t* this control, uses the font in another control and then\r\n\t* destroys this control will have the font unexpectedly\r\n\t* destroyed in the other control.  The fix is to assign\r\n\t* the font ourselves each time the control is created.\r\n\t* The control will not destroy a font that it did not\r\n\t* create.\r\n\t*/\r\n /* Set the button struct, bitmap and button sizes */\r\n /* Set the extended style bits */\r\n /*\r\n\t* Bug in Windows.  Despite the fact that the image list\r\n\t* index has never been set for the item, Windows always\r\n\t* assumes that the image index for the item is valid.\r\n\t* When an item is inserted, the image index is zero.\r\n\t* Therefore, when the first image is inserted and is\r\n\t* assigned image index zero, every item draws with this\r\n\t* image.  The fix is to set the image index to none\r\n\t* when the item is created.  This is not necessary in\r\n\t* the case when the item has the BTNS_SEP style because\r\n\t* separators cannot show images.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  For some reason, a tool item that has\r\n\t* the style BTNS_SEP does not return I_IMAGENONE when queried\r\n\t* for an image index, despite the fact that no attempt has been\r\n\t* made to assign an image to the item.  As a result, operations\r\n\t* on an image list that use the wrong index cause random results.\t\r\n\t* The fix is to ensure that the tool item is not a separator\r\n\t* before using the image index.  Since separators cannot have\r\n\t* an image and one is never assigned, this is not a problem.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When a tool item with the style\r\n\t* BTNS_CHECK or BTNS_CHECKGROUP is selected and then\r\n\t* disabled, the item does not draw using the disabled\r\n\t* image.  The fix is to use the disabled image in all\r\n\t* image lists.\r\n\t*/\r\n /*\r\n\t*  When the tool bar is vertical, make the width of each button\r\n\t*  be the width of the widest button in the tool bar.  Note that\r\n\t*  when the tool bar contains a drop down item, it needs to take\r\n\t*  into account extra padding.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  TB_MAPACCELERATOR matches either the mnemonic\r\n\t* character or the first character in a tool item.  This behavior is\r\n\t* undocumented and unwanted.  The fix is to ensure that the tool item\r\n\t* contains a mnemonic when TB_MAPACCELERATOR returns true.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When TBSTYLE_TRANSPARENT is set\r\n\t* in a tool bar that is drawing a background, image in\r\n\t* the image list that include transparency information\r\n\t* do not draw correctly.  The fix is to clear and set\r\n\t* TBSTYLE_TRANSPARENT depending on the background color.\r\n\t* \r\n\t* NOTE:  This work around is unnecessary on XP.  The\r\n\t* TBSTYLE_TRANSPARENT style is never cleared on that\r\n\t* platform.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  For some reason, when a tool bar is\r\n\t* repositioned more than once using DeferWindowPos () into\r\n\t* the same HDWP, the toolbar redraws more than once, defeating\r\n\t* the puropse of DeferWindowPos ().  The fix is to end the\r\n\t* defered positioning before the next tool bar is added,\r\n\t* ensuring that only one tool bar position is deferred at\r\n\t* any given time.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When WM_SETFONT is sent to a tool bar\r\n\t* that contains only separators, causes the bitmap and button\r\n\t* sizes to be set.  The fix is to reset these sizes after the font\r\n\t* has been changed when the tool bar contains only separators.\r\n\t*/\r\n /*\r\n\t\t* Feature in Windows.  When the TB_SETROWS is used to set the\r\n\t\t* number of rows in a tool bar, the tool bar is resized to show\r\n\t\t* the items.  This is unexpected.  The fix is to save and restore\r\n\t\t* the current size of the tool bar.\r\n\t\t*/\r\n /*\r\n\t\t* Feature in Windows.  When the last button in a tool bar has the\r\n\t\t* style BTNS_SEP and TB_SETROWS is used to set the number of rows\r\n\t\t* in the tool bar, depending on the number of buttons, the toolbar\r\n\t\t* will wrap items with the style BTNS_CHECK, even when the fLarger\r\n\t\t* flags is used to force the number of rows to be larger than the\r\n\t\t* number of items.  The fix is to set the number of rows to be two\r\n\t\t* larger than the actual number of rows in the tool bar.  When items\r\n\t\t* are being added, as long as the number of rows is at least one\r\n\t\t* item larger than the count, the tool bar is laid out properly.\r\n\t\t* When items are being removed, setting the number of rows to be\r\n\t\t* one more than the item count has no effect.  The number of rows\r\n\t\t* is already one more causing TB_SETROWS to do nothing.  Therefore,\r\n\t\t* choosing two instead of one as the row increment fixes both cases.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  When the tool bar loses capture while an\r\n\t* item is pressed in WM_LBUTTONDOWN, the item remains pressed.\r\n\t* The fix is unpress the item using TB_SETSTATE.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the toolbar window\r\n\t* proc processes WM_COMMAND, it forwards this\r\n\t* message to its parent.  This is done so that\r\n\t* children of this control that send this message \r\n\t* type to their parent will notify not only\r\n\t* this control but also the parent of this control,\r\n\t* which is typically the application window and\r\n\t* the window that is looking for the message.\r\n\t* If the control did not forward the message, \r\n\t* applications would have to subclass the control \r\n\t* window to see the message. Because the control\r\n\t* window is subclassed by SWT, the message\r\n\t* is delivered twice, once by SWT and once when\r\n\t* the message is forwarded by the window proc.\r\n\t* The fix is to avoid calling the window proc \r\n\t* for this control.\r\n\t*/\r\n /*\r\n\t* Return DLGC_BUTTON so that mnemonics will be\r\n\t* processed without needing to press the ALT key\r\n\t* when the widget has focus.\r\n\t*/\r\n /*\r\n\t\t\t* Ensure that the window proc does not process VK_SPACE\r\n\t\t\t* so that it can be handled in WM_CHAR.  This allows the\r\n\t\t\t* application the opportunity to cancel the operation.\r\n\t\t\t*/\r\n /*\r\n\t* Feature in Windows.  When the toolbar window\r\n\t* proc processes WM_NOTIFY, it forwards this\r\n\t* message to its parent.  This is done so that\r\n\t* children of this control that send this message \r\n\t* type to their parent will notify not only\r\n\t* this control but also the parent of this control,\r\n\t* which is typically the application window and\r\n\t* the window that is looking for the message.\r\n\t* If the control did not forward the message, \r\n\t* applications would have to subclass the control \r\n\t* window to see the message. Because the control\r\n\t* window is subclassed by SWT, the message\r\n\t* is delivered twice, once by SWT and once when\r\n\t* the message is forwarded by the window proc.\r\n\t* The fix is to avoid calling the window proc \r\n\t* for this control.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  The code in Windows that determines\r\n\t* when tool items should wrap seems to use the window\r\n\t* bounds rather than the client area.  Unfortunately,\r\n\t* tool bars with the style TBSTYLE_EX_HIDECLIPPEDBUTTONS\r\n\t* use the client area.  This means that buttons which\r\n\t* overlap the border are hidden before they are wrapped.\r\n\t* The fix is to compute TBSTYLE_EX_HIDECLIPPEDBUTTONS\r\n\t* and set it each time the tool bar is resized.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When a flat tool bar is wrapped,\r\n\t* Windows draws a horizontal separator between the\r\n\t* rows.  The tool bar does not draw the first or\r\n\t* the last two pixels of this separator.  When the\r\n\t* toolbar is resized to be bigger, only the new\r\n\t* area is drawn and the last two pixels, which are\r\n\t* blank are drawn over by separator.  This leaves\r\n\t* garbage on the screen.  The fix is to damage the\r\n\t* pixels.\r\n\t*/\r\n","KeyListener":" ","PngTrnsChunk":" Three 2-byte values (RGB)\r\n  Three 2-byte values (RGB)\r\n  One 2-byte value\r\n  Cannot use both Alpha and tRNS\r\n ","Tracker":" $NON-NLS-1$\r\n  apply the bounds adjustment\r\n /*\r\n\t* The following values mirror step sizes on Windows\r\n\t*/\r\n /*\r\n\t * Convert to screen coordinates iff needed\r\n \t */\r\n /*\r\n\t * Convert to screen coordinates iff needed\r\n\t */\r\n /*\r\n\t* If the client has not provided a custom cursor then determine\r\n\t* the appropriate resize cursor.\r\n\t*/\r\n /*\r\n\t* If exactly one of UP/DOWN is specified as a style then set the cursor\r\n\t* orientation accordingly (the same is done for LEFT/RIGHT styles below).\r\n\t*/\r\n /*\r\n\t* If this tracker is being created without a mouse drag then\r\n\t* we need to create a transparent window that fills the screen\r\n\t* in order to get all mouse/keyboard events that occur\r\n\t* outside of our visible windows (ie.- over the desktop).\r\n\t*/\r\n /* Tracker behaves like a Dialog with its own OS event loop. */\r\n /*\r\n\t* Cleanup: If a transparent window was created in order to capture events then\r\n\t* destroy it and its callback object now.\r\n\t*/\r\n /*\r\n\t* Cleanup: If this tracker was resizing then the last cursor that it created\r\n\t* needs to be destroyed.\r\n\t*/\r\n /*\r\n\t* If the cursor orientation has not been set in the orientation of\r\n\t* this change then try to set it here.\r\n\t*/\r\n /*\r\n\t * If the bounds will flip about the x or y axis then apply the adjustment\r\n\t * up to the axis (ie.- where bounds width/height becomes 0), change the\r\n\t * cursor's orientation accordingly, and flip each Rectangle's origin (only\r\n\t * necessary for > 1 Rectangles) \r\n\t */\r\n /*\r\n\t\t* We typically do not want to answer that the transparent window is\r\n\t\t* transparent to hits since doing so negates the effect of having it\r\n\t\t* to grab events.  However, clients of the tracker should not be aware\r\n\t\t* of this transparent window.  Therefore if there is a hit query\r\n\t\t* performed as a result of client code then answer that the transparent\r\n\t\t* window is transparent to hits so that its existence will not impact\r\n\t\t* the client.\r\n\t\t*/\r\n /*\r\n\t\t\t* It is possible (but unlikely) that application\r\n\t\t\t* code could have disposed the widget in the move\r\n\t\t\t* event.  If this happens return false to indicate\r\n\t\t\t* that the tracking has failed.\r\n\t\t\t*/\r\n /*\r\n\t\t\t * It is possible that application code could have\r\n\t\t\t * changed the rectangles in the move event.  If this\r\n\t\t\t * happens then only redraw the tracker if the rectangle\r\n\t\t\t * values have changed.\r\n\t\t\t */\r\n /*\r\n\t\t\t* It is possible (but unlikely) that application\r\n\t\t\t* code could have disposed the widget in the resize\r\n\t\t\t* event.  If this happens return false to indicate\r\n\t\t\t* that the tracking has failed.\r\n\t\t\t*/\r\n /*\r\n\t\t\t * It is possible that application code could have\r\n\t\t\t * changed the rectangles in the resize event.  If this\r\n\t\t\t * happens then only redraw the tracker if the rectangle\r\n\t\t\t * values have changed.\r\n\t\t\t */\r\n /*\r\n\t\t\t* It is possible (but unlikely), that application\r\n\t\t\t* code could have disposed the widget in the move\r\n\t\t\t* event.  If this happens, return false to indicate\r\n\t\t\t* that the tracking has failed.\r\n\t\t\t*/\r\n /*\r\n\t\t\t * It is possible that application code could have\r\n\t\t\t * changed the rectangles in the move event.  If this\r\n\t\t\t * happens then only redraw the tracker if the rectangle\r\n\t\t\t * values have changed.\r\n\t\t\t */\r\n /*\r\n\t\t\t* It is possible (but unlikely), that application\r\n\t\t\t* code could have disposed the widget in the resize\r\n\t\t\t* event.  If this happens, return false to indicate\r\n\t\t\t* that the tracking has failed.\r\n\t\t\t*/\r\n /*\r\n\t\t\t * It is possible that application code could have\r\n\t\t\t * changed the rectangles in the resize event.  If this\r\n\t\t\t * happens then only redraw the tracker if the rectangle\r\n\t\t\t * values have changed.\r\n\t\t\t */\r\n","CTabFolder":" index of the left most visible tab.\r\n  support for deprecated listener mechanism\r\n  close, min  borders and shapes\r\n  change the selection as each child is destroyed.\r\n  on Resize\r\n  tooltip\r\n  internal constants\r\n  showMax = (style2 & SWT.MAX) != 0; - conflicts with SWT.BOTTOM\r\n  set up default colors\r\n  Add all listeners\r\n  FALL THROUGH\r\n  TOP is the default\r\n  MULTI is the default\r\n  reduce the flash by not redrawing the entire area on a Resize event\r\n  $NON-NLS-1$   NOTE: region passed in to this function will be modified\r\n  add to array\r\n  add to array\r\n  display close button to be backwards compatible\r\n  $NON-NLS-1$\r\n  Don't perform anti-aliasing on low resolution displays\r\n  move the selection if this item is selected\r\n  draw a solid background using default background in shape\r\n  horizontal gradient\r\n  draw gradient\r\n  draw the background image in shape\r\n  If horizontal gradient, show gradient across the whole area\r\n  Draw highlight margin\r\n  Draw client area\r\n  fill in body\r\n  left\r\n  right\r\n  bottom\r\n  top\r\n  draw 1 pixel border around outside\r\n  draw chevron (10x7)\r\n  $NON-NLS-1$\r\n  5x4 or 7x9\r\n  5x4 or 9x3\r\n  If horizontal gradient, show gradient across the whole area\r\n  draw 1 pixel border\r\n  Draw Tab Header\r\n  Fill in background\r\n  Fill in parent background for non-rectangular shape\r\n  Draw the unselected tabs.\r\n  if no selected tab - draw line across bottom of all tabs\r\n  Draw selected tab\r\n  Draw Buttons\r\n  Draw border line\r\n  checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n  -1 for line drawn across top of tab\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  handle case where  default font changes\r\n  rounded top right corner\r\n  Don't use gradients on low color displays\r\n  Are these settings the same as before?\r\n  Store the new settings\r\n  Refresh with the new settings\r\n  max button\r\n  min button\r\n  top right control\r\n  fill size is 0 if chevron showing\r\n  fill size is 0 if item compressed\r\n  chevron button\r\n  off screen\r\n  off screen\r\n  First, try the minimum tab size at full compression.\r\n  determine compression for each item\r\n  no compression required\r\n  full compression required and a chevron\r\n  display maximize button\r\n  display maximize button\r\n  Don't use gradients on low color displays\r\n  Are these settings the same as before?\r\n  Store the new settings\r\n  Refresh with the new settings\r\n  display close button when mouse hovers\r\n  display image on unselected items\r\n  move to front of mru order\r\n  $NON-NLS-1$\r\n  make sure selected item will be showing\r\n  $NON-NLS-1$\r\n  +1 for line drawn across top of tab\r\n  $NON-NLS-1$   $NON-NLS-1$   $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  the arrow cursor on Windows\r\n /* sizing, positioning */\r\n /* item management */\r\n /* External Listener management */\r\n /* Selected item appearance */\r\n /* Unselected item appearance */\r\n /*\r\n\t * The default background on carbon and some GTK themes is not a solid color \r\n\t * but a texture.  To show the correct default background, we must allow\r\n\t * the operating system to draw it and therefore, we can not use the \r\n\t * NO_BACKGROUND style.  The NO_BACKGROUND style is not required on platforms\r\n\t * that use double buffering which is true in both of these cases.\r\n\t */\r\n /*\r\n\t * In Right To Left orientation on Windows, all GC calls that use a brush are drawing \r\n\t * offset by one pixel.  This results in some parts of the CTabFolder not drawing correctly.\r\n\t * To alleviate some of the appearance problems, allow the OS to draw the background.\r\n\t * This does not draw correctly but the result is less obviously wrong.\r\n\t */\r\n /*\r\n\t * Usually when an item is disposed, destroyItem will change the size of the items array, \r\n\t * reset the bounds of all the tabs and manage the widget associated with the tab.\r\n\t * Since the whole folder is being disposed, this is not necessary.  For speed\r\n\t * the inDispose flag is used to skip over this part of the item dispose.\r\n\t */\r\n /*\r\n\t * On some platforms, there is a minimum size for a shell  \r\n\t * which may be greater than the label size.\r\n\t * To avoid having the background of the tip shell showing\r\n\t * around the label, force the label to fill the entire client area.\r\n\t */\r\n /*\r\n\t * Position the tooltip and ensure that it is not located off\r\n\t * the screen.\r\n\t */\r\n","DIBSECTION":" ","PngLzBlockReader":" ","KeyAdapter":" ","TableTree":" $NON-NLS-1$\r\n  the TableTree adapting to changes in the System color settings.\r\n  checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n  Leave at least a 6 pixel border.\r\n  size must be an even number\r\n  checkWidget();\r\n /*\r\n\t* TableTreeItems are not treated as children but rather as items.\r\n\t* When the TableTree is disposed, all children are disposed because \r\n\t* TableTree inherits this behaviour from Composite.  The items\r\n\t* must be disposed separately.  Because TableTree is not part of\r\n\t* the org.eclipse.swt.widgets package, the method releaseWidget can \r\n\t* not be overriden (this is how items are disposed of in Table and Tree).\r\n\t* Instead, the items are disposed of in response to the dispose event on the\r\n\t* TableTree.  The \"inDispose\" flag is used to distinguish between disposing\r\n\t* one TableTreeItem (e.g. when removing an entry from the TableTree) and \r\n\t* disposing the entire TableTree.\r\n\t*/\r\n /* Return the index in the table where this table should be inserted */\r\n /* Expand upward from the specified leaf item. */\r\n /* Plus image */\r\n /* Minus image */\r\n /*\r\n\t * Usually when an item is disposed, destroyItem will change the size of the items array\r\n\t * and dispose of the underlying table items.\r\n\t * Since the whole table tree is being disposed, this is not necessary.  For speed\r\n\t * the inDispose flag is used to skip over this part of the item dispose.\r\n\t */\r\n /* If user clicked on the [+] or [-], expand or collapse the tree. */\r\n","TreeAdapter":" ","ProgressEvent":" ","VisibilityWindowAdapter":" ","FILETIME":" ","TextStyle":" $NON-NLS-1$ ","TIFFFileFormat":" /* A baseline reader is only expected to read the first directory */\r\n","Dialog":" ","ImageData":" may throw an IndexOutOfBoundsException\r\n  may throw an IndexOutOfBoundsException\r\n  copy source directly, else applies logic operations\r\n  enable alpha blending\r\n  enable dithering in low color modes\r\n  Fully opaque (ignores any alpha data)\r\n  Fully transparent (ignores any alpha data)\r\n  Use alpha channel from separate alphaData\r\n  Use alpha channel embedded in sourceData\r\n  Use transparency mask formed by bytes in alphaData (non-zero is opaque)\r\n  Use transparency mask formed by packed bits in alphaData\r\n  Consider source palette indices transparent if in alphaData array\r\n  Consider source RGBs transparent if in RGB888 format alphaData array\r\n  direct   palette indexed color formats\r\n  these should be supplied as params later\r\n  throw new IllegalArgumentException(\"Invalid source type\");\r\n  throw new IllegalArgumentException(\"Invalid destination type\");\r\n  throw new IllegalArgumentException(\"Invalid alpha type\");\r\n  prescale\r\n  Perform alpha blending\r\n  throw new IllegalArgumentException(\"Invalid source type\");\r\n  throw new IllegalArgumentException(\"Invalid source type\");\r\n  prescale\r\n  could speed up using binary search if we sorted the indices\r\n  Perform alpha blending\r\n  Floyd-Steinberg error diffusion\r\n  moving the variable declarations out seems to make the JDK JIT happier...\r\n  Floyd-Steinberg error diffusion, cont'd...\r\n  these should be supplied as params later\r\n  throw new IllegalArgumentException(\"Invalid source type\");\r\n  throw new IllegalArgumentException(\"Invalid destination type\");\r\n  prescale\r\n  could speed up using binary search if we sorted the indices\r\n  Perform alpha blending\r\n  these should be supplied as params later\r\n  throw new IllegalArgumentException(\"Invalid source type\");\r\n  throw new IllegalArgumentException(\"Invalid source type\");\r\n  throw new IllegalArgumentException(\"Invalid alpha type\");\r\n  prescale\r\n  Perform alpha blending\r\n  Floyd-Steinberg error diffusion\r\n  moving the variable declarations out seems to make the JDK JIT happier...\r\n  Floyd-Steinberg error diffusion, cont'd...\r\n /* Create a destination image with no data */\r\n /* Scale the image contents */\r\n /* Scale the image mask or alpha */\r\n /* Find index of black in mask palette */\r\n /* Gradients are drawn as tiled bands */\r\n /* Dithered two tone */\r\n /* Dithered color */\r\n /* Precise color */\r\n /* Select an algorithm depending on the depth of the screen */\r\n /* \r\n * Fill in gradated values for a color channel\r\n */\r\n /* \r\n * Fill in dithered gradated values for a color channel\r\n */\r\n /* Create the bitmap and tile it */\r\n","OPENFILENAME":" ","SelectionEvent":" remove trailing '}'\r\n ","List":" checkWidget ();\r\n /*\r\n\t* Ensure that at least one item is contained in\r\n\t* the range from start to end.  Note that when\r\n\t* start = end, LB_SELITEMRANGEEX deselects the\r\n\t* item.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  For some reason, LB_FINDSTRINGEXACT\r\n\t* will not find empty strings even though it is legal\r\n\t* to insert an empty string into a list.  The fix is\r\n\t* to search the list, an item at a time.\r\n\t*/\r\n /* Use LB_FINDSTRINGEXACT to search for the item */\r\n /*\r\n\t* Note that when start = end, LB_SELITEMRANGEEX\r\n\t* deselects the item.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  If the receiver is scrolled horizontally\r\n\t* and is resized, the list does not redraw properly.  The fix\r\n\t* is to redraw the control when resizing is not deferred and\r\n\t* the new size is different from the previous size.\r\n\t*/\r\n","TRACKMOUSEEVENT":" ","FormAttachment":" ","DISPPARAMS":" ","NMCUSTOMDRAW":" RECT rc;\r\n ","TVITEM":" ","LOGBRUSH":" ","OleParameterDescription":" ","PaintListener":" ","WinICOFileFormat":" the number of colors is in the low byte, but the high byte must be 0\r\n  this is specified: '00' represents '256' (0x100) colors\r\n  Seek to the specified offset\r\n ","Color":" $NON-NLS-1$\r\n  $NON-NLS-1$ /*\r\n\t * If this is a palette-based device,\r\n\t * Decrease the reference count for this color.\r\n\t * If the reference count reaches 0, the slot may\r\n\t * be reused when another color is allocated.\r\n\t */\r\n /* If this is not a palette-based device, return */\r\n /* First find out if the color already exists */\r\n /* See if the nearest color actually is the color */\r\n /* Found the color. Increment the ref count and return */\r\n /* Didn't find the color, allocate it now. Find the first free entry */\r\n /* Found a free entry */\r\n /* Remake the handle from the actual rgbs */\r\n","LICINFO":" ","MARGINS":" ","MENUITEMINFO":" /*\r\n\t* Feature in Windows.  The hbmpItem field requires Windows 4.10\r\n\t* or greater.  On Windows NT 4.0, passing in a larger struct size\r\n\t* in the cbSize field does nothing.  On Windows 95, the MENUITEMINFO\r\n\t* calls fail when the struct size is too large.  The fix is to ensure\r\n\t* that the correct struct size is used for the Windows platform.\r\n\t*/\r\n","TreeDragUnderEffect":" milli seconds\r\n  milli seconds\r\n  Some effects are mutually exclusive.  Make sure that only one of the mutually exclusive effects has been specified.\r\n /*\r\n\t\t* Bug in Windows.  When TVM_SETINSERTMARK is used to set\r\n\t\t* an insert mark for a tree and an item is expanded or\r\n\t\t* collapsed near the insert mark, the tree does not redraw\r\n\t\t* the insert mark properly.  The fix is to hide and show\r\n\t\t* the insert mark whenever an item is expanded or collapsed.\r\n\t\t* Since the insert mark can not be queried from the tree,\r\n\t\t* use the Tree API rather than calling the OS directly.\r\n\t\t*/\r\n","RGB":" $NON-NLS-1$ ","HDITEM":" ","PngPlteChunk":" int end = DATA_OFFSET + getLength();\r\n  IDAT, or IEND chunk has been read.\r\n  Palettes cannot be included in grayscale images.\r\n  of 3. Each 3-byte group represents an RGB value.\r\n  in the IHDR chunk.\r\n  Palettes cannot have more than 256 entries.\r\n ","IPersist":" ","WebSite":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n /* Workaround for javac 1.1.8 bug */\r\n /* Workaround for javac 1.1.8 bug */\r\n /* Show default IE popup menu */\r\n /*\r\n\t* Feature on Internet Explorer.  By default the embedded Internet Explorer control runs\r\n\t* the Internet Explorer shortcuts (e.g. F5 for refresh).  This overrides the shortcuts\r\n\t* defined by SWT.  The workaround is to forward the accelerator keys to the parent window\r\n\t* and have Internet Explorer ignore the ones handled by the parent window.\r\n\t*/\r\n /*\r\n\t* Feature on Internet Explorer.  By default the embedded Internet Explorer control runs\r\n\t* the Internet Explorer shortcuts.  F5 causes refresh.  CTRL-N opens a standalone Internet \r\n\t* Explorer.  These behaviours are undesired when rendering HTML in memory.\r\n\t* The workaround is to block the default CTRL-N and F5 handling by IE when the URL is about:blank.\r\n\t*/\r\n /* resource identifier in shdoclc.dll for window caption \"Your current security settings prohibit \r\n\t * running ActiveX controls on this page ...\" \r\n\t */\r\n /* \r\n\t\t\t* Note.  lpstrText is a LPOLESTR, i.e. a null terminated unicode string LPWSTR, i.e. a WCHAR*.\r\n\t\t\t* It is not a BSTR.  A BSTR is a null terminated unicode string that contains its length\r\n\t\t\t* at the beginning. \r\n\t\t\t*/\r\n /* \r\n\t\t\t* Note.  lpstrText is unicode on both unicode and ansi platforms.\r\n\t\t\t* The nbr of chars is multiplied by the constant 2 and not by TCHAR.sizeof since\r\n\t\t\t* TCHAR.sizeof returns 1 on ansi platforms.\r\n\t\t\t*/\r\n /* provide a buffer large enough to hold the string to compare to and a null terminated character */\r\n /* Note.  One of the arguments of ShowHelp is a POINT struct and not a pointer to a POINT struct. Because\r\n * of the way Callback gets int parameters from a va_list of C arguments 2 integer arguments must be declared,\r\n * ptMouse_x and ptMouse_y. Otherwise the Browser crashes when the user presses F1 to invoke\r\n * the help.\r\n */\r\n /*\r\n\t* Feature in IE 6 sp1.  HTML rendered in memory\r\n\t* does not enable local links but the exact same\r\n\t* HTML document loaded through a local file is\r\n\t* permitted to follow local links.  The workaround is\r\n\t* to return URLZONE_INTRANET instead of the default\r\n\t* value URLZONE_LOCAL_MACHINE.\r\n\t*/\r\n /*\r\n\t* Feature in IE 6 sp1.  HTML rendered in memory\r\n\t* containing an OBJECT tag referring to a local file\r\n\t* brings up a warning dialog asking the user whether\r\n\t* it should proceed or not.  The workaround is to\r\n\t* set the policy to URLPOLICY_ALLOW in this case (dwAction\r\n\t* value of 0x1406).\r\n\t* \r\n\t* Feature in IE. Security Patches and user settings\r\n\t* affect the way the embedded web control behaves.  The current\r\n\t* approach is to consider the content trusted and allow\r\n\t* all URLs by default.\r\n\t*/\r\n /*\r\n\t* Note. The URLACTION_JAVA flags refer to the applet tag that normally resolve to\r\n\t* the Microsoft VM, not to the java OBJECT tag that resolves to the\r\n\t* Sun plugin. Return URLPOLICY_JAVA_LOW to authorize applets instead of\r\n\t* URLPOLICY_ALLOW that is interpreted as URLPOLICY_JAVA_PROHIBIT in this\r\n\t* context. \r\n\t*/\r\n /*\r\n\t* Note.  Some ActiveX plugins crash when executing\r\n\t* inside the embedded explorer itself running into\r\n\t* a JVM.  The current workaround is to detect when\r\n\t* such ActiveX is about to be started and refuse\r\n\t* to execute it.\r\n\t*/\r\n /* IOleCommandTarget */\r\n /*\r\n\t\t* If a javascript error occurred then suppress IE's default script error dialog.\r\n\t\t*/\r\n /*\r\n\t\t* Bug in Internet Explorer.  OnToolBar TRUE is also fired when any of the \r\n\t\t* address bar or menu bar are requested but not the tool bar.  A workaround\r\n\t\t* has been posted by a Microsoft developer on the public webbrowser_ctl\r\n\t\t* newsgroup. The workaround is to implement the IOleCommandTarget interface\r\n\t\t* to test the argument of an undocumented command.\r\n\t\t*/\r\n","Caret":" /* Save the current IME font */\r\n /* Set new IME font */\r\n","SelectionListener":" ","DefaultLineStyler":" the number of styles\r\n  the expansion exponent, used to increase the lines array exponentially\r\n  shift the styles down to make room for the new styles\r\n  add the new styles\r\n  and the end of style needs to be < the start of the next style\r\n  styles if possible\r\n  the start of style needs to be > the end of the previous style\r\n  merge the styles if possible\r\n  no overlapped styles exist\r\n  styles\r\n  beginning of overlap needs to be cleared\r\n  entire overlap needs to be cleared\r\n  cause overlap to be broken into two\r\n  the end of overlap needs to be cleared\r\n  shift the styles up\r\n  style starts after the line, end looping\r\n  -- starts before the line, ends after the line (add range)\r\n  find the index of the first style for the given range, use a binary search\r\n  no styles exist\r\n  newStyle does not overlap any other styles\r\n  indicates whether or not the new style has been added\r\n  beginning of overlap needs to be replaced by newStyle\r\n  that processing is done (no more overlapped styles)\r\n  hasn't already been added, if it has just delete overlap\r\n  cause overlap to be broken into two\r\n  processing is done (no more overlapped styles)\r\n  processing is done\r\n  styles after it so continue processing\r\n  update overlap to accomodate the new style\r\n  the end of overlap needs to be replaced by newStyle\r\n  styles\r\n  find insert point\r\n  all text is going to be replaced, clear line backgrounds\r\n  shift up the lines\r\n  shift the lines down to make room for new lines\r\n  to find the index\r\n  style starts in change range, ends after change range\r\n  style starts in change range, ends in change range\r\n  style starts before change range, ends after change range\r\n  style starts before change range, ends in change range\r\n  affected\r\n  it will need to be split into two and then the newStyle inserted\r\n  update the styles that are in the affected range\r\n  change the offsets of the styles after the affected styles\r\n  to find the index\r\n /*\r\n * Updates the line backgrounds to reflect a pending text change.\r\n * <p>\r\n *\r\n * @param start\tthe starting line of the change that is about to take place\r\n * @param delta\tthe number of lines in the change, > 0 indicates lines inserted,\r\n * \t< 0 indicates lines deleted\r\n */\r\n /*\r\n * Updates the style ranges to reflect a text change.\r\n * <p>\r\n *\r\n * @param start\tthe starting offset of the change that is about to \r\n *\ttake place\r\n * @param delta\tthe length of the change, > 0 indicates text inserted,\r\n * \t< 0 indicates text deleted\r\n */\r\n","Listener":" ","JPEGQuantizationTable":" int tq = (reference[ofs] & 0xFF) % 16;\r\n ","ModifyListener":" ","COMBOBOXINFO":" ","IStream":" Pointer to location for pointer to the new stream object\r\n  Specifies how changes are committed\r\n  Specifies how changes are committed\r\n  Specifies how changes are committed\r\n ","IEnum":" ","Decorations":" } else {\r\n  }\r\n  widget could be disposed at this point\r\n /*\r\n\t\t* Feature in WinCE PPC.  WS_MINIMIZEBOX or WS_MAXIMIZEBOX\r\n\t\t* are not supposed to be used.  If they are, the result\r\n\t\t* is a button which does not repaint correctly.  The fix\r\n\t\t* is to remove this style.\r\n\t\t*/\r\n /*\r\n\t* If either WS_MINIMIZEBOX or WS_MAXIMIZEBOX are set,\r\n\t* we must also set WS_SYSMENU or the buttons will not\r\n\t* appear.\r\n\t*/\r\n /*\r\n\t* Both WS_SYSMENU and WS_CAPTION must be set in order\r\n\t* to for the system menu to appear.\r\n\t*/\r\n /* Get the size of the trimmings */\r\n /* Get the size of the scroll bars */\r\n /* Get the height of the menu bar */\r\n /* \r\n\t\t* Note on WinCE PPC.  Close the shell when user taps CTRL-Q.\r\n\t\t* IDOK represents the \"Done Button\" which also closes the shell.\r\n\t\t*/\r\n /* Icons need black pixels where the mask is transparent */\r\n /* \r\n\t* Note: The CommandBar is part of the client area,\r\n\t* not the trim.  Applications don't expect this so\r\n\t* subtract the height of the CommandBar.\r\n\t*/\r\n /*\r\n\t\t\t* Feature in Windows.  For some reason WM_NCCALCSIZE does\r\n\t\t\t* not compute the client area when the window is minimized.\r\n\t\t\t* The fix is to compute it using AdjustWindowRectEx() and\r\n\t\t\t* GetSystemMetrics().\r\n\t\t\t* \r\n\t\t\t* NOTE: This code fails to compute the correct client area\r\n\t\t\t* for a minimized window where the menu bar would wrap were\r\n\t\t\t* the window restored.  There is no fix for this problem at\r\n\t\t\t* this time.\r\n\t\t\t*/\r\n /* Use the character encoding for the default locale */\r\n /*\r\n\t* Feature in Windows.  Calling SetParent() for a shell causes\r\n\t* a kind of fake MDI to happen.  It doesn't work well on Windows\r\n\t* and is not supported on the other platforms.  The fix is to\r\n\t* disallow the SetParent().\r\n\t*/\r\n /*\r\n\t* Can't test WS_TAB bits because they are the same as WS_MAXIMIZEBOX.\r\n\t*/\r\n /*\r\n\t* Can't test WS_TAB bits because they are the same as WS_MAXIMIZEBOX.\r\n\t*/\r\n /*\r\n\t* Feature in WinCE.  WM_SETICON and WM_GETICON set the icon\r\n\t* for the window class, not the window instance.  This means\r\n\t* that it is possible to set an icon into a window and then\r\n\t* later free the icon, thus freeing the icon for every window.\r\n\t* The fix is to avoid the API.\r\n\t* \r\n\t* On WinCE PPC, icons in windows are not displayed.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When WM_SETICON is used to remove an\r\n\t* icon from the window trimmings for a window with the\r\n\t* extended style bits WS_EX_DLGMODALFRAME, the window\r\n\t* trimmings do not redraw to hide the previous icon.\r\n\t* The fix is to force a redraw.\r\n\t*/\r\n /* Leave space for the menu bar */\r\n /*\r\n\t\t* Note: WinCE does not support SW_SHOWMAXIMIZED and SW_RESTORE. The\r\n\t\t* workaround is to resize the window to fit the parent client area.\r\n\t\t*/\r\n /*\r\n\t\t\t\t* Note in WinCE PPC.  The menu bar is a separate popup window.\r\n\t\t\t\t* If the shell is full screen, resize its window to leave\r\n\t\t\t\t* space for the menu bar.\r\n\t\t\t\t*/\r\n /*\r\n\t* In order for an MDI child window to support\r\n\t* a menu bar, setParent () is needed to reset\r\n\t* the parent.  Otherwise, the MDI child window\r\n\t* will appear as a separate shell.  This is an\r\n\t* undocumented and possibly dangerous Windows\r\n\t* feature.\r\n\t*/\r\n /* Use the character encoding for the default locale */\r\n /*\r\n\t\t* It is possible (but unlikely), that application\r\n\t\t* code could have disposed the widget in the show\r\n\t\t* event.  If this happens, just return.\r\n\t\t*/\r\n /* Shell Sort from K&R, pg 108 */\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have disposed the widget in focus in\r\n\t* or out events.  Ensure that a disposed widget is\r\n\t* not accessed.\r\n\t*/\r\n /* \r\n\t* Clear WS_VISIBLE and WS_TABSTOP.  NOTE: In Windows, WS_TABSTOP\r\n\t* has the same value as WS_MAXIMIZEBOX so these bits cannot be\r\n\t* used to control tabbing.\r\n\t*/\r\n /* Set the title bits and no-trim bits */\r\n /* Set the min and max button bits */\r\n /*\r\n\t\t* Note on WinCE PPC.  SWT.RESIZE is used to resize\r\n\t\t* the Shell according to the state of the IME.\r\n\t\t* It does not set the WS_THICKFRAME style.\r\n\t\t*/\r\n /* Set the resize, dialog border or border bits */\r\n /* Set the system menu and close box bits */\r\n /*\r\n\t* Feature in AWT.  When an AWT Window is activated,\r\n\t* for some reason, it seems to forward the WM_ACTIVATE\r\n\t* message to the parent.  Normally, the parent is an\r\n\t* AWT Frame.  When AWT is embedded in SWT, the SWT\r\n\t* shell gets the WM_ACTIVATE and assumes that it came\r\n\t* from Windows.  When an SWT shell is activated it\r\n\t* restores focus to the last control that had focus.\r\n\t* If this control is an embedded composite, it takes\r\n\t* focus from the AWT Window.  The fix is to ignore\r\n\t* WM_ACTIVATE messages that come from AWT Windows.\r\n\t*/\r\n /*\r\n\t\t* When the high word of wParam is non-zero, the activation\r\n\t\t* state of the window is being changed while the window is\r\n\t\t* minimized. If this is the case, do not report activation\r\n\t\t* events or restore the focus.\r\n\t\t*/\r\n /*\r\n\t\t* Feature on WinCE SP.  The Back key is either used to close\r\n\t\t* the foreground Dialog or used as a regular Back key in an EDIT\r\n\t\t* control. The article 'Back Key' in MSDN for Smartphone \r\n\t\t* describes how an application should handle it.  The \r\n\t\t* workaround is to override the Back key when creating\r\n\t\t* the menubar and handle it based on the style of the Shell.\r\n\t\t* If the Shell has the SWT.CLOSE style, close the Shell.\r\n\t\t* Otherwise, send the Back key to the window with focus.\r\n\t\t*/\r\n","CloseWindowListener":" ","TableTreeItem":" checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n  this is a root and can not be toggled between visible and hidden\r\n  remove row from table\r\n  parentItem must already be visible\r\n  create underlying table item and set data in table item to stored data\r\n  ignore any images in the first column\r\n  display the children and the appropriate [+] /* Root items are visible immediately */\r\n /*\r\n\t\t* Feature in the Table.  The table uses the first image that\r\n\t\t* is inserted into the table to size the table rows.  If the\r\n\t\t* user is allowed to insert the first image, this will cause\r\n\t\t* the +/- images to be scaled.  The fix is to insert a dummy\r\n\t\t* image to force the size.\r\n\t\t*/\r\n /* Now that item has a sub-node it must indicate that it can be expanded */\r\n /* Put the item in the items list */\r\n","PrinterData":" $NON-NLS-1$  ","NMHDR":" ","MINMAXINFO":" POINT ptReserved;\r\n  POINT ptMaxSize;\r\n  POINT ptMaxPosition;\r\n  POINT ptMinTrackSize;\r\n  POINT ptMaxTrackSize;\r\n ","GC":" $NON-NLS-1$\r\n  swap angles\r\n  TODO - cache bitmap\r\n  set the background color, we may not have to do this work?\r\n  TCHAR buffer = new TCHAR (getCodePage(), string, false);\r\n  swap angles\r\n  TCHAR buffer = new TCHAR (getCodePage(), string, false);\r\n  OS.GetTextExtentPoint32(handle, SPACE, SPACE.length(), size);\r\n  OS.GetTextExtentPoint32(handle, SPACE, SPACE.length(), size);\r\n /* Get the HDC for the device */\r\n /* Copy the bitmap area */\r\n /* Release the HDC for the device */\r\n /*\r\n\t* Feature in WinCE.  The function WindowFromDC is not part of the\r\n\t* WinCE SDK.  The fix is to remember the HWND.\r\n\t*/\r\n /*\r\n\t\t* Feature in WinCE.  ScrollWindowEx does not accept combined\r\n\t\t* vertical and horizontal scrolling.  The fix is to do a\r\n\t\t* BitBlt and invalidate the appropriate source area.\r\n\t\t*/\r\n /*\r\n\t\t* Feature in Windows.  The default end caps is PS_ENDCAP_ROUND\r\n\t\t* and the default line join is PS_JOIN_ROUND which are different\r\n\t\t* from other platforms.  The fix is to change these values when\r\n\t\t* line width is widened.\r\n\t\t*/\r\n /* Select stock pen and brush objects and free resources */\r\n /*\r\n\t* Put back the original bitmap into the device context.\r\n\t* This will ensure that we have not left a bitmap\r\n\t* selected in it when we delete the HDC.\r\n\t*/\r\n /*\r\n\t* Dispose the HDC.\r\n\t*/\r\n /* compute arc with a simple linear interpolation */\r\n /*\r\n\t* Feature in WinCE.  The function Arc is not present in the\r\n\t* WinCE SDK.  The fix is to emulate arc drawing by using\r\n\t* Polyline.\r\n\t*/\r\n /* Simple case: no stretching, entire icon */\r\n /* Get the icon info */\r\n /* Get the icon width and height */\r\n /* Draw the icon */\r\n /* Create the icon info and HDC's */\r\n /* Blt the color bitmap */\r\n /* Blt the mask bitmap */\r\n /* Destroy the new icon src and mask and hdc's*/\r\n /* Simple case: no stretching, entire icon */\r\n /* Free icon info */\r\n /* Simple cases */\r\n /*\r\n\t\t* Feature in Windows.  AlphaBlend() alters the alpha\r\n\t\t* channel if the destination is a 32 bit depth bitmap.\r\n\t\t* The fix is to draw to a temporary 24 bit depth bitmap\r\n\t\t* first and then draw the temporary bitmap.\r\n\t\t*/\r\n /* Check clipping */\r\n /* \r\n\t* Optimization.  Recalculate src and dest rectangles so that\r\n\t* only the clipping area is drawn.\r\n\t*/\r\n /* Create resources */\r\n /* Get the background pixels */\r\n /* Get the foreground pixels */\r\n /* Merge the alpha channel in place */\r\n /* Scale the foreground pixels with alpha */\r\n /* \r\n\t* Bug in WinCE and Win98.  StretchBlt does not correctly stretch when\r\n\t* the source and destination HDCs are the same.  The workaround is to\r\n\t* stretch to a temporary HDC and blit back into the original HDC.\r\n\t* Note that on WinCE StretchBlt correctly compresses the image when the\r\n\t* source and destination HDCs are the same.\r\n\t*/\r\n /* Compose the pixels */\r\n /* Draw the composed pixels */\r\n /* Free resources */\r\n /* Create a clipping region from the mask */\r\n /* Stretch the clipping mask if needed */\r\n /* Find the RGB values for the transparent pixel. */\r\n /* Direct color image */\r\n /* Palette-based bitmap */\r\n /* Set the few fields necessary to get the RGB data out */\r\n /* Palette-based DIBSECTION */\r\n /* Create the mask for the source image */\r\n /* Draw the source bitmap transparently using invert/and mask/invert */\r\n /* Most printers do not support BitBlt(), draw the source bitmap transparently using clipping */\r\n /*\r\n\t\t* Note in WinCE. TransparentImage uses the first entry of a palette\r\n\t\t* based image when there are multiple entries that have the same\r\n\t\t* transparent color.\r\n\t\t*/\r\n /* \r\n\t\t* Bug in WinCE PPC.  On certain devices, RoundRect does not draw\r\n\t\t* all the pixels.  The workaround is to draw a round rectangle\r\n\t\t* using lines and arcs.\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows.  For some reason DrawText(), the maximum\r\n    * value for the bottom and right coordinates for the RECT that\r\n    * is used to position the text is different on between Windows\r\n    * versions.  If this value is larger than the maximum, nothing\r\n\t* is drawn.  On Windows 98, the limit is 0x7FFF.  On Windows CE,\r\n\t* NT, and 2000 it is 0x6FFFFFF. And on XP, it is 0x7FFFFFFF.\r\n\t* The fix is to use the the smaller limit for Windows 98 and the\r\n\t* larger limit on the other Windows platforms. \r\n\t*/\r\n /* compute arc with a simple linear interpolation */\r\n /*\r\n\t* Feature in WinCE.  The function Pie is not present in the\r\n\t* WinCE SDK.  The fix is to emulate it by using Polygon.\r\n\t*/\r\n /* \r\n\t* Bug in Windows: On Windows 2000 when the device is a printer,\r\n\t* GradientFill swaps red and blue color components, causing the\r\n\t* gradient to be printed in the wrong color. On Windows 98 when\r\n\t* the device is a printer, GradientFill does not fill completely\r\n\t* to the right edge of the rectangle. The fix is not to use\r\n\t* GradientFill for printer devices.\r\n\t*/\r\n /* Assumes that user sets the background color. */\r\n /*\r\n\t\t* Note Flush() does not flush the output to the\r\n\t\t* underline HDC. This is done by calling GetHDC()\r\n\t\t* followed by ReleaseHDC().\r\n\t\t*/\r\n /* GetCharABCWidths only succeeds on truetype fonts */\r\n /* It wasn't a truetype font */\r\n /*\r\n\t\t* Feature in GDI+. The GDI+ clipping set with Graphics->SetClip()\r\n\t\t* is always intersected with the GDI clipping at the time the\r\n\t\t* GDI+ graphics is created.  This means that the clipping \r\n\t\t* cannot be reset.  The fix is to clear the clipping before\r\n\t\t* the GDI+ graphics is created and reset it afterwards.\r\n\t\t*/\r\n /*\r\n\t\t* Feature in Windows.  The default end caps is PS_ENDCAP_ROUND\r\n\t\t* and the default line join is PS_JOIN_ROUND which are different\r\n\t\t* from other platforms.  The fix is to change these values when\r\n\t\t* line width is widened.\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows.  Windows does not honour line styles other then\r\n\t* PS_SOLID for pens wider than 1 pixel created with CreatePen().  The fix\r\n\t* is to use ExtCreatePen() instead.\r\n\t*/\r\n /* Feature in Windows. PS_GEOMETRIC pens cannot have zero width. */\r\n","AccessibleEvent":" $NON-NLS-1$  ","LocationEvent":" ","RunnableLock":" ","IAccessible":" ","HelpEvent":" ","DragSourceAdapter":" ","IDataObject":" The caller then assumes responsibility for releasing the STGMEDIUM structure.\r\n  allocate and free the specified storage medium.\r\n  Pointer to the FORMATETC structure\r\n  Pointer to STGMEDIUM structure\r\n  Indicates which object owns the storage medium after the call is completed\r\n ","TabFolder":" TEMPORARY CODE\r\n  }\r\n /*\r\n\t* These are the undocumented control id's for the children of\r\n\t* a tab control.  Since there are no constants for these values,\r\n\t* they may change with different versions of Windows.\r\n\t*/\r\n /*\r\n\t\t* Feature in Windows.  The tab control window class\r\n\t\t* uses the CS_HREDRAW and CS_VREDRAW style bits to\r\n\t\t* force a full redraw of the control and all children\r\n\t\t* when resized.  This causes flashing.  The fix is to\r\n\t\t* register a new window class without these bits and\r\n\t\t* implement special code that damages only the exposed\r\n\t\t* area.\r\n\t\t* \r\n\t\t* NOTE:  Screen readers look for the exact class name\r\n\t\t* of the control in order to provide the correct kind\r\n\t\t* of assistance.  Therefore, it is critical that the\r\n\t\t* new window class have the same name.  It is possible\r\n\t\t* to register a local window class with the same name\r\n\t\t* as a global class.  Since bits that affect the class\r\n\t\t* are being changed, it is possible that other native\r\n\t\t* code, other than SWT, could create a control with\r\n\t\t* this class name, and fail unexpectedly.\r\n\t\t*/\r\n /* Force tabs to be on the bottom for tab folders on PPC */\r\n /*\r\n\t* Even though it is legal to create this widget\r\n\t* with scroll bars, they serve no useful purpose\r\n\t* because they do not automatically scroll the\r\n\t* widget's client area.  The fix is to clear\r\n\t* the SWT style.\r\n\t*/\r\n /*\r\n\t* Send a selection event when the item that is added becomes\r\n\t* the new selection.  This only happens when the first item\r\n\t* is added.\r\n\t*/\r\n /*COMCTL32_VERSION*/\r\n /* Enable the flat look for tab folders on PPC */\r\n /*\r\n\t* Feature in Windows.  Despite the fact that the\r\n\t* tool tip text contains \\r\\n, the tooltip will\r\n\t* not honour the new line unless TTM_SETMAXTIPWIDTH\r\n\t* is set.  The fix is to set TTM_SETMAXTIPWIDTH to\r\n\t* a large value.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  Under certain circumstances,\r\n\t* when TCM_SETITEM is used to change the text\r\n\t* in a tab item, the tab folder draws on top\r\n\t* of the client area.  The fix is ensure that\r\n\t* this cannot happen by setting WS_CLIPCHILDREN.\r\n\t*/\r\n /*\r\n\t* Return DLGC_BUTTON so that mnemonics will be\r\n\t* processed without needing to press the ALT key\r\n\t* when the widget has focus.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  The tab control implements\r\n\t* WM_NCHITTEST to return HTCLIENT when the cursor\r\n\t* is inside the tab buttons.  This causes mouse\r\n\t* events like WM_MOUSEMOVE to be delivered to the\r\n\t* parent.  Also, tool tips for the tab control are\r\n\t* never invoked because tool tips rely on mouse\r\n\t* events to be delivered to the window that wants\r\n\t* to display the tool tip.  The fix is to call the\r\n\t* default window proc that returns HTCLIENT when\r\n\t* the mouse is in the client area.\t\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the tab folder window\r\n\t* proc processes WM_NOTIFY, it forwards this\r\n\t* message to its parent.  This is done so that\r\n\t* children of this control that send this message \r\n\t* type to their parent will notify not only\r\n\t* this control but also the parent of this control,\r\n\t* which is typically the application window and\r\n\t* the window that is looking for the message.\r\n\t* If the control did not forward the message, \r\n\t* applications would have to subclass the control \r\n\t* window to see the message. Because the control\r\n\t* window is subclassed by SWT, the message\r\n\t* is delivered twice, once by SWT and once when\r\n\t* the message is forwarded by the window proc.\r\n\t* The fix is to avoid calling the window proc \r\n\t* for this control.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  Windows does not explicitly set the orientation of\r\n\t* the buddy control.  Instead, the orientation is inherited when WS_EX_LAYOUTRTL\r\n\t* is specified for the tab folder.  This means that when both WS_EX_LAYOUTRTL\r\n\t* and WS_EX_NOINHERITLAYOUT are specified for the tab folder, the buddy control\r\n\t* will not be oriented correctly.  The fix is to explicitly set the orientation\r\n\t* for the buddy control.\r\n\t* \r\n\t* NOTE: WS_EX_LAYOUTRTL is not supported on Windows NT.\r\n\t*/\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have disposed the widget in the resize\r\n\t* event.  If this happens, end the processing of the\r\n\t* Windows message by returning the result of the\r\n\t* WM_SIZE message.\r\n\t*/\r\n","PathData":" ","TableEditor":" To be consistent with older versions of SWT, grabVertical defaults to true\r\n  default is CENTER\r\n  default is CENTER\r\n  In this situation, there is a single default column.\r\n ","TitleEvent":" ","HELPINFO":" POINT MousePos\r\n ","LZWNode":" ","AnimatedProgress":" Subtracted border painted by paint.\r\n  checkWidget();\r\n ","DND":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n /* OS Failure/Limit (fatal, may occur only on some platforms) */\r\n /* Unknown/Undefined Error */\r\n","ControlEvent":" ","HIGHCONTRAST":" ","SCRIPT_CONTROL":" ","ArmEvent":" ","OleEventTable":" ","PngChunk":" Critical chunks.\r\n  Non-critical chunks.\r\n  The third character MUST be upper case.\r\n  All characters must be letters.\r\n  The stored CRC must match the data's computed CRC.\r\n ","Image":" /* Get the HDC for the device */\r\n /* Copy the bitmap */\r\n /* Release the HDC for the device */\r\n /* biSize */\r\n /* biWidth */\r\n /* biHeight */\r\n /* biPlanes */\r\n /* biBitCount */\r\n /* biCompression */\r\n /* biSizeImage */\r\n /* biXPelsPerMeter */\r\n /* biYPelsPerMeter */\r\n /* biClrUsed */\r\n /* biClrImportant */\r\n /* First color: black */\r\n /* Get the HDC for the device */\r\n /* Source DC */\r\n /* Monochrome (Intermediate) DC */\r\n /* Destination DC */\r\n /* Monochrome (Intermediate) DIB section */\r\n /* Attach the bitmap to the source DC */\r\n /* Create the destination bitmap */\r\n /* Attach the DIB section and the new bitmap to the DCs */\r\n /* BitBlt the bitmap into the monochrome DIB section */\r\n /* Paint the destination rectangle in gray */\r\n /*\r\n\t\t\t\t\t * BitBlt the black bits in the monochrome bitmap into\r\n\t\t\t\t\t * COLOR_3DHILIGHT bits in the destination DC.\r\n\t\t\t\t\t * The magic ROP comes from Charles Petzold's book\r\n\t\t\t\t\t */\r\n /*\r\n\t\t\t\t\t * BitBlt the black bits in the monochrome bitmap into \r\n\t\t\t\t\t * COLOR_3DSHADOW bits in the destination DC.\r\n\t\t\t\t\t */\r\n /* Free resources */\r\n /* Release the HDC for the device */\r\n /* Get icon information */\r\n /* Create the destination bitmaps */\r\n /* BitBlt the source mask into the destination mask */\r\n /* Attach the monochrome DIB section and the destination bitmap to the DCs */\r\n /* BitBlt the bitmap into the monochrome DIB section */\r\n /* Paint the destination rectangle in grey */\r\n /*\r\n\t\t\t\t\t * BitBlt the black bits in the monochrome bitmap into\r\n\t\t\t\t\t * COLOR_3DHILIGHT bits in the destination DC.\r\n\t\t\t\t\t * The magic ROP comes from Charles Petzold's book\r\n\t\t\t\t\t */\r\n /* Invert mask into hdcBw */\r\n /* Select black brush into destination */\r\n /*\r\n\t\t\t\t\t * Copy black bits from monochrome bitmap into black bits in the\r\n\t\t\t\t\t * destination DC.\r\n\t\t\t\t\t */\r\n /* Free resources */\r\n /* Release the HDC for the device */\r\n /* Create the new iconinfo */\r\n /* Create the new icon */\r\n /* Free bitmaps */\r\n /* Create a 8 bit depth image data with a gray palette. */\r\n /* Convert the pixels. */\r\n /* Convert the palette entries to gray. */\r\n /* Determine the DDB depth */\r\n /* Determine the DIB palette */\r\n /* Set the rgb colors into the bitmap info */\r\n /* little endian */\r\n /* big endian */\r\n /* Bitblt DDB into DIB */\r\n /*\r\n\t\t\t* Bug in GDI+. Creating a new GDI+ Bitmap from a HICON segment faults\r\n\t\t\t* when the icon width is bigger than the icon height.  The fix is to\r\n\t\t\t* detect this and create a PixelFormat32bppARGB image instead.\r\n\t\t\t*/\r\n /* Get the HDC for the device */\r\n /* Compute the background color */\r\n /* Release the HDC for the device */\r\n /* Get the basic BITMAP information */\r\n /* Create the BITMAPINFO */\r\n /* Get the HDC for the device */\r\n /* Create the DC and select the bitmap */\r\n /* Select the palette if necessary */\r\n /* Find the size of the image and allocate data */\r\n /* Call with null lpBits to get the image size */\r\n /* Get the bitmap data */\r\n /* Calculate the palette */\r\n /* Do the mask */\r\n /* Create the BITMAPINFO */\r\n /* First color black, second color white */\r\n /* Call with null lpBits to get the image size */\r\n /* Loop to invert the mask */\r\n /* Make sure mask scanlinePad is 2 */\r\n /* Do the bottom half of the mask */\r\n /* Clean up */\r\n /* Release the HDC for the device */\r\n /* Construct and return the ImageData */\r\n /* Get the basic BITMAP information */\r\n /* Find out whether this is a DIB or a DDB. */\r\n /* Get the HDC for the device */\r\n /*\r\n\t\t\t* Feature in WinCE.  GetDIBits is not available in WinCE.  The\r\n\t\t\t* workaround is to create a temporary DIB from the DDB and use\r\n\t\t\t* the bmBits field of DIBSECTION to retrieve the image data.\r\n\t\t\t*/\r\n /* Calculate number of colors */\r\n /* Create the BITMAPINFO */\r\n /* Create the DC and select the bitmap */\r\n /* Select the palette if necessary */\r\n /* Find the size of the image and allocate data */\r\n /* Call with null lpBits to get the image size */\r\n /* get image data from the temporary DIB */\r\n /* Get the bitmap data */\r\n /* Calculate the palette */\r\n /* \r\n\t\t\t\t\t\t* Feature on WinCE.  GetDIBColorTable is not supported.\r\n\t\t\t\t\t\t* The workaround is to set a pixel to the desired\r\n\t\t\t\t\t\t* palette index and use getPixel to get the corresponding\r\n\t\t\t\t\t\t* RGB value.\r\n\t\t\t\t\t\t*/\r\n /* Clean up */\r\n /* free temporary DIB */\r\n /* Release the HDC for the device */\r\n /* Construct and return the ImageData */\r\n /*\r\n\t* Feature in Windows.  CreateCompatibleBitmap() may fail\r\n\t* for large images.  The fix is to create a DIB section\r\n\t* in that case.\r\n\t*/\r\n /* big endian */\r\n /* Set the rgb colors into the bitmap info */\r\n /* Windows does not support 2-bit images. Convert to 4-bit image. */\r\n /*\r\n\t* Note on WinCE.  CreateDIBSection requires the biCompression\r\n\t* field of the BITMAPINFOHEADER to be set to BI_BITFIELDS for\r\n\t* 16 and 32 bit direct images (see MSDN for CreateDIBSection).\r\n\t* In this case, the color mask can be set to any value.  For\r\n\t* consistency, it is set to the same mask used by non WinCE\r\n\t* platforms in BI_RGB mode.\r\n\t*/\r\n /* Construct bitmap info header by hand */\r\n /* Set the rgb colors into the bitmap info */\r\n /*\r\n\t\t\t * The color masks must be written based on the\r\n\t\t\t * endianness of the ImageData.\r\n\t\t\t */\r\n /* In case of a scanline pad other than 4, do the work to convert it */\r\n /* Get the HDC for the device */\r\n /* Create the color bitmap */\r\n /* Release the HDC for the device */\r\n /* Create the mask. Windows requires icon masks to have a scanline pad of 2. */\r\n /* Create the icon */\r\n /* Create a temporary image and locate the black pixel */\r\n /* No room to grow the palette */\r\n /* We can grow the palette and add black */\r\n /*\r\n\t\t\t\t * We didn't find black in the palette, and there is no transparent\r\n\t\t\t\t * pixel we can use.\r\n\t\t\t\t */\r\n /*\r\n\t\t\t * The source had transparency, so we can use the transparent pixel\r\n\t\t\t * for black.\r\n\t\t\t */\r\n /* Grow the palette with black */\r\n /* Modify the source image to contain black wherever the mask is 0 */\r\n /* There was no black in the palette, so just copy the data over */\r\n /*\r\n\t* Create a new GC that can draw into the image.\r\n\t* Only supported for bitmaps.\r\n\t*/\r\n /* Create a compatible HDC for the device */\r\n /* Set the GCData fields */\r\n /*\r\n\t* Note.  Not implemented on WinCE.\r\n\t*/\r\n /* Get the HDC for the device */\r\n /* Change the background color in the image */\r\n /* Release the HDC for the device */\r\n","OLECMD":" ","StatusTextEvent":" ","LITEM":" ","GIFFileFormat":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  aspect = block[6] & 0xFF;\r\n  sorted = false;\r\n  sorted = (bitField & 0x8) != 0;\r\n  the block contents.\r\n  Read size of block = 0x0C.\r\n  Read the text information (x, y, width, height, colors).\r\n  Read the text.\r\n  Read size of block = 0x04.\r\n  Read the control block.\r\n  Store the disposal method.\r\n  Store the delay time.\r\n  Store the transparent color.\r\n  Read block terminator.\r\n  Read size of block = 0x0B.\r\n  Read application identifier.\r\n  Read authentication code.\r\n  Read application data.\r\n  $NON-NLS-1$   Look for the NETSCAPE 'repeat count' field for an animated GIF.\r\n  No local palette.\r\n  Local palette.\r\n  boolean sorted = (bitField & 0x20) != 0;\r\n  Promote depth to next highest supported value.\r\n  size of block\r\n  block terminator\r\n  no interlace, no sort, no local palette\r\n /* Read the 0-byte terminator at the end of the image. */\r\n /* We read the terminator earlier. */\r\n /* Work around: a customer has a GIF that specifies an\r\n\t\t\t\t * invalid color index that is larger than the number\r\n\t\t\t\t * of entries in the palette. Detect this case, and\r\n\t\t\t\t * ignore the specified color index. */\r\n","ModifyEvent":" ","LVITEM":" ","StyledTextListener":" ","TCHAR":" ","ScrolledComposite":" checkWidget();\r\n  checkWidget();\r\n ","JPEGFrameHeader":" /* Used when decoding. */\r\n /* Used when encoding. */\r\n /*\r\n\t * Verify the information contained in the receiver is correct.\r\n\t * Answer true if the header contains a valid marker. Otherwise,\r\n\t * answer false. Valid Start Of Frame markers are:\r\n\t *\tSOF_0  - Baseline DCT, Huffman coding\r\n\t *\tSOF_1  - Extended sequential DCT, Huffman coding\r\n\t *\tSOF_2  - Progressive DCT, Huffman coding\r\n\t *\tSOF_3  - Lossless (sequential), Huffman coding\r\n\t *\tSOF_5  - Differential sequential, Huffman coding\r\n\t *\tSOF_6  - Differential progressive, Huffman coding\r\n\t *\tSOF_7  - Differential lossless, Huffman coding\r\n\t *\tSOF_9  - Extended sequential DCT, arithmetic coding\r\n\t *\tSOF_10 - Progressive DCT, arithmetic coding\r\n\t *\tSOF_11 - Lossless (sequential), arithmetic coding\r\n\t *\tSOF_13 - Differential sequential, arithmetic coding\r\n\t *\tSOF_14 - Differential progressive, arithmetic coding\r\n\t *\tSOF_15 - Differential lossless, arithmetic coding\r\n\t */\r\n","EXTLOGPEN":" ","TextChangeListener":" ","BROWSEINFO":" ","Accessible":" method6 Invoke - not implemented\r\n  Currently, we don't let the application override this. Forward to the proxy.\r\n  proxy doesn't know about app childID\r\n  proxy doesn't know about app childID\r\n  Currently, we don't let the application override this. Forward to the proxy.\r\n  proxy doesn't know about app childID\r\n  Currently, we don't let the application override this. Forward to the proxy.\r\n  proxy doesn't know about app childID\r\n  proxy doesn't know about app childID\r\n  proxy doesn't know about app childID\r\n  proxy doesn't know about app childID\r\n  TEMPORARY CODE - process tree even if there are no apps listening\r\n  proxy doesn't know about app childID\r\n  Currently, we don't let the application override this. Forward to the proxy.\r\n  proxy doesn't know about app childID\r\n  proxy doesn't know about app childID\r\n  proxy doesn't know about app childID\r\n  Currently, we don't let the application override this. Forward to the proxy.\r\n  proxy doesn't know about app childID\r\n  TEMPORARY CODE - process tree and table even if there are no apps listening\r\n  proxy doesn't know about app childID\r\n  TEMPORARY CODE - process tree and table even if there are no apps listening\r\n  proxy doesn't know about app childID\r\n  MSAA: this method is no longer supported\r\n  We don't implement this. Forward to the proxy.\r\n  proxy doesn't know about app childID\r\n  MSAA: this method is typically only used for edit controls\r\n  We don't implement this. Forward to the proxy.\r\n  proxy doesn't know about app childID\r\n /* Get the default location from the OS. */\r\n /* Get the default child count from the OS. */\r\n /* Get the default defaultAction from the OS. */\r\n /* Get the default description from the OS. */\r\n /* Currently our tree columns are emulated using custom draw,\r\n\t\t * so we need to create the description using the tree column\r\n\t\t * header text and tree item text. */\r\n /* Get the default focus child from the OS. */\r\n /* Get the default help string from the OS. */\r\n /* Get the default keyboard shortcut from the OS. */\r\n /* Get the default name from the OS. */\r\n /* Get the default role from the OS. */\r\n /* Currently our checkbox table and tree are emulated using state mask\r\n\t\t * images, so we need to specify 'checkbox' role for the items. */\r\n /* Get the default selection from the OS. */\r\n /* Should return an IEnumVARIANT for this... so the next line is wrong... need better API here... */\r\n /* Get the default state from the OS. */\r\n /* Currently our checkbox table and tree are emulated using state mask\r\n\t\t * images, so we need to determine if the item state is 'checked'. */\r\n /* Get the default value string from the OS. */\r\n /* If there are no listeners, query the proxy for\r\n\t\t * its IEnumVariant, and get the Next items from it.\r\n\t\t */\r\n /* Retrieve the next celt items in the enumeration sequence. \r\n\t * If there are fewer than the requested number of elements left\r\n\t * in the sequence, retrieve the remaining elements.\r\n\t * The number of elements actually retrieved is returned in pceltFetched \r\n\t * (unless the caller passed in NULL for that parameter).\r\n\t */\r\n /* If there are no listeners, query the proxy\r\n\t\t * for its IEnumVariant, and tell it to Skip.\r\n\t\t */\r\n /* Skip over the specified number of elements in the enumeration sequence. */\r\n /* If there are no listeners, query the proxy\r\n\t\t * for its IEnumVariant, and tell it to Reset.\r\n\t\t */\r\n /* Reset the enumeration sequence to the beginning. */\r\n /*\r\n\t\t* Feature of Windows:\r\n\t\t* In Windows XP, tree item ids are 1-based indices. Previous versions\r\n\t\t* of Windows use the tree item handle for the accessible child ID.\r\n\t\t* For backward compatibility, we still take a handle childID for tree\r\n\t\t* items on XP. All other childIDs are 1-based indices.\r\n\t\t*/\r\n /*\r\n\t\t* Feature of Windows:\r\n\t\t* In Windows XP, tree item ids are 1-based indices. Previous versions\r\n\t\t* of Windows use the tree item handle for the accessible child ID.\r\n\t\t* For backward compatibility, we still take a handle childID for tree\r\n\t\t* items on XP. All other childIDs are 1-based indices.\r\n\t\t*/\r\n /* checkWidget was copied from Widget, and rewritten to work in this package */\r\n /* isValidThread was copied from Widget, and rewritten to work in this package */\r\n","SCRIPT_ITEM":" ","StyledTextEvent":" used by LineStyleEvent\r\n  used by LineBackgroundEvent\r\n  used by BidiSegmentEvent\r\n  used by TextChangedEvent\r\n ","TVINSERTSTRUCT":" public TVITEM item;\r\n ","FontData":" out of the box\r\n  $NON-NLS-1$  out of the box\r\n  data.lfHeight == lf.lfHeight &&\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n /* Get the locale ID */\r\n /* Check the language */\r\n /* Check the country */\r\n /* Get the charset */\r\n /* The field lfFaceName must be NULL terminated */\r\n","JPEGEndOfImage":" ","ImageLoaderListener":" ","NMTBHOTITEM":" ","FillLayout":" TEMPORARY CODE\r\n ","TCITEM":" ","LZWCodec":" Last byte has data\r\n  Nothing in last byte\r\n  Write out last partial block\r\n  Write out empty block to indicate the end (if needed)\r\n  Off by one?\r\n  Force a read\r\n  *high-order* bits of the code.\r\n  The whole code fit in the first byte, so we are done.\r\n  for the next one.\r\n  Fill in any remaining whole bytes (i.e. not the last one!)\r\n  Fill the *low-order* bits of the last byte with the remainder\r\n  Slight optimization for depth = 8.\r\n ","Variant":" OLE.VT_* type\r\n  try to coerce the value to the desired type\r\n  Note: This must absolutely be done AFTER the\r\n  Dispatch object\r\n  try to coerce the value to the desired type\r\n  Note: This must absolutely be done AFTER the\r\n  Dispatch object\r\n  try to coerce the value to the desired type\r\n  try to coerce the value to the desired type\r\n  try to coerce the value to the desired type\r\n  try to coerce the value to the desired type\r\n  try to coerce the value to the desired type\r\n  try to coerce the value to the desired type\r\n  Note: This must absolutely be done AFTER the\r\n  Dispatch object\r\n  get the address of the memory in which the string resides\r\n  of bytes - each unicode character is 2 bytes.\r\n  $NON-NLS-1$\r\n  add one to avoid rounding errors\r\n  try coercing it into one of the known forms\r\n ","NMRGINFO":" POINT ptAction;\r\n ","CCombo":" $NON-NLS-1$\r\n  create shell and list\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$   $NON-NLS-1$\r\n  $NON-NLS-1$   Escape key cancels popup list\r\n  Enter causes default selection\r\n  If so, do not continue.\r\n  draw black rectangle around list\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  If so, do not continue.\r\n  If so, do not continue.\r\n  do not use them for traversal.\r\n /* \r\n * Return the Label immediately preceding the receiver in the z-order, \r\n * or null if none. \r\n */\r\n","NMLVFINDITEM":" LVFINDINFO lvfi;\r\n  POINT pt;\r\n ","CTabFolderListener":" ","IProvideClassInfo":" ","ViewFormLayout":" calculate width of title bar\r\n  allow space for a vertical separator\r\n ","FocusAdapter":" ","GCP_RESULTS":" ","ExtendedModifyListener":" ","KEYBDINPUT":" ","BidiSegmentEvent":" ","AccessibleControlListener":" ","CONTROLINFO":" ","DragSourceListener":" ","IProvideClassInfo2":" ","DragSourceEvent":" ","NMUPDOWN":" ","GridLayout":" TEMPORARY CODE\r\n  TEMPORARY CODE\r\n  clean up cache\r\n /* Build the grid */\r\n /* Column widths */\r\n /* Wrapping */\r\n /* Row heights */\r\n /* Position the controls */\r\n","RowData":" ","ScrolledCompositeLayout":" ","TreeColumn":" /*\r\n\t* Bug in Windows.  When a column header contains a\r\n\t* mnemonic character, Windows does not measure the\r\n\t* text properly.  This causes '...' to always appear\r\n\t* at the end of the text.  The fix is to remove\r\n\t* mnemonic characters and replace doubled mnemonics\r\n\t* with spaces.\r\n\t*/\r\n","Menu":" checkOrientation (parent);\r\n /* Resource ID for SHMENUBARINFO */\r\n /* SmartPhone SoftKeyBar resource ids */\r\n /*\r\n\t* Bug in IBM JVM 1.3.1.  For some reason, when the checkOrientation() is\r\n\t* called from createWidget(), the JVM issues this error:\r\n\t*\r\n\t* JVM Exception 0x2 (subcode 0x0) occurred in thread \"main\" (TID:0x9F19D8)\r\n\t* \r\n\t* In addition, on Windows XP, a dialog appears with following error message,\r\n\t* indicating that the problem may be in the JIT:\r\n\t* \r\n\t* AppName: java.exe\t AppVer: 0.0.0.0\t ModName: jitc.dll\r\n\t* ModVer: 0.0.0.0\t Offset: 000b6912\r\n\t* \r\n\t* The fix is to call checkOrientation() from here.\r\n\t*/\r\n /*\r\n\t\t* Feature in Windows.  It is legal use TrackPopupMenu()\r\n\t\t* to display an empty menu as long as menu items are added\r\n\t\t* inside of WM_INITPOPUPMENU.  If no items are added, then\r\n\t\t* TrackPopupMenu() fails and does not send an indication\r\n\t\t* that the menu has been closed.  This is not strictly a\r\n\t\t* bug but leads to unwanted behavior when application code\r\n\t\t* assumes that every WM_INITPOPUPMENU will eventually result\r\n\t\t* in a WM_MENUSELECT, wParam=0xFFFF0000, lParam=0 to indicate\r\n\t\t* that the menu has been closed.  The fix is to detect the\r\n\t\t* case when TrackPopupMenu() fails and the number of items in\r\n\t\t* the menu is zero and issue a fake WM_MENUSELECT.\r\n\t\t*/\r\n /* Remove the item from the resource file */\r\n /* Determine type of menubar */\r\n /* Create SHMENUBAR */\r\n /* as defined in .rc file */\r\n /*\r\n\t\t\t* Feature on WinCE SmartPhone.  The SHCMBF_HIDDEN flag causes the\r\n\t\t\t* SHMENUBAR to not be drawn. However the keyboard events still go\r\n\t\t\t* through it.  The workaround is to also hide the SHMENUBAR with\r\n\t\t\t* ShowWindow ().\r\n\t\t\t*/\r\n /* Remove the item from the resource file */\r\n /* Set first item */\r\n /* Set second item */\r\n /*\r\n\t\t\t* Override the Back key.  For some reason, the owner of the menubar\r\n\t\t\t* must be a Dialog or it won't receive the WM_HOTKEY message.  As\r\n\t\t\t* a result, Shell on WinCE SP must use the class Dialog.\r\n\t\t\t*/\r\n /*\r\n\t\t* Note in WinCE SmartPhone.  The SoftBar contains only 2 items.\r\n\t\t* An item can either be a menu or a button. \r\n\t\t* SWT.BAR: creates a SoftBar with 2 menus\r\n\t\t* SWT.BAR | SWT.BUTTON1: creates a SoftBar with 1 button\r\n\t\t*    for button1, and a menu for button2\r\n\t\t* SWT.BAR | SWT.BUTTON1 | SWT.BUTTON2: creates a SoftBar with\r\n\t\t*    2 buttons\r\n\t\t*/\r\n /*\r\n\t\t\t* The command bar hosts the 'close' button when the window does not\r\n\t\t\t* have a caption.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* Bug in Windows.  For some reason, when InsertMenuItem()\r\n\t\t\t* is used to insert an item without text, it is not possible\r\n\t\t\t* to use SetMenuItemInfo() to set the text at a later time.\r\n\t\t\t* The fix is to insert the item with some text.\r\n\t\t\t* \r\n\t\t\t* Feature in Windows.  When an empty string is used instead\r\n\t\t\t* of a space and InsertMenuItem() is used to set a submenu\r\n\t\t\t* before setting text to a non-empty string, the menu item\r\n\t\t\t* becomes unexpectedly disabled.  The fix is to insert a\r\n\t\t\t* space.\r\n\t\t\t*/\r\n /*\r\n* Currently not used.\r\n*/\r\n /*\r\n* Currently not used.\r\n*/\r\n /*public*/\r\n /*\r\n\t\t* Each time a menu has been modified, the command menu bar\r\n\t\t* must be redrawn or it won't update properly.  For example,\r\n\t\t* a submenu will not drop down.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  If a menu contains items that have\r\n\t* images and can be checked, Windows does not include\r\n\t* the width of the image and the width of the check when\r\n\t* computing the width of the menu.  When the longest item\r\n\t* does not have an image, the label and the accelerator\r\n\t* text can overlap.  The fix is to use SetMenuItemInfo()\r\n\t* to indicate that all items have a bitmap and then include\r\n\t* the width of the widest bitmap in WM_MEASURECHILD.\r\n\t* \r\n\t* NOTE:  This work around causes problems on Windows 98.\r\n\t* Under certain circumstances that have yet to be isolated,\r\n\t* some menus can become huge and blank.  For now, do not\r\n\t* run the code on Windows 98.\r\n\t*/\r\n /* Update the menu to hide or show the space for bitmaps */\r\n","ByteArrayTransfer":" The caller of this method must release the data when it is done with it.\r\n ","CoolItem":" /*\r\n* Not currently used.\r\n*/\r\n /*\r\n\t* Feature in Windows.  When Windows sets the rebar band child,\r\n\t* it makes the new child visible and hides the old child and\r\n\t* moves the new child to the top of the Z-order.  The fix is\r\n\t* to save and restore the visibility and Z-order.\r\n\t*/\r\n /* Get the child size fields first so we don't overwrite them. */\r\n /* Set the size fields we are currently modifying. */\r\n /* Get the child size fields first so we don't overwrite them. */\r\n /* Set the size fields we are currently modifying. */\r\n /*\r\n\t* Do not set the size for the last item on the row.\r\n\t*/\r\n /* Get the child size fields first so we don't overwrite them. */\r\n /* Set the size fields we are currently modifying. */\r\n","PngFileReadState":" Non - critical chunks\r\n  Set to true after IDATs have been read.\r\n ","COM":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  public static final int ADVFCACHE_ONSAVE = 32;\r\n  public static final int COINIT_SPEED_OVER_MEMORY = 8;\r\n  public static final int DISPID_AMBIENT_AUTOCLIP = -715;\r\n  public static final int DISPID_AMBIENT_DISPLAYNAME = -702;\r\n  public static final int DISPID_AMBIENT_SCALEUNITS = -707;\r\n  public static final int DISPID_AMBIENT_TRANSFERPRIORITY = -728;\r\n  public static final int DISPID_READYSTATECHANGE = -609;\r\n  public static final int DVASPECT_THUMBNAIL = 2;\r\n  public static final int E_POINTER = -2147467261;\r\n  public static final int GMEM_NODISCARD = 32;\r\n  public static final int IMPLTYPEFLAG_FDEFAULTVTABLE = 2048;\r\n  public static final int OLECHANGED = 0;\r\n  public static final int OLECLOSE_PROMPTSAVE = 2;\r\n  public static final int OLEEITHER = 2;\r\n  public static final int OLEFROZEN = 1;\r\n  public static final int OLEIVERB_HIDE = -3;\r\n  public static final int OLEIVERB_OPEN = -2;\r\n  public static final int OLEIVERB_UIACTIVATE = -4;\r\n  public static final int OLERENDER_ASIS = 3;\r\n  public static final int OLEWHICHMK_OBJREL = 2;\r\n  public static final int STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4;\r\n  public static final int STGC_OVERWRITE = 1;\r\n  public static final int TYMED_GDI = 16;\r\n  public static final int TYMED_NULL = 0;\r\n  public static final short DISPID_NEWENUM = -4;\r\n  public static final short DISPID_VALUE = 0;\r\n  public static final int ROLE_SYSTEM_TITLEBAR = 0x1;\r\n  public static final int ROLE_SYSTEM_ALERT = 0x8;\r\n  public static final int ROLE_SYSTEM_CHART = 0x11;\r\n  public static final int ROLE_SYSTEM_GROUPING = 0x14;\r\n  public static final int ROLE_SYSTEM_STATUSBAR = 0x17;\r\n  public static final int ROLE_SYSTEM_ROW = 0x1c;\r\n  public static final int ROLE_SYSTEM_CHARACTER = 0x20;\r\n  public static final int ROLE_SYSTEM_GRAPHIC = 0x28;\r\n  public static final int ROLE_SYSTEM_DROPLIST = 0x2f;\r\n  public static final int ROLE_SYSTEM_HOTKEYFIELD = 0x32;\r\n  public static final int ROLE_SYSTEM_WHITESPACE = 0x3b;\r\n  public static final int ROLE_SYSTEM_CLOCK = 0x3d;\r\n  public static final int STATE_SYSTEM_UNAVAILABLE = 0x1;\r\n  public static final int STATE_SYSTEM_INDETERMINATE = STATE_SYSTEM_MIXED;\r\n  public static final int STATE_SYSTEM_DEFAULT = 0x100;\r\n  public static final int STATE_SYSTEM_ANIMATED = 0x4000;\r\n  public static final int STATE_SYSTEM_SELFVOICING = 0x80000;\r\n  public static final int STATE_SYSTEM_TRAVERSED = 0x800000;\r\n ","Sash":" /* Calculate the new x or y position */\r\n /* Update the pointer position */\r\n /* Compute the banding rectangle */\r\n /* The event must be sent because doit flag is used */\r\n /* Draw the banding rectangle */\r\n /* Compute the banding rectangle */\r\n /* The event must be sent because doit flag is used */\r\n /* Compute the banding rectangle */\r\n /* The event must be sent because doit flag is used */\r\n","MouseAdapter":" ","Text":" }\r\n  ENDIAN\r\n  FALL THROUGH\r\n  ENDIAN\r\n  FALL THROUGH\r\n  widget could be disposed at this point\r\n /*\r\n\t* These values can be different on different platforms.\r\n\t* Therefore they are not initialized in the declaration\r\n\t* to stop the compiler from inlining.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When an edit control with ES_MULTILINE\r\n\t* style that does not have the WS_VSCROLL style is full (i.e.\r\n\t* there is no space at the end to draw any more characters),\r\n\t* EM_REPLACESEL sends a WM_CHAR with a backspace character\r\n\t* to remove any further text that is added.  This is an\r\n\t* implementation detail of the edit control that is unexpected\r\n\t* and can cause endless recursion when EM_REPLACESEL is sent\r\n\t* from a WM_CHAR handler.  The fix is to ignore calling the\r\n\t* handler from WM_CHAR.\r\n\t*/\r\n /*\r\n\t\t* Bug in WinCE.  Calling EM_SETSEL with -1 and 0 is equivalent\r\n\t\t* to calling EM_SETSEL with 0 and -1.  It causes the entire\r\n\t\t* text to be selected instead of clearing the selection.  The\r\n\t\t* fix is to set the start of the selection to the  end of the\r\n\t\t* current selection.\r\n\t\t*/\r\n /*\r\n\t* The preferred height of a single-line text widget\r\n\t* has been hand-crafted to be the same height as\r\n\t* the single-line text widget in an editable combo\r\n\t* box.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the edit control is not\r\n\t* mirrored, it uses WS_EX_RIGHT, WS_EX_RTLREADING and\r\n\t* WS_EX_LEFTSCROLLBAR to give the control a right to\r\n\t* left appearance.  This causes the control to be lead\r\n\t* aligned no matter what alignment was specified by\r\n\t* the programmer.  For example, setting ES_RIGHT and\r\n\t* WS_EX_LAYOUTRTL should cause the contents of the\r\n\t* control to be left (trail) aligned in a mirrored world.\r\n\t* When the orientation is changed by the user or\r\n\t* specified by the programmer, WS_EX_RIGHT conflicts\r\n\t* with the mirrored alignment.  The fix is to clear\r\n\t* or set WS_EX_RIGHT to achieve the correct alignment\r\n\t* according to the orientation and mirroring.\r\n\t*/\r\n /*\r\n\t\t* Bug in Windows 98. When the edit control is created\r\n\t\t* with the style ES_RIGHT it automatically sets the \r\n\t\t* WS_EX_LEFTSCROLLBAR bit.  The fix is to clear the\r\n\t\t* bit when the orientation of the control is left\r\n\t\t* to right.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  For some reason, Windows is unable\r\n\t* to return the pixel coordinates of the last character\r\n\t* in the widget.  The fix is to temporarily insert a\r\n\t* space, query the coordinates and delete the space.\r\n\t* The selection is always an i-beam in this case because\r\n\t* this is the only time the start of the selection can\r\n\t* be equal to the last character position in the widget.\r\n\t* If EM_POSFROMCHAR fails for any other reason, return\r\n\t* pixel coordinates (0,0). \r\n\t*/\r\n /*\r\n\t\t\t* Feature in Windows.  When an edit control with ES_MULTILINE\r\n\t\t\t* style that does not have the WS_VSCROLL style is full (i.e.\r\n\t\t\t* there is no space at the end to draw any more characters),\r\n\t\t\t* EM_REPLACESEL sends a WM_CHAR with a backspace character\r\n\t\t\t* to remove any further text that is added.  This is an\r\n\t\t\t* implementation detail of the edit control that is unexpected\r\n\t\t\t* and can cause endless recursion when EM_REPLACESEL is sent\r\n\t\t\t* from a WM_CHAR handler.  The fix is to ignore calling the\r\n\t\t\t* handler from WM_CHAR.\r\n\t\t\t*/\r\n /*\r\n\t* NOTE: The current implementation uses substring ()\r\n\t* which can reference a potentially large character\r\n\t* array.\r\n\t*/\r\n /*\r\n\t* Note, EM_GETSCROLLPOS is implemented in Rich Edit 3.0\r\n\t* and greater.  The plain text widget and previous versions\r\n\t* of Rich Edit return zero.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When an edit control with ES_MULTILINE\r\n\t* style that does not have the WS_VSCROLL style is full (i.e.\r\n\t* there is no space at the end to draw any more characters),\r\n\t* EM_REPLACESEL sends a WM_CHAR with a backspace character\r\n\t* to remove any further text that is added.  This is an\r\n\t* implementation detail of the edit control that is unexpected\r\n\t* and can cause endless recursion when EM_REPLACESEL is sent\r\n\t* from a WM_CHAR handler.  The fix is to ignore calling the\r\n\t* handler from WM_CHAR.\r\n\t*/\r\n /*\r\n\t* Disable all magic keys that could modify the text\r\n\t* and don't send events when Alt, Shift or Ctrl is\r\n\t* pressed.\r\n\t*/\r\n /*\r\n\t* If the left button is down, the text widget refuses the character.\r\n\t*/\r\n /* Verify the character */\r\n /* Bs */\r\n /* Del */\r\n /* Return */\r\n /* Tab and other characters */\r\n /*\r\n\t* Feature in Windows.  When an edit control with ES_MULTILINE\r\n\t* style that does not have the WS_VSCROLL style is full (i.e.\r\n\t* there is no space at the end to draw any more characters),\r\n\t* EM_REPLACESEL sends a WM_CHAR with a backspace character\r\n\t* to remove any further text that is added.  This is an\r\n\t* implementation detail of the edit control that is unexpected\r\n\t* and can cause endless recursion when EM_REPLACESEL is sent\r\n\t* from a WM_CHAR handler.  The fix is to ignore calling the\r\n\t* handler from WM_CHAR.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the caret is moved,\r\n\t* the text widget scrolls to show the new location.\r\n\t* This means that the text widget may be scrolled\r\n\t* to the right in order to show the caret when the\r\n\t* widget is not large enough to show both the caret\r\n\t* location and all the text.  Unfortunately, when\r\n\t* the text widget is resized such that all the text\r\n\t* and the caret could be visible, Windows does not\r\n\t* scroll the widget back.  The fix is to resize the\r\n\t* text widget, set the selection to the start of the\r\n\t* text and then restore the selection.  This will\r\n\t* cause the text widget compute the correct scroll\r\n\t* position.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When the password character is changed,\r\n\t* Windows does not redraw to show the new password character.\r\n\t* The fix is to force a redraw when the character is set.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When WM_SETREDRAW is used to turn\r\n\t* redraw off, the edit control is not scrolled to show the\r\n\t* i-beam.  The fix is to detect that the i-beam has moved\r\n\t* while redraw is turned off and force it to be visible\r\n\t* when redraw is restored.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  Windows expects the tab spacing in\r\n\t* dialog units so we must convert from space widths.  Due\r\n\t* to round off error, the tab spacing may not be the exact\r\n\t* number of space widths, depending on the font.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When the widget is multi line\r\n\t* text widget, it does not send a WM_COMMAND with\r\n\t* control code EN_CHANGE from SetWindowText () to\r\n\t* notify the application that the text has changed.\r\n\t* The fix is to send the event.\r\n\t*/\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have disposed the widget in the verify\r\n\t* event.  If this happens, answer null to cancel\r\n\t* the operation.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When the user types CTRL and BS\r\n\t* in an edit control, a DEL character is generated.\r\n\t* Rather than deleting the text, the DEL character\r\n\t* is inserted into the control.  The fix is to detect\r\n\t* this case and not call the window proc.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  For some reason, when the\r\n\t* widget is a single line text widget, when the\r\n\t* user presses tab, return or escape, Windows beeps.\r\n\t* The fix is to look for these keys and not call\r\n\t* the window proc.\r\n\t*/\r\n /*\r\n\t* Bug in WinCE PPC.  For some reason, sending WM_GETDLGCODE\r\n\t* to a multi-line edit control causes it to ignore return and\r\n\t* tab keys.  The fix is to return the value which is normally\r\n\t* returned by the text window proc on other versions of Windows.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  Despite the fact that the\r\n\t* edit control is read only, it still returns a\r\n\t* dialog code indicating that it wants all keys.  \r\n\t* The fix is to detect this case and clear the bits.\r\n\t* \r\n\t* NOTE: A read only edit control processes arrow keys\r\n\t* so DLGC_WANTARROWS should not be cleared.\r\n\t*/\r\n /* Process a DBCS character */\r\n /*\r\n\t* Feature in Windows.  The Windows text widget uses\r\n\t* two 2 WM_CHAR's to process a DBCS key instead of\r\n\t* using WM_IME_CHAR.  The fix is to allow the text\r\n\t* widget to get the WM_CHAR's but ignore sending\r\n\t* them to the application.\r\n\t*/\r\n /*\r\n\t* Prevent Windows from processing WM_LBUTTONDBLCLK\r\n\t* when double clicking behavior is disabled by not\r\n\t* calling the window proc.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When the last line of text in the\r\n\t* widget is double clicked and the line is empty, Windows\r\n\t* hides the i-beam then moves it to the first line in\r\n\t* the widget but does not scroll to show the user.\r\n\t* If the user types without clicking the mouse, invalid\r\n\t* characters are displayed at the end of each line of\r\n\t* text in the widget.  The fix is to detect this case\r\n\t* and avoid calling the window proc.\r\n\t*/\r\n /*\r\n\t* Note: On WinCE PPC, only attempt to recognize the gesture for\r\n\t* a context menu when the control contains a valid menu or there\r\n\t* are listeners for the MenuDetect event.\r\n\t* \r\n\t* Note: On WinCE PPC, the gesture that brings up a popup menu\r\n\t* on the text widget must keep the current text selection.  As a\r\n\t* result, the window proc is only called if the menu is not shown.\r\n\t*/\r\n /*\r\n\t\t\t* Feature in Windows.  When an edit control with ES_MULTILINE\r\n\t\t\t* style that does not have the WS_VSCROLL style is full (i.e.\r\n\t\t\t* there is no space at the end to draw any more characters),\r\n\t\t\t* EM_REPLACESEL sends a WM_CHAR with a backspace character\r\n\t\t\t* to remove any further text that is added.  This is an\r\n\t\t\t* implementation detail of the edit control that is unexpected\r\n\t\t\t* and can cause endless recursion when EM_REPLACESEL is sent\r\n\t\t\t* from a WM_CHAR handler.  The fix is to ignore calling the\r\n\t\t\t* handler from WM_CHAR.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* It is possible (but unlikely), that application\r\n\t\t\t* code could have disposed the widget in the modify\r\n\t\t\t* event.  If this happens, end the processing of the\r\n\t\t\t* Windows message by returning zero as the result of\r\n\t\t\t* the window proc.\r\n\t\t\t*/\r\n","WINDOWPOS":" ","NMREBARCHEVRON":" RECT rc;\r\n ","GRADIENT_RECT":" ","IOleObject":" create a null terminated array of char\r\n  create a null terminated array of char\r\n ","ITypeInfo":" add one to avoid rounding errors\r\n  add one to avoid rounding errors\r\n  add one to avoid rounding errors\r\n  create an array to hold the addresses\r\n  free the memory\r\n  create a null terminated array of char for each String\r\n  get the address of the start of the array of char\r\n  copy the address to the array of addresses\r\n  keep track of the Global Memory so we can free it\r\n  add one to avoid rounding errors\r\n ","JPEGVariableSizeSegment":" to use getSegmentLength()\r\n ","IOleInPlaceActiveObject":" lpmsg - Pointer to message that may need translating\r\n ","Clipboard":" ole interfaces\r\n  $NON-NLS-1$\r\n  No data available for this transfer\r\n  method4 GetDataHere - not implemented\r\n  method7 SetData - not implemented\r\n  register each of the interfaces that this object implements\r\n  only allow getting of data - SetData is not currently supported\r\n  what types have been registered?\r\n  include the drop effect format to specify a copy operation\r\n  specify that a copy operation is to be performed\r\n  get matching transfer agent to perform conversion\r\n  is this type supported by the transfer agent?\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  Loop over enumerator and save any types that match what we are looking for\r\n /*\r\n\t* Bug in Windows. When a new application takes control\r\n\t* of the clipboard, other applications may open the \r\n\t* clipboard to determine if they want to record the \r\n\t* clipoard updates.  When this happens, the clipboard \r\n\t* can not be accessed until the other application is\r\n\t* finished.  To allow the other applications to release\r\n\t* the clipboard, use PeekMessage() to enable cross thread\r\n\t* message sends.\r\n\t*/\r\n /*\r\n\t* Bug in Windows. When a new application takes control\r\n\t* of the clipboard, other applications may open the \r\n\t* clipboard to determine if they want to record the \r\n\t* clipoard updates.  When this happens, the clipboard \r\n\t* can not be flushed until the other application is\r\n\t* finished.  To allow other applications to get the\r\n\t* data, use PeekMessage() to enable cross thread\r\n\t* message sends.\r\n\t*/\r\n /* Called by a data consumer to obtain data from a source data object. \r\n\t   The GetData method renders the data described in the specified FORMATETC \r\n\t   structure and transfers it through the specified STGMEDIUM structure. \r\n\t   The caller then assumes responsibility for releasing the STGMEDIUM structure.\r\n\t*/\r\n","Transform":" ","LOGPEN":" POINT lopnWidth;\r\n ","LineStyleEvent":" line start offset\r\n  line text\r\n  array of StyleRanges\r\n ","CTabFolderAdapter":" ","TraverseEvent":" remove trailing '}'\r\n ","TreeItem":" TODO - take into account grid (add boolean arg) to damage less during redraw\r\n  TODO - items that are not in column zero don't need to be in the image list\r\n /*\r\n\t* When there are no columns and the tree is not\r\n\t* full selection, redraw only the text.  This is\r\n\t* an optimization to reduce flashing.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the user collapses the root\r\n\t* of a subtree that has the focus item, Windows moves\r\n\t* the selection to the root of the subtree and issues\r\n\t* a TVN_SELCHANGED to inform the programmer that the\r\n\t* seletion has changed.  When the programmer collapses\r\n\t* the same subtree using TVM_EXPAND, Windows does not\r\n\t* send the selection changed notification.  This is not\r\n\t* strictly wrong but is inconsistent.  The fix is to notice\r\n\t* that the selection has changed and issue the event.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When the font is changed for an item,\r\n\t* the bounds for the item are not updated, causing the text\r\n\t* to be clipped.  The fix is to reset the text, causing\r\n\t* Windows to compute the new bounds using the new font.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When the font is changed for an item,\r\n\t* the bounds for the item are not updated, causing the text\r\n\t* to be clipped.  The fix is to reset the text, causing\r\n\t* Windows to compute the new bounds using the new font.\r\n\t*/\r\n /*\r\n\t\t* Bug in Windows.  When I_IMAGECALLBACK is used with TVM_SETITEM\r\n\t\t* to indicate that an image has changed, Windows does not draw\r\n\t\t* the new image.  The fix is to use LPSTR_TEXTCALLBACK to force\r\n\t\t* Windows to ask for the text, causing Windows to ask for both.\r\n\t\t*/\r\n","MouseTrackListener":" ","DisposeEvent":" ","PngIendChunk":" Or if no IDAT chunk has been read.\r\n  IEND chunks are not allowed to have any data.\r\n ","TBBUTTON":" ","CLayoutData":" ","DRAWITEMSTRUCT":" RECT rcItem;\r\n ","JPEGFixedSizeSegment":" ","URLTransfer":" $NON-NLS-1$\r\n  URL is stored as a null terminated byte array\r\n /*public*/\r\n","LocationAdapter":" ","DropTargetEvent":" ","EventTable":" ","IEnumSTATSTG":" ","IEnumFORMATETC":" ","NONCLIENTMETRICSW":" ","Library":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$  /*\r\n     * Include platform name to support different windowing systems\r\n     * on same operating system.\r\n\t */\r\n /* Force 3 digits in minor version number */\r\n","DVTARGETDEVICE":" ","OleEventSink":" method5 GetIDsOfNames - not implemented\r\n  disconnect event sink\r\n  Note: parameters are passed in reverse order - here we will correct the order\r\n ","ScrollBar":" checkWidget ();\r\n  if ((style & SWT.HORIZONTAL) != 0) return OS.SB_HORZ;\r\n  if (OS.IsWinCE) error (SWT.ERROR_NOT_IMPLEMENTED);\r\n  if (OS.IsWinCE) error (SWT.ERROR_NOT_IMPLEMENTED);\r\n  if (OS.IsWinCE) error (SWT.ERROR_NOT_IMPLEMENTED);\r\n  the widget could be destroyed at this point\r\n /*\r\n* Not currently used.\r\n*/\r\n /*\r\n\t* Bug in Windows.  For some reason, when SetScrollInfo()\r\n\t* is used with SIF_POS and the scroll bar is hidden,\r\n\t* the opposite scroll bar is incorrectly made visible\r\n\t* so that the next time the parent is resized (or another\r\n\t* scroll bar operation is performed), the opposite scroll\r\n\t* bar draws.  The fix is to hide both scroll bars.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  For some reason, when the widget\r\n\t* is a standard scroll bar, and SetScrollInfo() is\r\n\t* called with SIF_RANGE or SIF_PAGE, the widget is\r\n\t* incorrectly made visible so that the next time the\r\n\t* parent is resized (or another scroll bar operation\r\n\t* is performed), the scroll bar draws.  The fix is\r\n\t* to hide the scroll bar (again) when already hidden.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  Using SIF_DISABLENOSCROLL,\r\n\t* SetScrollInfo () can change enabled and disabled\r\n\t* state of the scroll bar causing a scroll bar that\r\n\t* was disabled by the application to become enabled.\r\n\t* The fix is to disable the scroll bar (again) when\r\n\t* the application has disabled the scroll bar.\r\n\t*/\r\n /*\r\n\t\t\t* Bug in Windows.  When the only changed flag to\r\n\t\t\t* SetScrollInfo () is OS.SIF_DISABLENOSCROLL, \r\n\t\t\t* Windows does not update the scroll bar state.\r\n\t\t\t* The fix is to increase and then decrease the\r\n\t\t\t* maximum, causing Windows to honour the flag.\r\n\t\t\t*/\r\n /*\r\n\t* On Windows CE, use SIF_DISABLENOSCROLL to show and\r\n\t* hide the scroll bar when the page size is equal to\r\n\t* the range.\r\n\t*/\r\n /*\r\n\t* Set the state bits before calling ShowScrollBar ()\r\n\t* because hiding and showing the scroll bar can cause\r\n\t* WM_SIZE messages when the client area is resized.\r\n\t* Setting the state before the call means that code\r\n\t* that runs during WM_SIZE that queries the visibility\r\n\t* of the scroll bar will get the correct value.\r\n\t*/\r\n /*\r\n\t\t* Bug in Windows.  For some reason, when the widget\r\n\t\t* is a standard scroll bar, and SetScrollInfo () is\r\n\t\t* called with SIF_RANGE or SIF_PAGE while the widget\r\n\t\t* is not visible, the widget is incorrectly disabled\r\n\t\t* even though the values for SIF_RANGE and SIF_PAGE,\r\n\t\t* when set for a visible scroll bar would not disable\r\n\t\t* the scroll bar.  The fix is to enable the scroll bar\r\n\t\t* when not disabled by the application and the current\r\n\t\t* scroll bar ranges would cause the scroll bar to be\r\n\t\t* enabled had they been set when the scroll bar was\r\n\t\t* visible.\r\n\t\t*/\r\n /* Do nothing when scrolling is ending */\r\n /*\r\n\t* Send the event because WM_HSCROLL and\r\n\t* WM_VSCROLL are sent from a modal message\r\n\t* loop in Windows that is active when the\r\n\t* user is scrolling.\r\n\t*/\r\n","WINDOWPLACEMENT":" POINT ptMinPosition;\r\n  POINT ptMaxPosition;\r\n  RECT  rcNormalPosition;\r\n ","NONCLIENTMETRICSA":" ","RECT":" ","SCRIPT_STATE":" ","IMoniker":" ","IEnumVARIANT":" ","ColorDialog":" $NON-NLS-1$\r\n /* Use the character encoding for the default locale */\r\n /* Get the owner HWND for the dialog */\r\n /* Allocate the Custom Colors */\r\n /* Open the dialog */\r\n /* Make the parent shell be temporary modal */\r\n /* Open the dialog */\r\n /* Clear the temporary dialog modal parent */\r\n /* Free the CCHookProc */\r\n","JPEGHuffmanTable":" maximum is 4 AC + 4 DC\r\n  table class: AC (1) or DC (0)\r\n  table id: 0-1 baseline, 0-3 prog  start with 50 and increment as needed\r\n  start with 50 and increment as needed\r\n /* Read the 16 count bytes and add them together to get the table size. */\r\n /* Read the table. */\r\n /* Truncate huffCodeLengths to the correct size. */\r\n /* Truncate huffCodes to the correct size. */\r\n /* Calculate the maximum and minimum codes */\r\n /* Calculate the eHuffman codes and lengths. */\r\n /* Create the new JPEGHuffmanTable and add it to the allTables array. */\r\n","Monitor":" ","NMTTDISPINFO":" ","NoDragUnderEffect":" ","IConnectionPointContainer":" ","ToolItem":" if ((style & SWT.RADIO) != 0) return OS.BTNS_CHECKGROUP;\r\n /*\r\n\t* In order to emulate all the processing that\r\n\t* happens when a mnemonic key is pressed, fake\r\n\t* a mouse press and release.  This will ensure\r\n\t* that radio and pull down items are handled\r\n\t* properly.\r\n\t*/\r\n /*\r\n  \t* In order to be consistent with the way that disabled\r\n\t* images appear in other places in the user interface,\r\n\t* use the SWT Graphics to create a disabled image instead\r\n    * of calling DrawState().\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  For some reason, a tool item that has\r\n\t* the style BTNS_SEP does not return I_IMAGENONE when queried\r\n\t* for an image index, despite the fact that no attempt has been\r\n\t* made to assign an image to the item.  As a result, operations\r\n\t* on an image list that use the wrong index cause random results.\t\r\n\t* The fix is to ensure that the tool item is not a separator\r\n\t* before using the image index.  Since separators cannot have\r\n\t* an image and one is never assigned, this is not a problem.\r\n\t*/\r\n /*\r\n\t\t* Set the size and location of the control\r\n\t\t* separately to minimize flashing in the\r\n\t\t* case where the control does not resize\r\n\t\t* to the size that was requested.  This\r\n\t\t* case can occur when the control is a\r\n\t\t* combo box.\r\n\t\t*/\r\n /*\r\n\t\t\t* Bug in Windows.  When TB_SETBUTTONINFO changes the\r\n\t\t\t* style of a tool item from BTNS_SEP to BTNS_BUTTON\r\n\t\t\t* and the tool bar is wrapped, the tool bar does not\r\n\t\t\t* redraw properly.  Windows uses separator items as\r\n\t\t\t* wrap points and sometimes draws etching above or\r\n\t\t\t* below and entire row.  The fix is to redraw the\r\n\t\t\t* tool bar.\r\n\t\t\t*/\r\n /*\r\n\t* Feature in Windows.  When a tool bar wraps, tool items\r\n\t* with the style BTNS_SEP are used as wrap points.  This\r\n\t* means that controls that are placed on top of separator\r\n\t* items are not positioned properly.  Also, vertical tool\r\n\t* bars are implemented using TB_SETROWS to set the number\r\n\t* of rows.  When a control is placed on top of a separator,\r\n\t* the height of the separator does not grow.  The fix in\r\n\t* both cases is to change the tool item style from BTNS_SEP\r\n\t* to BTNS_BUTTON, causing the item to wrap like a tool item\r\n\t* button.  The new tool item button is disabled to avoid key\r\n\t* traversal and the image is set to I_IMAGENONE to avoid\r\n\t* getting the first image from the image list.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When TB_SETSTATE is used to set the\r\n\t* state of a tool item, the item redraws even when the state\r\n\t* has not changed.  The fix is to detect this case and avoid\r\n\t* setting the state. \r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When TB_SETSTATE is used to set the\r\n\t* state of a tool item, the item redraws even when the state\r\n\t* has not changed.  The fix is to detect this case and avoid\r\n\t* setting the state. \r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When a tool item with the style\r\n\t* BTNS_CHECK or BTNS_CHECKGROUP is selected and then\r\n\t* disabled, the item does not draw using the disabled\r\n\t* image.  The fix is to use the disabled image in all\r\n\t* image lists.\r\n\t* \r\n\t* NOTE: This means that the image list must be updated\r\n\t* when the selection changes in a disabled tool item.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  For some reason, when the font is set\r\n\t* before any tool item has text, the tool items resize to\r\n\t* a very small size.  Also, a tool item will only show text\r\n\t* when text has already been set on one item and then a new\r\n\t* item is created.  The fix is to use WM_SETFONT to force\r\n\t* the tool bar to redraw and layout.\r\n\t*/\r\n /*\r\n\t\t* Bug in Windows.  When a tool item with the style\r\n\t\t* BTNS_CHECK or BTNS_CHECKGROUP is selected and then\r\n\t\t* disabled, the item does not draw using the disabled\r\n\t\t* image.  The fix is to use the disabled image in all\r\n\t\t* image lists.\r\n\t\t*/\r\n /*\r\n\t\t* Bug in Windows.  When a tool item with the style\r\n\t\t* BTNS_CHECK or BTNS_CHECKGROUP is selected and then\r\n\t\t* disabled, the item does not draw using the disabled\r\n\t\t* image.  The fix is to assign the disabled image in\r\n\t\t* all image lists.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  If the width of an item has already been\r\n\t* calculated, the tool bar control will not recalculate it to \r\n\t* include the space for the image.  The fix is to set the width\r\n\t* to zero, forcing the control recalculate the width for the item.\r\n\t*/\r\n","DLLVERSIONINFO":" ","ShellAdapter":" ","PaintEvent":" remove trailing '}'\r\n ","OS":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  public static final int EVENT_OBJECT_SELECTION = 0x8006;\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  public static final int WM_GETICON = 0x7f;\r\n /*\r\n\t* SWT Windows flags\r\n\t*/\r\n /*\r\n\t* Flags for Window API GetVersionEx()\r\n\t*/\r\n /*\r\n\t\t* Try the UNICODE version of GetVersionEx first\r\n\t\t* and then the ANSI version.  The UNICODE version\r\n\t\t* is present on all versions of Windows but is not\r\n\t\t* implemented on Win95/98/ME.\r\n\t\t* \r\n\t\t* NOTE: The value of OSVERSIONINFO.sizeof cannot\r\n\t\t* be static final because it relies on the Windows\r\n\t\t* platform version to be initialized and IsUnicode\r\n\t\t* has not been calculated.  It must be initialized\r\n\t\t* here, after the platform is determined in order\r\n\t\t* for the value to be correct.\r\n\t\t*/\r\n /* Get the DBCS flag */\r\n /*\r\n\t\t* Bug in Windows.  On Korean Windows XP when the Text\r\n\t\t* Services Framework support for legacy applications\r\n\t\t* is enabled, certain legacy calls segment fault.\r\n\t\t* For example, when ImmSetCompositionWindow() is used\r\n\t\t* to move the composition window outside of the client\r\n\t\t* area, Windows crashes.  The fix is to disable legacy\r\n\t\t* support.\r\n\t\t*/\r\n /* Get the Windows version and the flags */\r\n /* Get the COMCTL32.DLL version */\r\n /* Get the Shell32.DLL version */\r\n /* Flag used on WinCE */\r\n /* Constants */\r\n /* returns the instance handle to the swt library */\r\n","BITMAP":" ","BidiSegmentListener":" ","Scale":" widget could be disposed at this point\r\n /*\r\n\t\t* Feature in Windows.  The track bar window class\r\n\t\t* does not include CS_DBLCLKS.  This mean that these\r\n\t\t* controls will not get double click messages such as\r\n\t\t* WM_LBUTTONDBLCLK.  The fix is to register a new \r\n\t\t* window class with CS_DBLCLKS.\r\n\t\t* \r\n\t\t* NOTE:  Screen readers look for the exact class name\r\n\t\t* of the control in order to provide the correct kind\r\n\t\t* of assistance.  Therefore, it is critical that the\r\n\t\t* new window class have the same name.  It is possible\r\n\t\t* to register a local window class with the same name\r\n\t\t* as a global class.  Since bits that affect the class\r\n\t\t* are being changed, it is possible that other native\r\n\t\t* code, other than SWT, could create a control with\r\n\t\t* this class name, and fail unexpectedly.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  Changing the background color of the Scale\r\n\t* widget and calling InvalidateRect() still draws with the old\r\n\t* color.  The fix is to post a fake WM_SETFOCUS event to cause\r\n\t* it to redraw with the new background color.\r\n\t* \r\n\t* Note.  This WM_SETFOCUS message causes recursion when\r\n\t* setBackground is called from within the focus event\r\n\t* listener.\r\n\t*/\r\n /* Do nothing when scrolling is ending */\r\n /*\r\n\t* Send the event because WM_HSCROLL and WM_VSCROLL\r\n\t* are sent from a modal message loop in windows that\r\n\t* is active when the user is scrolling.\r\n\t*/\r\n","Point":" $NON-NLS-1$  ","COSERVERINFO":" ","Callback":" $NON-NLS-1$\r\n  $NON-NLS-1$    $NON-NLS-1$    $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n /*long*/\r\n /* Load the SWT library */\r\n /* Set the callback fields */\r\n /* Inline the common cases */\r\n /* Bind the address */\r\n /*long*/\r\n /*long*/\r\n /*long*/\r\n /*long*/\r\n","TableTreeEditor":" To be consistent with older versions of SWT, grabVertical defaults to true\r\n  default is CENTER\r\n  default is CENTER\r\n  In this situation, there is a single default column.\r\n ","OleClientSite":" Interfaces for this Ole Client Container\r\n  References to the associated Frame.\r\n  Access to the embedded  IStorage interface of the receiver\r\n  the display aspect of the embedded object, e.g., DvaspectContent or DvaspectIcon\r\n  Indicates the type of client that can be supported inside this container\r\n  Indicates item's display is static, i.e., a bitmap, metafile, etc.\r\n  $NON-NLS-1$\r\n  install the Ole Frame for this Client Site\r\n  Is there an associated CLSID?\r\n  associated CLSID may not be installed on this machine\r\n  Open a temporary storage object\r\n  Create ole object with storage object\r\n  Init sinks\r\n  Open a temporary storage object\r\n  Create ole object with storage object\r\n  Init sinks\r\n  Are we opening this file with the preferred OLE object?\r\n  Not using the same application that created file, therefore, copy from original file to a new storage file\r\n  Original file is not a Storage file so copy contents to a stream in a new storage file\r\n  Increments ref count if successful\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  Increments ref count if successful\r\n  Copy over data in file to named stream\r\n  Does an AddRef if successful\r\n  Open a temporary storage object\r\n  Copy over contents of file\r\n  create ole client\r\n  get the persistant storage of the ole client\r\n  load the contents of the file into the ole client site\r\n  Using the same application that created file, therefore, use default mechanism.\r\n  Create ole object with storage object\r\n  Init sinks\r\n  \r\n  \r\n  \r\n  $NON-NLS-1$   Notify the control object that it is embedded in an OLE container\r\n  Is OLE object linked or embedded?\r\n  method4 GetMoniker - not implemented\r\n  method5 OnRename - not implemented\r\n  method13 DeactivateAndUndoChange - not implemented\r\n  Destroy this item's contents in the temp root IStorage.\r\n  The fix is to ensure that the client is in the running state before invoking any verb on it.\r\n  See PR: 1FV9RZW\r\n  create a GUID struct to hold the result\r\n  create a null terminated array of char\r\n  get the current size of the embedded OLENatives object\r\n  remove null terminator\r\n  TRUE\r\n  TRUE\r\n  Copy the Window's handle into the memory passed in\r\n  fill in frame handle\r\n  null out document handle\r\n  fill in position and clipping info\r\n  get frame info\r\n  Get access to the persistant storage mechanism\r\n  Are the contents of the permanent storage different from the file?\r\n  Note, must release object interfaces before releasing frame\r\n  remove listeners\r\n  $NON-NLS-1$\r\n  currently, we are ignoring the fUndoable flag\r\n  }\r\n  Note: if file does not exist, this will create the file the\r\n  first time it is called\r\n  of the native data that follows.\r\n  Read the data\r\n  Note: if file does not exist, this will create the file\r\n  open the file and write data into it\r\n  save fails)\r\n  get access to the persistant storage mechanism\r\n  Does an AddRef if successful\r\n  save fails)\r\n  $NON-NLS-1$\r\n  Look for a CONTENTS stream\r\n  $NON-NLS-1$\r\n  Look for Ole 1.0 object stream\r\n  readjust size and location of client site\r\n  Get the server running first, then do a SetExtent, then show it\r\n  Close server if it wasn't already running upon entering this method.\r\n  leave a border\r\n  Get the Property Page information from the OLE Object\r\n  create a frame in which to display the pages\r\n  free the property page information\r\n  OleSave will fail for static objects, so do what OleSave does.\r\n  logical pixels  logical pixels  2540 HIMETRIC units per inch\r\n  logical pixels  logical pixels  2540 HIMETRIC units per inch\r\n /*\r\n\t * NOTE: this constructor should never be used by itself because it does\r\n\t * not create an Ole Object\r\n\t */\r\n /* required for traversal */\r\n /* Simple containers that do not support links to their embedded \r\n\t * objects probably do not need to implement this method. Instead, \r\n\t * they can return E_NOINTERFACE and set ppContainer to NULL.\r\n\t */\r\n /* Tells the container to position the object so it is visible to \r\n\t * the user. This method ensures that the container itself is \r\n\t * visible and not minimized.\r\n\t */\r\n","IOleLink":" ","POINT":" ","ImageLoader":" /*\r\n\t * the set of ImageLoader event listeners, created on demand\r\n\t */\r\n","FileDialog":" /* Get the owner HWND for the dialog */\r\n /* Convert the title and copy it into lpstrTitle */\r\n /* Use the character encoding for the default locale */\r\n /* Compute filters and copy into lpstrFilter */\r\n /* Use the character encoding for the default locale */\r\n /* Convert the fileName and filterName to C strings */\r\n /* Use the character encoding for the default locale */\r\n /*\r\n\t* Copy the name into lpstrFile and ensure that the\r\n\t* last byte is NULL and the buffer does not overrun.\r\n\t*/\r\n /*\r\n\t* Copy the path into lpstrInitialDir and ensure that\r\n\t* the last byte is NULL and the buffer does not overrun.\r\n\t*/\r\n /* Use the character encoding for the default locale */\r\n /* Create the file dialog struct */\r\n /*\r\n\t* Set the default extension to an empty string.  If the\r\n\t* user fails to type an extension and this extension is\r\n\t* empty, Windows uses the current value of the filter\r\n\t* extension at the time that the dialog is closed.\r\n\t*/\r\n /* Make the parent shell be temporary modal */\r\n /*\r\n\t* Open the dialog.  If the open fails due to an invalid\r\n\t* file name, use an empty file name and open it again.\r\n\t*/\r\n /* Clear the temporary dialog modal parent */\r\n /* Set the new path, file name and filter */\r\n /* Use the character encoding for the default locale */\r\n /*\r\n\t\t* Bug in WinCE.  For some reason, nFileOffset and nFileExtension\r\n\t\t* are always zero on WinCE HPC. nFileOffset is always zero on\r\n\t\t* WinCE PPC when using GetSaveFileName.  nFileOffset is correctly\r\n\t\t* set on WinCE PPC when using OpenFileName.  The fix is to parse\r\n\t\t* lpstrFile to calculate nFileOffset.\r\n\t\t* \r\n\t\t* Note: WinCE does not support multi-select file dialogs.\r\n\t\t*/\r\n /* Use the character encoding for the default locale */\r\n /*\r\n\t\t\t* Get each file from the buffer.  Files are delimited\r\n\t\t\t* by a NULL character with 2 NULL characters at the end.\r\n\t\t\t*/\r\n /* Free the memory that was allocated. */\r\n /* Answer the full path or null */\r\n","PopupList":" close dialog if user selects outside of the shell\r\n  resize shell when list resizes\r\n  return list selection on Mouse Up or Carriage Return\r\n  Position the dialog so that it does not run off the screen and the largest number of items are visible\r\n  place popup list below table cell\r\n  place popup list above table cell\r\n  Make dialog as wide as the cell\r\n  dialog width should not be les than minimumwidth\r\n  Align right side of dialog with right side of cell\r\n  specified string\r\n ","TRIVERTEX":" ","HelpListener":" ","JPEGComment":" ","JPEGFileFormat":" Sequential: Clear and reuse the data unit buffer.\r\n  Subsequent scans - refine the existing data unit.\r\n  display the image incrementally.\r\n  Non-interleaved.\r\n  sqrt(2) * c3\r\n  sqrt(2) * (-c1+c3+c5-c7)\r\n  sqrt(2) * ( c1+c3-c5+c7)\r\n  sqrt(2) * ( c1+c3+c5-c7)\r\n  sqrt(2) * ( c1+c3-c5-c7)\r\n  sqrt(2) * (c7-c3)\r\n  sqrt(2) * (-c1-c3)\r\n  sqrt(2) * (-c3-c5)\r\n  sqrt(2) * (c5-c3)\r\n  sqrt(2) * c3\r\n  sqrt(2) * (-c1+c3+c5-c7)\r\n  sqrt(2) * ( c1+c3-c5+c7)\r\n  sqrt(2) * ( c1+c3+c5-c7)\r\n  sqrt(2) * ( c1+c3-c5-c7)\r\n  sqrt(2) * (c7-c3)\r\n  sqrt(2) * (-c1-c3)\r\n  sqrt(2) * (-c3-c5)\r\n  sqrt(2) * (c5-c3)\r\n  we no longer check for appN\r\n  Sequential jpeg: only need one data unit.\r\n  Progressive jpeg: need to keep all of the data units.\r\n  there should only be one SOI per file\r\n /* JPEGConstants */\r\n /* JPEGFixedPointConstants */\r\n /* JPEGMarkerCodes */\r\n /* JPEGFrameComponentParameterConstants */\r\n /* JPEGScanComponentParameterConstants */\r\n /* JFIF Component Constants */\r\n /* Unsupported CMYK format. Answer an empty byte array. */\r\n /* Unsupported CMYK format. Answer an empty byte array. */\r\n /* sqrt(2) * (-c1+c3+c5-c7) */\r\n /* sqrt(2) * ( c1+c3-c5+c7) */\r\n /* sqrt(2) * ( c1+c3+c5-c7) */\r\n /* sqrt(2) * ( c1+c3-c5-c7) */\r\n /* sqrt(2) * (c7-c3) */\r\n /* sqrt(2) * (-c1-c3) */\r\n /* sqrt(2) * (-c3-c5) */\r\n /* sqrt(2) * (-c1+c3+c5-c7) */\r\n /* sqrt(2) * ( c1+c3-c5+c7) */\r\n /* sqrt(2) * ( c1+c3+c5-c7) */\r\n /* sqrt(2) * ( c1+c3-c5-c7) */\r\n /* sqrt(2) * (c7-c3) */\r\n /* sqrt(2) * (-c1-c3) */\r\n /* sqrt(2) * (-c3-c5) */\r\n /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */\r\n /* Process the tables preceding the frame header. */\r\n /* Start of Frame. */\r\n /* Process the tables preceding the scan header. */\r\n /* Start of Scan. */\r\n /* Process scan(s) and further tables until EOI. */\r\n /* Unread any buffered data before looking for tables again. */\r\n /* Process the tables preceding the next scan header. */\r\n /* Process all markers until a frame header, scan header, or EOI is found. */\r\n","PointF":" ","OLE":" Used for functions that semantically return a Boolean FALSE result to indicate that the function succeeded.\r\n  Function succeeded.\r\n  Unspecified failure.\r\n  Invalid argument\r\n  QueryInterface did not recognize the requested interface.\r\n  Not implemented\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  close the OLE object and discard the undo state\r\n  hide the OLE object\r\n  open the OLE for editing in-place\r\n  open the OLE object for editing in a separate window\r\n  opens the OLE object for editing\r\n  request the OLE object properties dialog\r\n  show the OLE object\r\n  activate the UI for the OLE object\r\n  Boolean; True=-1, False=0.\r\n  Binary String.\r\n  By reference - must be combined with one of the othre VT values\r\n  Currency.\r\n  Date.\r\n  IDispatch\r\n  Not specified.\r\n  Scodes.\r\n  2-byte signed int.\r\n  4-byte signed int.\r\n  Null.\r\n  4-byte real.\r\n  8-byte real.\r\n  Unsigned char.\r\n  Unsigned int.\r\n  IUnknown FAR*.\r\n  VARIANT FAR*.\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n /* Ole Property Description flags */\r\n /* Ole Property Description kind */\r\n /* Ole Parameter Description flags */\r\n /* Ole Function Description Invoke Kind values */\r\n /* Ole Function Description function kind */\r\n /* Ole Function Description function flags */\r\n /* Ole Function Description calling convention */\r\n /* Illegal Arguments (non-fatal) */\r\n /* SWT Errors (non-fatal) */\r\n /* OS Failure/Limit (fatal, may occur only on some platforms) */\r\n /* Unknown/Undefined Error */\r\n /* Use the character encoding for the default locale */\r\n /*\r\n * Finds the OLE program id that is associated with an extension.\r\n * The extension may or may not begin with a '.'.  On platforms\r\n * that do not support OLE, an empty string is returned.\r\n *\r\n * @param extension the program extension\r\n * @return a string that is the OLE program id or an empty string\r\n *\r\n * @exception IllegalArgumentException <ul>\r\n *\t\t<li>ERROR_NULL_ARGUMENT when extension is null</li>\r\n *\t</ul>\r\n */\r\n /* Use the character encoding for the default locale */\r\n","COMObject":" $NON-NLS-1$\r\n  create a null terminated array of char\r\n  invoke system method\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  find the object on which this call was invoked\r\n  free the memory for this reference\r\n  remove this ppVtable from the list\r\n ","RTFTransfer":" $NON-NLS-1$\r\n  CF_RTF is stored as a null terminated byte array\r\n ","DOCINFO":" LPCTSTR\r\n  LPCTSTR\r\n  LPCTSTR\r\n  DWORD\r\n ","ICONINFO":" ","ControlListener":" ","SerializableCompatibility":" ","DeviceData":" /*\r\n\t* Debug fields - may not be honoured\r\n\t* on some SWT platforms.\r\n\t*/\r\n","JPEGRestartInterval":" ","IOleCommandTarget":" Pointer to command group\r\n  Identifier of command to execute\r\n  Options for executing the command\r\n  Pointer to input arguments\r\n  Pointer to command output\r\n  we only support querying for one command at a time\r\n  Pointer to command group\r\n  Number of commands in prgCmds array\r\n  Array of commands\r\n  Pointer to name or status of command\r\n ","Rect":" ","OlePropertyDescription":" ","LOGFONTA":" ","Drawable":" /*long*/\r\n /*long*/\r\n","DropTargetAdapter":" ","ViewForm":" SWT widgets\r\n  Configuration and state info\r\n  checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n ","PRINTDLG":" DWORD\r\n  HWND\r\n  HGLOBAL\r\n  HGLOBAL\r\n  HDC\r\n  DWORD\r\n  WORD\r\n  WORD\r\n  WORD\r\n  WORD\r\n  WORD\r\n  HINSTANCE\r\n  LPARAM\r\n  LPPRINTHOOKPROC\r\n  LPSETUPHOOKPROC\r\n  LPCTSTR\r\n  LPCTSTR\r\n  HGLOBAL\r\n  HGLOBAL\r\n ","IOleDocument":" ","JPEGAppn":" ","Compatibility":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n ","Group":" /*\r\n\t\t* Feature in Windows.  The group box window class\r\n\t\t* uses the CS_HREDRAW and CS_VREDRAW style bits to\r\n\t\t* force a full redraw of the control and all children\r\n\t\t* when resized.  This causes flashing.  The fix is to\r\n\t\t* register a new window class without these bits and\r\n\t\t* implement special code that damages only the exposed\r\n\t\t* area.\r\n\t\t* \r\n\t\t* Feature in WinCE.  On certain devices, defining\r\n\t\t* a new window class which looks like BUTTON causes\r\n\t\t* CreateWindowEx() to crash.  The workaround is to use\r\n\t\t* the class Button directly.\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows.  When the user clicks on the group\r\n\t* box label, the group box takes focus.  This is unwanted.\r\n\t* The fix is to avoid calling the group box window proc.\r\n\t*/\r\n /*\r\n\t* Even though it is legal to create this widget\r\n\t* with scroll bars, they serve no useful purpose\r\n\t* because they do not automatically scroll the\r\n\t* widget's client area.  The fix is to clear\r\n\t* the SWT style.\r\n\t*/\r\n /*\r\n\t\t* If the group has text, and the text is wider than the\r\n\t\t* client area, pad the width so the text is not clipped.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  When GetDCEx() is called with DCX_INTERSECTUPDATE,\r\n\t* the HDC that is returned does not include the current update region.\r\n\t* This was confirmed under DEBUG Windows when GetDCEx() complained about\r\n\t* invalid flags.  Therefore, it is not easily possible to get an HDC from\r\n\t* outside of WM_PAINT that includes the current damage and clips children.\r\n\t* Because the receiver has children and draws a frame and label, it is\r\n\t* necessary that the receiver always draw clipped, in the current damaged\r\n\t* area.  The fix is to force the receiver to be fully clipped by including\r\n\t* WS_CLIPCHILDREN and WS_CLIPSIBLINGS in the default style bits.\r\n\t*/\r\n /*\r\n\t* Feaure in Windows.  Group boxes do not erase\r\n\t* the background before drawing.  The fix is to\r\n\t* fill the background.\r\n\t* \r\n\t* NOTE:  This work around causes flashing on XP\r\n\t* and is not necessary when a parent has a theme.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  The window proc for the group box\r\n\t* returns HTTRANSPARENT indicating that mouse messages\r\n\t* should not be delivered to the receiver and any children.\r\n\t* Normally, group boxes in Windows do not have children and\r\n\t* this is the correct behavior for this case.  Because we\r\n\t* allow children, answer HTCLIENT to allow mouse messages\r\n\t* to be delivered to the children.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  In version 6.00 of COMCTL32.DLL,\r\n\t* every time the mouse moves, the group title redraws.\r\n\t* This only happens when WM_NCHITTEST returns HTCLIENT.\r\n\t* The fix is to avoid calling the group window proc.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  In version 6.00 of COMCTL32.DLL,\r\n\t* when WM_PRINTCLIENT is sent from a child BS_GROUP\r\n\t* control to a parent BS_GROUP, the parent BS_GROUP\r\n\t* clears the font from the HDC.  Normally, group boxes\r\n\t* in Windows do not have children so this behavior is\r\n\t* undefined.  When the parent of a BS_GROUP is not a\r\n\t* BS_GROUP, there is no problem.  The fix is to save\r\n\t* and restore the current font.\r\n\t*/\r\n","LOGFONT":" ","Spinner":" if (!hooks (SWT.Verify) && !filters (SWT.Verify)) return true;\r\n  FALL THROUGH\r\n  case OS.WM_MOUSEWHEEL:\t\tresult = wmMouseWheel (hwnd, wParam, lParam); break;\r\n  FALL THROUGH\r\n  if (!hooks (SWT.Verify) && !filters (SWT.Verify)) return null;\r\n /*\r\n\t* Even though it is legal to create this widget\r\n\t* with scroll bars, they serve no useful purpose\r\n\t* because they do not automatically scroll the\r\n\t* widget's client area.  The fix is to clear\r\n\t* the SWT style.\r\n\t*/\r\n /* Get the trim of the text control */\r\n /*\r\n\t* The preferred height of a single-line text widget\r\n\t* has been hand-crafted to be the same height as\r\n\t* the single-line text widget in an editable combo\r\n\t* box.\r\n\t*/\r\n /*\r\n\t* Disable all magic keys that could modify the text\r\n\t* and don't send events when Alt, Shift or Ctrl is\r\n\t* pressed.\r\n\t*/\r\n /*\r\n\t* If the left button is down, the text widget refuses the character.\r\n\t*/\r\n /* Verify the character */\r\n /* Bs */\r\n /* Del */\r\n /* Return */\r\n /* Tab and other characters */\r\n /* Keyboard messages */\r\n /* Mouse Messages */\r\n /* Focus Messages */\r\n /* Paint messages */\r\n /* Menu messages */\r\n /* Clipboard messages */\r\n /*\r\n\t* Feature in Windows.  For some reason, when the\r\n\t* widget is a single line text widget, when the\r\n\t* user presses tab, return or escape, Windows beeps.\r\n\t* The fix is to look for these keys and not call\r\n\t* the window proc.\r\n\t*/\r\n /* Increment the value */\r\n /*  Stop the edit control from moving the caret */\r\n /*\r\n\t\t\t* The SWT.Modify event is sent after the widget has been\r\n\t\t\t* updated with the new state.  Rather than allowing\r\n\t\t\t* the default updown window proc to set the value\r\n\t\t\t* when the user clicks on the updown control, set\r\n\t\t\t* the value explicity and stop the window proc\r\n\t\t\t* from running.\r\n\t\t\t*/\r\n","WrappedContent":" index of line offset in visualLines array\r\n  index of line lenght in visualLines array\r\n  start and length of each visual line\r\n  redirect call to logical content if there are no wrapped lines\r\n  redirect call to logical content if there are no wrapped lines\r\n  count which is only available in the visual content.\r\n  last character) - for inserting\r\n  (they have the same offset). always return the first visual line\r\n  redirect call to logical content if there are no wrapped lines\r\n  redirect call to logical content if there are no wrapped lines\r\n  first logical line that has at least one visual line reset.\r\n  being reset.\r\n  i.e., there must not be any reset but unwrapped lines\r\n  there are more visual lines for a given logical line than before\r\n  do nothing if there are no wrapped lines\r\n  at the start of a visual line  visual lines for a given logical line than before\r\n  is known.\r\n ","LOGFONTW":" ","LVHITTESTINFO":" POINT pt;\r\n ","TOOLINFO":" public RECT rect;\r\n ","TVHITTESTINFO":" POINT pt;\r\n ","AccessibleTextEvent":" IN\r\n  OUT\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n ","OLEINPLACEFRAMEINFO":" ","BidiUtil":" Keyboard language ids\r\n  bidi flag\r\n  getRenderInfo flag values\r\n  switching\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  GetCharacterPlacement constants\r\n  ExtTextOut constants\r\n  Windows primary language identifiers\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  ActivateKeyboard constants\r\n  fixes bug 40006\r\n  render transparently to avoid overlapping segments. fixes bug 40006\r\n  set required dwFlags\r\n  on a platform that supports bidi.  Fixes 20690.\r\n  set classification values for the substring\r\n  the actual number returned may be less in case of Arabic ligatures.\r\n  segments without overlapping.\r\n  ordered\r\n  on a platform that supports bidi.  Fixes 20690.\r\n  can be specified on input\r\n  the actual number returned may be less in case of Arabic ligatures.\r\n  segments without overlapping.\r\n  language identifier\r\n  return non-bidi for all other languages\r\n  already set\r\n  languages, but only install the Thai keyboard).\r\n  $NON-NLS-1$\r\n  not supported for these platforms\r\n  don't switch the keyboard if it doesn't need to be\r\n  get the list of active languages\r\n  hebrew or arabic)\r\n  get the list of active languages\r\n  set to first bidi language\r\n /*\r\n\t * Public character class constants are the same as Windows \r\n\t * platform constants. \r\n\t * Saves conversion of class array in getRenderInfo to arbitrary \r\n\t * constants for now.\r\n\t */\r\n /* Free the memory that was allocated. */\r\n /* Free the memory that was allocated. */\r\n /*OS.WM_INPUTLANGCHANGE*/\r\n /*\r\n * Wraps Win32 API used to bidi enable the StyledText widget.\r\n */\r\n","GCData":" ","ST":" binding = SWT.ARROW_UP\r\n  binding = SWT.ARROW_DOWN\r\n  binding = SWT.HOME\r\n  binding = SWT.END\r\n  binding = SWT.ARROW_LEFT\r\n  binding = SWT.ARROW_RIGHT\r\n  binding = SWT.PAGE_UP\r\n  binding = SWT.PAGE_DOWN\r\n  binding = SWT.MOD1 + SWT.ARROW_LEFT\r\n  binding = SWT.MOD1 + SWT.ARROW_RIGHT\r\n  binding = SWT.MOD1 + SWT.HOME\r\n  binding = SWT.MOD1 + SWT.END\r\n  binding = SWT.MOD1 + SWT.PAGE_UP\r\n  binding = SWT.MOD1 + SWT.PAGE_DOWN\r\n  binding = SWT.MOD1 + 'A'\r\n  binding = SWT.MOD2 + SWT.ARROW_UP\r\n  binding = SWT.MOD2 + SWT.ARROW_DOWN\r\n  binding = SWT.MOD2 + SWT.HOME\r\n  binding = SWT.MOD2 + SWT.END\r\n  binding = SWT.MOD2 + SWT.ARROW_LEFT\r\n  binding = SWT.MOD2 + SWT.ARROW_RIGHT\r\n  binding = SWT.MOD2 + SWT.PAGE_UP\r\n  binding = SWT.MOD2 + SWT.PAGE_DOWN\r\n  binding = SWT.MOD1 + SWT.MOD2 + SWT.ARROW_LEFT\r\n  binding = SWT.MOD1 + SWT.MOD2 + SWT.ARROW_RIGHT\r\n  binding = SWT.MOD1 + SWT.MOD2 + SWT.HOME\r\n  binding = SWT.MOD1 + SWT.MOD2 + SWT.END\r\n  binding = SWT.MOD1 + SWT.MOD2 + SWT.PAGE_UP\r\n  binding = SWT.MOD1 + SWT.MOD2 + SWT.PAGE_DOWN\r\n  binding = SWT.MOD2 + SWT.DEL\r\n  binding = SWT.MOD1 + SWT.INSERT;\r\n  binding = SWT.MOD2 + SWT.INSERT ;\r\n  binding = SWT.BS;\r\n  binding = SWT.DEL;\r\n  binding = SWT.BS | SWT.MOD1;\r\n  binding = SWT.DEL | SWT.MOD1;\r\n  binding = SWT.INSERT;\r\n ","LEDataOutputStream":" ","LVCOLUMN":" ","TreeEditor":" To be consistent with older versions of SWT, grabVertical defaults to true\r\n  entire client area\r\n  default is CENTER\r\n  don't let the editor overlap with the +  default is CENTER\r\n  In this situation, there is a single default column.\r\n ","Composite":" }\r\n  widget could be disposed at this point\r\n /*\r\n\t* NOTE: The current implementation will count\r\n\t* non-registered children.\r\n\t*/\r\n /*\r\n\t\t* Call layout() directly so that subclasses that reimplement\r\n\t\t* this method instead of using a Layout will set the size and\r\n\t\t* location of their children when the font changes.\r\n\t\t*/\r\n /* Force clipping of children by setting WS_CLIPCHILDREN */\r\n /* Return zero to indicate that the background was not erased */\r\n /* Set focus for a canvas with no children */\r\n /*\r\n\t\t\t* Feature in Windows.  When the tool tip control is\r\n\t\t\t* created, the parent of the tool tip is the shell.\r\n\t\t\t* If SetParent () is used to reparent the tool bar\r\n\t\t\t* into a new shell, the tool tip is not reparented\r\n\t\t\t* and pops up underneath the new shell.  The fix is\r\n\t\t\t* to make sure the tool tip is a topmost window.\r\n\t\t\t*/\r\n /*\r\n\t\t\t\t* Bug in Windows 98 and NT.  Setting the tool tip to be the\r\n\t\t\t\t* top most window using HWND_TOPMOST can result in a parent\r\n\t\t\t\t* dialog shell being moved behind its parent if the dialog\r\n\t\t\t\t* has a sibling that is currently on top.  The fix is to\r\n\t\t\t\t* lock the z-order of the active window.\r\n\t\t\t\t* \r\n\t\t\t\t* Feature in Windows.  Using SetWindowPos() with HWND_NOTOPMOST\r\n\t\t\t\t* to clear the topmost state of a window whose parent is already\r\n\t\t\t\t* topmost clears the topmost state of the parent.  The fix is to\r\n\t\t\t\t* check if the parent is already on top and neither set or clear\r\n\t\t\t\t* the topmost status of the tool tip.\r\n\t\t\t\t*/\r\n /*\r\n\t\t\t* Bug in Windows 98.  For some reason, the tool bar control\r\n\t\t\t* sends both TTN_GETDISPINFOW and TTN_GETDISPINFOA to get\r\n\t\t\t* the tool tip text and the tab folder control sends only \r\n\t\t\t* TTN_GETDISPINFOW.  The fix is to handle only TTN_GETDISPINFOW,\r\n\t\t\t* even though it should never be sent on Windows 98.\r\n\t\t\t*\r\n\t\t\t* NOTE:  Because the size of NMTTDISPINFO differs between\r\n\t\t\t* Windows 98 and NT, guard against the case where the wrong\r\n\t\t\t* kind of message occurs by inlining the memory moves and\r\n\t\t\t* the UNICODE conversion code.\r\n\t\t\t*/\r\n /*\r\n\t\t\t\t\t* Ensure that the orientation of the tool tip matches\r\n\t\t\t\t\t* the orientation of the control.\r\n\t\t\t\t\t*/\r\n /* Set the clipping bits */\r\n /* Paint the control and the background */\r\n /* Get the damage */\r\n /* Create the paint GC */\r\n /* Send the paint event */\r\n /*\r\n\t\t\t\t\t* It is possible (but unlikely), that application\r\n\t\t\t\t\t* code could have disposed the widget in the paint\r\n\t\t\t\t\t* event.  If this happens, attempt to give back the\r\n\t\t\t\t\t* paint GC anyways because this is a scarce Windows\r\n\t\t\t\t\t* resource.\r\n\t\t\t\t\t*/\r\n /* Dispose the paint GC */\r\n /*\r\n\t\t\t* It is possible (but unlikely), that application\r\n\t\t\t* code could have disposed the widget in the paint\r\n\t\t\t* event.  If this happens, don't attempt to restore\r\n\t\t\t* the style.\r\n\t\t\t*/\r\n /* Restore the clipping bits */\r\n /* Begin deferred window positioning */\r\n /* Resize and Layout */\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have disposed the widget in the resize\r\n\t* event.  If this happens, end the processing of the\r\n\t* Windows message by returning the result of the\r\n\t* WM_SIZE message.\r\n\t*/\r\n /* End deferred window positioning */\r\n /* Damage the widget to cause a repaint */\r\n /* Resize the embedded window */\r\n /*\r\n\t* Check to see if the command is a system command or\r\n\t* a user menu item that was added to the system menu.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When a vertical or horizontal scroll bar is\r\n\t* hidden or shown while the opposite scroll bar is being scrolled\r\n\t* by the user (with WM_HSCROLL code SB_LINEDOWN), the scroll bar\r\n\t* does not redraw properly.  The fix is to detect this case and\r\n\t* redraw the non-client area.\r\n\t*/\r\n /* Return the result */\r\n","SWTEventListener":" ","MONITORINFO":" RECT rcMonitor;\r\n  RECT rcWork;\r\n ","MessageBox":" /* Compute the MessageBox style */\r\n /* Only MB_APPLMODAL is supported on WinCE */\r\n /*\r\n\t* Feature in Windows.  System modal is not supported\r\n\t* on Windows 95 and NT.  The fix is to convert system\r\n\t* modal to task modal.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  In order for MB_TASKMODAL to work,\r\n\t* the parent HWND of the MessageBox () call must be NULL.\r\n\t* If the parent is not NULL, MB_TASKMODAL behaves the\r\n\t* same as MB_APPLMODAL.  The fix to set the parent HWND\r\n\t* anyway and not rely on MB_MODAL to work by making the\r\n\t* parent be temporarily modal. \r\n\t*/\r\n /* Use the character encoding for the default locale */\r\n /* Clear the temporarily dialog modal parent */\r\n /* Compute and return the result */\r\n","RectF":" ","SWT":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n /*\r\n\t* This code prevents the creation of \"chains\" of SWTErrors and\r\n\t* SWTExceptions which in turn contain other SWTErrors and \r\n\t* SWTExceptions as their throwable. This can occur when low level\r\n\t* code throws an exception past a point where a higher layer is\r\n\t* being \"safe\" and catching all exceptions. (Note that, this is\r\n\t* _a_bad_thing_ which we always try to avoid.)\r\n\t*\r\n\t* On the theory that the low level code is closest to the\r\n\t* original problem, we simply re-throw the original exception here.\r\n\t*/\r\n /* Illegal Arguments (non-fatal) */\r\n /* SWT Exceptions (non-fatal) */\r\n /* Operation System Errors (fatal, may occur only on some platforms) */\r\n /* SWT Errors (fatal, may occur only on some platforms) */\r\n /* Unknown/Undefined Error */\r\n /*\r\n\t* These values represent bit masks that may need to\r\n\t* expand in the future.  Therefore they are not initialized\r\n\t* in the declaration to stop the compiler from inlining.\r\n\t*/\r\n /*\r\n\t* These values can be different on different platforms.\r\n\t* Therefore they are not initialized in the declaration\r\n\t* to stop the compiler from inlining.\r\n\t*/\r\n /* NOTE:\r\n *   Good javadoc coding style is to put the values of static final \r\n *   constants in the comments. This reinforces the fact that\r\n *   consumers are allowed to rely on the value (and they must\r\n *   since the values are compiled inline in their code). We\r\n *   can <em>not</em> change the values of these constants between\r\n *   releases.\r\n */\r\n","TYPEATTR":" GUID guid\r\n  TYPEDESC tdescAlias\r\n  IDLDESC idldesctype\r\n ","OleListener":" ","Event":" $NON-NLS-1$ ","JPEGSegment":" ","OpenWindowListener":" ","Display":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  case SWT.LF: inputs.wVk = (short) OS.VK_RETURN; break;\r\n  $NON-NLS-1$\r\n /* Windows and Events */\r\n /* Widget Table */\r\n /* Focus */\r\n /* Menus */\r\n /*\r\n\t* The start value for WM_COMMAND id's.\r\n\t* Windows reserves the values 0..100.\r\n\t* \r\n\t* The SmartPhone SWT resource file reserves\r\n\t* the values 101..107.\r\n\t*/\r\n /* Filter Hook */\r\n /* Idle Hook */\r\n /* Message Hook and Embedding */\r\n /* Sync/Async Widget Communication */\r\n /* Display Shutdown */\r\n /* System Tray */\r\n /* Timers */\r\n /* Keyboard and Mouse */\r\n /* MDI */\r\n /* Message Only Window */\r\n /* System Images Cache */\r\n /* System Cursors Cache */\r\n /* ImageList Cache */\r\n /* Custom Colors for ChooseColor */\r\n /* Display Data */\r\n /* Keyboard and Mouse Masks */\r\n /* Non-Numeric Keypad Keys */\r\n /* Virtual and Ascii Keys */\r\n /* Functions Keys */\r\n /* Numeric Keypad Keys */\r\n /* Other keys */\r\n /* Key Mappings */\r\n /* Multiple Displays */\r\n /* Multiple Monitors */\r\n /* Modality */\r\n /* Private SWT Window Messages */\r\n /* Workaround for Adobe Reader 7.0 */\r\n /*\r\n\t* TEMPORARY CODE.  Install the runnable that\r\n\t* gets the current display. This code will\r\n\t* be removed in the future.\r\n\t*/\r\n /*\r\n* TEMPORARY CODE.\r\n*/\r\n /* Get the current keyboard. */\r\n /* Translate the key to ASCII or UNICODE using the virtual keyboard */\r\n /*\r\n\t\t* Because GWL_USERDATA can be used by native widgets that\r\n\t\t* do not belong to SWT, it is possible that GWL_USERDATA\r\n\t\t* could return an index that is in the range of the table,\r\n\t\t* but was not put there by SWT.  Therefore, it is necessary\r\n\t\t* to check the handle of the control that is in the table\r\n\t\t* against the handle that provided the GWL_USERDATA.\r\n\t\t*/\r\n /* Use the character encoding for the default locale */\r\n /* Remember the current thread id */\r\n /* Use the character encoding for the default locale */\r\n /* Register the SWT window class */\r\n /* Register the SWT drop shadow window class */\r\n /* Initialize the system font */\r\n /* Create the message only HWND */\r\n /* Create the filter hook */\r\n /* Create the idle hook */\r\n /* Register the task bar created message */\r\n /* Initialize OLE */\r\n /* Initialize the Widget Table */\r\n /*\r\n\t* NOTE: X-Mouse is active when bit 1 of the UserPreferencesMask is set.\r\n  \t*/\r\n /*\r\n * Returns a single character, converted from the default\r\n * multi-byte character set (MBCS) used by the operating\r\n * system widgets to a wide character set (WCS) used by Java.\r\n *\r\n * @param ch the MBCS character\r\n * @return the WCS character\r\n */\r\n /*\r\n * Returns a single character, converted from the specified\r\n * multi-byte character set (MBCS) used by the operating\r\n * system widgets to a wide character set (WCS) used by Java.\r\n *\r\n * @param ch the MBCS character\r\n * @param codePage the code page used to convert the character\r\n * @return the WCS character\r\n */\r\n /*\r\n\t\t\t* Feature in Windows.  When multiple shells are\r\n\t\t\t* disabled and one of the shells has an enabled\r\n\t\t\t* dialog child and the user selects a disabled\r\n\t\t\t* shell that does not have the enabled dialog\r\n\t\t\t* child using the Task bar, Windows brings the\r\n\t\t\t* disabled shell to the front.  As soon as the\r\n\t\t\t* user clicks on the disabled shell, the enabled\r\n\t\t\t* dialog child comes to the front.  This behavior\r\n\t\t\t* is unspecified and seems strange.  Normally, a\r\n\t\t\t* disabled shell is frozen on the screen and the\r\n\t\t\t* user cannot change the z-order by clicking with\r\n\t\t\t* the mouse.  The fix is to look for WM_ACTIVATEAPP\r\n\t\t\t* and force the enabled dialog child to the front.\r\n\t\t\t* This is typically what the user is expecting.\r\n\t\t\t* \r\n\t\t\t* NOTE: If the modal shell is disabled for any\r\n\t\t\t* reason, it should not be brought to the front.\r\n\t\t\t*/\r\n /*\r\n\t\t\t\t* When the session is ending, no SWT program can continue\r\n\t\t\t\t* to run.  In order to avoid running code after the display\r\n\t\t\t\t* has been disposed, exit from Java.\r\n\t\t\t\t*/\r\n /*\r\n\t* Place the event at the end of the event queue.\r\n\t* This code is always called in the Display's\r\n\t* thread so it must be re-enterant but does not\r\n\t* need to be synchronized.\r\n\t*/\r\n /* Unhook the message hook */\r\n /* Unhook the filter hook */\r\n /* Unhook the idle hook */\r\n /* Destroy the message only HWND */\r\n /* Unregister the SWT window class */\r\n /* Unregister the SWT drop shadow window class */\r\n /* Release the system fonts */\r\n /* Release the System Images */\r\n /* Release the System Cursors */\r\n /* Release Custom Colors for ChooseColor */\r\n /* Uninitialize OLE */\r\n /* Release references */\r\n /* Take an event off the queue */\r\n /* Run the event */\r\n /*\r\n\t* Run deferred events.  This code is always\r\n\t* called in the Display's thread so it must\r\n\t* be re-enterant but need not be synchronized.\r\n\t*/\r\n /* Clear the queue */\r\n /* Remove the key/value pair */\r\n /* Add the key/value pair */\r\n /* Clear the virtual keyboard and press the shift key */\r\n /* Translate the key to ASCII or UNICODE using the virtual keyboard */\r\n /*\r\n\t* Feature in Windows.  When an application does not remove\r\n\t* events from the event queue for some time, Windows assumes\r\n\t* the application is not responding and no longer sends paint\r\n\t* events to the application.  The fix is to detect that the\r\n\t* application is not responding and call PeekMessage() with\r\n\t* PM_REMOVE to tell Windows that the application is ready\r\n\t* to dispatch events.  Note that the message does not have\r\n\t* to be found or dispatched in order to wake Windows up.\r\n\t* \r\n\t* NOTE: This allows other cross thread messages to be delivered,\r\n\t* most notably WM_ACTIVATE.\r\n\t*/\r\n /*\r\n * Returns a single character, converted from the wide\r\n * character set (WCS) used by Java to the specified\r\n * multi-byte character set used by the operating system\r\n * widgets.\r\n *\r\n * @param ch the WCS character\r\n * @param codePage the code page used to convert the character\r\n * @return the MBCS character\r\n */\r\n /*\r\n * Returns a single character, converted from the wide\r\n * character set (WCS) used by Java to the default\r\n * multi-byte character set used by the operating system\r\n * widgets.\r\n *\r\n * @param ch the WCS character\r\n * @return the MBCS character\r\n */\r\n /*\r\n\t* Bug in Adobe Reader 7.0.  For some reason, when Adobe\r\n\t* Reader 7.0 is deactivated from within Internet Explorer,\r\n\t* it sends thousands of consecutive WM_NCHITTEST messages\r\n\t* to the control that is under the cursor.  It seems that\r\n\t* if the control takes some time to respond to the message,\r\n\t* Adobe stops sending them.  The fix is to detect this case\r\n\t* and sleep.\r\n\t* \r\n\t* NOTE: Under normal circumstances, Windows will never send\r\n\t* consecutive WM_NCHITTEST messages to the same control without\r\n\t* another message (normally WM_SETCURSOR) in between.\r\n\t*/\r\n /* If the string is empty, return the string. */\r\n /*\r\n\t* Check for an LF or CR/LF and assume the rest of\r\n\t* the string is formated that way.  This will not\r\n\t* work if the string contains mixed delimiters.\r\n\t*/\r\n /*\r\n\t* The string is formatted with LF.  Compute the\r\n\t* number of lines and the size of the buffer\r\n\t* needed to hold the result\r\n\t*/\r\n /* Create a new string with the CR/LF line terminator. */\r\n","TextTransfer":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n /* Ensure byteCount is a multiple of 2 bytes */\r\n","ControlEditor":" do nothing - clientArea.x is the right answer\r\n  default is CENTER\r\n  do nothing - clientArea.y is the right answer\r\n  default is CENTER\r\n  before we get here\r\n  set all the values accordingly\r\n ","ControlAdapter":" ","STATSTG":" FILETIME mtime;\r\n  FILETIME ctime;\r\n  FILETIME atime;\r\n  GUID clsid;\r\n ","Label":" FALL THROUGH\r\n /*\r\n\t\t\t\t\t\t* Bug in Windows.  For some reason in Windows XP only, indexed palette\r\n\t\t\t\t\t\t* bitmaps are not drawn properly even though the screen depth can\r\n\t\t\t\t\t\t* handle all colors in the palette.  The fix is to use a higher depth\r\n\t\t\t\t\t\t* bitmap instead.\r\n\t\t\t\t\t\t*/\r\n /*\r\n\t* When STM_SETIMAGE encounters a bitmap with alpha information,\r\n\t* it makes a copy of the bitmap.  Therefore the bitmap that was\r\n\t* created to preserve transparency can be deleted right away.\r\n\t* \r\n\t* Note: The client code also needs to delete the copied image\r\n\t* created by Windows when the image changed but does not need\r\n\t* to delete the copied image when the control is disposed.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When STM_SETIMAGE is used to set the\r\n\t* image for a static control, Windows either streches the image\r\n\t* to fit the control or shrinks the control to fit the image.\r\n\t* While not stricly wrong, neither of these is desirable.\r\n\t* The fix is to stop Windows from stretching the image by\r\n\t* using SS_REALSIZEIMAGE and SS_CENTERIMAGE, allow Windows\r\n\t* to shrink the control, and then restore the control to the\r\n\t* original size.\r\n\t*/\r\n /*\r\n\t* NOTE: SS_BITMAP and SS_ICON are not single bit\r\n\t* masks so it is necessary to test for all of the\r\n\t* bits in these masks.\r\n\t*/\r\n /* \r\n\t* Feature in WinCE PPC.  Text labels have a trim\r\n\t* of one pixel wide on the right and left side.\r\n\t* The fix is to increase the size.\r\n\t*/\r\n /*\r\n* Not currently used.\r\n*/\r\n /* Windows deletes the copied image when the control is disposed */\r\n /*\r\n\t* Feature in Windows.  The windows label does not align\r\n\t* the bitmap or icon.  Any attempt to set alignment bits\r\n\t* such as SS_CENTER cause the label to display text.  The\r\n\t* fix is to disallow alignment.\r\n\t*\r\n\t* NOTE: SS_BITMAP and SS_ICON are not single bit\r\n\t* masks so it is necessary to test for all of the\r\n\t* bits in these masks.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  For some reason, SetWindowText() for\r\n\t* static controls redraws the control, even when the text has\r\n\t* has not changed.  The fix is to check for this case and do\r\n\t* nothing.\r\n\t*/\r\n /*\r\n\t\t* Bug in Windows.  When the style of a label is SS_BITMAP\r\n\t\t* or SS_ICON, the label does not remember the font that is\r\n\t\t* set in WM_SETFONT.  The fix is to remember the font and\r\n\t\t* return the font in WM_GETFONT and to reset the font when\r\n\t\t* the style is changed from SS_BITMAP or SS_ICON to a style\r\n\t\t* that displays text.\r\n\t\t*/\r\n /*\r\n* Not currently used.\r\n*/\r\n /*\r\n\t* Bug in Windows.  When a label has the SS_BITMAP\r\n\t* or SS_ICON style, the label does not draw the\r\n\t* background.  The fix is to draw the background\r\n\t* when the label is showing a bitmap or icon.\r\n\t*\r\n\t* NOTE: SS_BITMAP and SS_ICON are not single bit\r\n\t* masks so it is necessary to test for all of the\r\n\t* bits in these masks.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When the style of a label is SS_BITMAP\r\n\t* or SS_ICON, the label does not remember the font that is\r\n\t* set in WM_SETFONT.  The fix is to remember the font and\r\n\t* return the font in WM_GETFONT.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When the style of a label is SS_BITMAP\r\n\t* or SS_ICON, the label does not remember the font that is\r\n\t* set in WM_SETFONT.  The fix is to remember the font and\r\n\t* return the font in WM_GETFONT.\r\n\t*/\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have disposed the widget in the resize\r\n\t* event.  If this happens, end the processing of the\r\n\t* Windows message by returning the result of the\r\n\t* WM_SIZE message.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  For some reason, a label with\r\n\t* SS_BITMAP or SS_ICON and SS_CENTER does not redraw\r\n\t* properly when resized.  Only the new area is drawn\r\n\t* and the old area is not cleared.  The fix is to\r\n\t* force the redraw.\r\n\t*\r\n\t* NOTE: SS_BITMAP and SS_ICON are not single bit\r\n\t* masks so it is necessary to test for all of the\r\n\t* bits in these masks.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  For some reason, a label with\r\n\t* style SS_LEFT, SS_CENTER or SS_RIGHT does not\r\n\t* redraw the text in the new position when resized.\r\n\t* Note that SS_LEFTNOWORDWRAP does not have the\r\n\t* problem.  The fix is to force the redraw.\r\n\t*/\r\n","IPersistStorage":" ","OleEvent":" ","ShellEvent":" remove trailing '}'\r\n ","Combo":" FALL THROUGH\r\n  widget could be disposed at this point\r\n  case OS.WM_MOUSEWHEEL:\t\tresult = wmMouseWheel (hwnd, wParam, lParam); break;\r\n  FALL THROUGH\r\n  widget could be disposed at this point\r\n /*\r\n\t * These values can be different on different platforms.\r\n\t * Therefore they are not initialized in the declaration\r\n\t * to stop the compiler from inlining.\r\n\t */\r\n /*\r\n\t * These are the undocumented control id's for the children of\r\n\t * a combo box.  Since there are no constants for these values,\r\n\t * they may change with different versions of Windows (but have\r\n\t * been the same since Windows 3.0).\r\n\t */\r\n /*\r\n\t * Feature in Windows.  It is not possible to create\r\n\t * a combo box that has a border using Windows style\r\n\t * bits.  All combo boxes draw their own border and\r\n\t * do not use the standard Windows border styles.\r\n\t * Therefore, no matter what style bits are specified,\r\n\t * clear the BORDER bits so that the SWT style will\r\n\t * match the Windows widget.\r\n\t *\r\n\t * The Windows behavior is currently implemented on\r\n\t * all platforms.\r\n\t */\r\n /*\r\n\t * Even though it is legal to create this widget\r\n\t * with scroll bars, they serve no useful purpose\r\n\t * because they do not automatically scroll the\r\n\t * widget's client area.  The fix is to clear\r\n\t * the SWT style.\r\n\t */\r\n /* Get the text and list window procs */\r\n /*\r\n\t* Bug in Windows.  If the combo box has the CBS_SIMPLE style,\r\n\t* the list portion of the combo box is not drawn correctly the\r\n\t* first time, causing pixel corruption.  The fix is to ensure\r\n\t* that the combo box has been resized more than once.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  For some reason, CB_FINDSTRINGEXACT\r\n\t* will not find empty strings even though it is legal\r\n\t* to insert an empty string into a combo.  The fix is\r\n\t* to search the combo, an item at a time.\r\n\t*/\r\n /* Use CB_FINDSTRINGEXACT to search for the item */\r\n /*\r\n\t\t* It is possible (but unlikely), that application\r\n\t\t* code could have disposed the widget in the modify\r\n\t\t* event.  If this happens, just return.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  When the combo box is read only\r\n\t* with exactly one item that is currently selected\r\n\t* and that item is removed, the combo box does not\r\n\t* redraw to clear the text area.  The fix is to\r\n\t* force a redraw.\r\n\t*/\r\n /*\r\n\t\t* It is possible (but unlikely), that application\r\n\t\t* code could have disposed the widget in the modify\r\n\t\t* event.  If this happens, just return.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  When the combo box is read only\r\n\t* with exactly one item that is currently selected\r\n\t* and that item is removed, the combo box does not\r\n\t* redraw to clear the text area.  The fix is to\r\n\t* force a redraw.\r\n\t*/\r\n /*\r\n\t* Disable all magic keys that could modify the text\r\n\t* and don't send events when Alt, Shift or Ctrl is\r\n\t* pressed.\r\n\t*/\r\n /*\r\n\t* If the left button is down, the text widget refuses the character.\r\n\t*/\r\n /* Verify the character */\r\n /* Bs */\r\n /* Del */\r\n /* Return */\r\n /* Tab and other characters */\r\n /*\r\n\t\t* Feature in Windows.  When a drop down combo box is resized,\r\n\t\t* the combo box resizes the height of the text field and uses\r\n\t\t* the height provided in SetWindowPos () to determine the height\r\n\t\t* of the drop down list.  For some reason, the combo box redraws\r\n\t\t* the whole area, not just the text field.  The fix is to set the\r\n\t\t* SWP_NOSIZE bits when the height of text field and the drop down\r\n\t\t* list is the same as the requested height.\r\n\t\t* \r\n\t\t* NOTE:  Setting the width of a combo box to zero does not update\r\n\t\t* the width of the drop down control rect.  If the width of the\r\n\t\t* combo box is zero, then do not set SWP_NOSIZE.\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows.  If the combo box has the CBS_DROPDOWN\r\n\t* or CBS_DROPDOWNLIST style, Windows uses the height that the\r\n\t* programmer sets in SetWindowPos () to control height of the\r\n\t* drop down list.  When the width is non-zero, Windows remembers\r\n\t* this value and sets the height to be the height of the text\r\n\t* field part of the combo box.  If the width is zero, Windows\r\n\t* allows the height to have any value.  Therefore, when the\r\n\t* programmer sets and then queries the height, the values can\r\n\t* be different depending on the width.  The problem occurs when\r\n\t* the programmer uses computeSize () to determine the preferred\r\n\t* height (always the height of the text field) and then uses\r\n\t* this value to set the height of the combo box.  The result\r\n\t* is a combo box with a zero size drop down list.  The fix, is\r\n\t* to always set the height to show a fixed number of combo box\r\n\t* items and ignore the height value that the programmer supplies.\r\n\t*/\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have disposed the widget in the modify\r\n\t* event that might be sent when the index is removed.\r\n\t* If this happens, just exit.\r\n\t*/\r\n /*\r\n\t\t* Bug in Windows.  For some reason, the single line text field\r\n\t\t* portion of the combo box does not redraw to reflect the new\r\n\t\t* style bits.  The fix is to force the widget to be resized by\r\n\t\t* temporarily shrinking and then growing the width and height.\r\n\t\t*/\r\n /*\r\n\t* When the combo box is dropped down, allow return\r\n\t* to select an item in the list and escape to close\r\n\t* the combo box.\r\n\t*/\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have disposed the widget in the verify\r\n\t* event.  If this happens, answer null to cancel\r\n\t* the operation.\r\n\t*/\r\n /* Keyboard messages */\r\n /* Mouse Messages */\r\n /* Paint messages */\r\n /* Menu messages */\r\n /* Clipboard messages */\r\n /*\r\n\t* Bug in Windows.  When a combo box that is read only\r\n\t* is disposed in CBN_KILLFOCUS, Windows segment faults.\r\n\t* The fix is to send focus from WM_KILLFOCUS instead\r\n\t* of CBN_KILLFOCUS.\r\n\t* \r\n\t* NOTE: In version 6 of COMCTL32.DLL, the bug is fixed.\r\n\t*/\r\n /*\r\n\t* Return NULL - Focus notification is\r\n\t* done in WM_COMMAND by CBN_KILLFOCUS.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When an editable combo box is dropped\r\n\t* down and the text in the entry field partially matches an\r\n\t* item in the list, Windows selects the item but doesn't send\r\n\t* WM_COMMAND with CBN_SELCHANGE.  The fix is to detect that\r\n\t* the selection has changed and issue the notification.\r\n\t*/\r\n /*\r\n\t* Return NULL - Focus notification is\r\n\t* done by WM_COMMAND with CBN_SETFOCUS.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  If the combo box has the CBS_SIMPLE style,\r\n\t* the list portion of the combo box is not redrawn when the\r\n\t* combo box is resized.  The fix is to force a redraw when\r\n\t* the size has changed.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When an editable drop down combo box\r\n\t* contains text that does not correspond to an item in the\r\n\t* list, when the widget is resized, it selects the closest\r\n\t* match from the list.  The fix is to remember the original\r\n\t* text and reset it after the widget is resized.\r\n\t*/\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have disposed the widget in the resize\r\n\t* event.  If this happens, end the processing of the\r\n\t* Windows message by returning the result of the\r\n\t* WM_SIZE message.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  For some reason, when the\r\n\t* widget is a single line text widget, when the\r\n\t* user presses tab, return or escape, Windows beeps.\r\n\t* The fix is to look for these keys and not call\r\n\t* the window proc.\r\n\t* \r\n\t* NOTE: This only happens when the drop down list\r\n\t* is not visible.\r\n\t*/\r\n /*\r\n\t\t\t* Feature in Windows.  If the combo box list selection is\r\n\t\t\t* queried using CB_GETCURSEL before the WM_COMMAND (with\r\n\t\t\t* CBN_EDITCHANGE) returns, CB_GETCURSEL returns the previous\r\n\t\t\t* selection in the list.  It seems that the combo box sends\r\n\t\t\t* the WM_COMMAND before it makes the selection in the list box\r\n\t\t\t* match the entry field.  The fix is remember that no selection\r\n\t\t\t* in the list should exist in this case.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* Feature in Windows.  If the text in an editable combo box\r\n\t\t\t* is queried using GetWindowText () before the WM_COMMAND\r\n\t\t\t* (with CBN_SELCHANGE) returns, GetWindowText () returns is\r\n\t\t\t* the previous text in the combo box.  It seems that the combo\r\n\t\t\t* box sends the WM_COMMAND before it updates the text field to\r\n\t\t\t* match the list selection.  The fix is to force the text field\r\n\t\t\t* to match the list selection by re-selecting the list item.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* It is possible (but unlikely), that application\r\n\t\t\t* code could have disposed the widget in the modify\r\n\t\t\t* event.  If this happens, end the processing of the\r\n\t\t\t* Windows message by returning zero as the result of\r\n\t\t\t* the window proc.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* Bug in Windows.  When a combo box that is read only\r\n\t\t\t* is disposed in CBN_KILLFOCUS, Windows segment faults.\r\n\t\t\t* The fix is to send focus from WM_KILLFOCUS instead\r\n\t\t\t* of CBN_KILLFOCUS.\r\n\t\t\t* \r\n\t\t\t* NOTE: In version 6 of COMCTL32.DLL, the bug is fixed.\r\n\t\t\t*/\r\n /* Process a DBCS character */\r\n /*\r\n\t* Feature in Windows.  The Windows text widget uses\r\n\t* two 2 WM_CHAR's to process a DBCS key instead of\r\n\t* using WM_IME_CHAR.  The fix is to allow the text\r\n\t* widget to get the WM_CHAR's but ignore sending\r\n\t* them to the application.\r\n\t*/\r\n","SCRIPT_ANALYSIS":" ","NMLVDISPINFO":" LVITEM item;\r\n ","JPEGScanHeader":" /* Used when decoding. */\r\n /* Used when encoding. */\r\n","TreeEvent":" ","VisibilityWindowListener":" ","REBARBANDINFO":" /* Note in WinCE.  The field cxHeader is not defined. */\r\n","TreeListener":" ","TIFFModifiedHuffmanCodec":" /* 2 bits  */\r\n /* 3 bits  */\r\n /* 4 bits  */\r\n /* 5 bits  */\r\n /* 6 bits  */\r\n /* 7 bits  */\r\n /* 8 bits  */\r\n /* 9 bits  */\r\n /* 10 bits */\r\n /* EOL */\r\n /* 11 bits */\r\n /* 12 bits */\r\n /* 13 bits */\r\n /* 4 bits */\r\n /* 5 bits */\r\n /* 6 bits */\r\n /* 7 bits */\r\n /* 8 bits */\r\n /* 9 bits */\r\n /* 10 bits */\r\n /* 11 bits */\r\n /* EOL */\r\n /* 12 bits */\r\n /* nbr of bytes per row */\r\n /* byte aligned */\r\n /* Stop when reaching final EOL on last byte */\r\n /*\r\n* Decoder for \r\n* - CCITT Group 3 1-Dimensional Modified Huffman run length encoding\r\n*   (TIFF compression type 2)\r\n* - CCITT T.4 bi-level encoding 1D\r\n*   (TIFF compression type 3 option 1D) \r\n*/\r\n","FormData":" ","WNDCLASS":" ","Program":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$   $NON-NLS-1$  /* Use the character encoding for the default locale */\r\n /* Use the character encoding for the default locale */\r\n /* Use the character encoding for the default locale */\r\n /* Use the character encoding for the default locale */\r\n /* Name */\r\n /* Use the character encoding for the default locale */\r\n /* Use the character encoding for the default locale */\r\n /* Use the character encoding for the default locale */\r\n","VerifyListener":" ","BLENDFUNCTION":" ","Canvas":" if (all) flags |= OS.SW_SCROLLCHILDREN;\r\n /*\r\n* Not currently used.\r\n*/\r\n /*\r\n\t* Bug in Windows.  When a window with style WS_EX_LAYOUTRTL\r\n\t* that contains a caret is resized, Windows does not move the\r\n\t* caret in relation to the mirrored origin in the top right.\r\n\t* The fix is to hide the caret in WM_WINDOWPOSCHANGING and\r\n\t* show the caret in WM_WINDOWPOSCHANGED.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When a window with style WS_EX_LAYOUTRTL\r\n\t* that contains a caret is resized, Windows does not move the\r\n\t* caret in relation to the mirrored origin in the top right.\r\n\t* The fix is to hide the caret in WM_WINDOWPOSCHANGING and\r\n\t* show the caret in WM_WINDOWPOSCHANGED.\r\n\t*/\r\n","GUID":" ","OleFunctionDescription":" ","DNDListener":" ","TIFFDirectory":" /* Directory fields */\r\n /* Encoder fields */\r\n /* Different compression schemes */\r\n /* Noop when n == -128 */\r\n /* Copy next byte -n+1 times */\r\n /* Copy next n+1 bytes literally */\r\n /* Number of bytes copied */\r\n /* PackBits decoder */\r\n /* Each row is byte aligned */\r\n /* Read a strip */\r\n /* R, G, B entries are 16 bit wide (2 bytes) */\r\n /* \r\n\t* Calculate the nbr of required strips given the following requirements: \r\n\t* - each strip should, if possible, not be greater than maxStripByteSize\r\n\t* - each strip should contain 1 or more entire rows\r\n\t* \r\n\t* Format the strip fields arrays so that the image data is stored in one\r\n\t* contiguous block. This block is stored after the IFD and after any tag\r\n\t* info described in the IFD.\r\n\t*/\r\n /* Each strip contains 1 row */\r\n /* \r\n\t* Nbr of bytes between the end of the IFD directory and the start of\r\n\t* the image data. Keep space for at least the offsets and counts\r\n\t* data, each field being TYPE_LONG (4 bytes). If other tags require\r\n\t* space between the IFD and the image block, use the extraBytes\r\n\t* parameter.\r\n\t* If there is only one strip, the offsets and counts data is stored\r\n\t* directly in the IFD and we need not reserve space for it.\r\n\t*/\r\n /* \r\n\t\t* Store all strips sequentially to allow us\r\n\t\t* to copy all pixels in one contiguous area.\r\n\t\t*/\r\n /* The last strip may contain fewer rows */\r\n /* \r\n\t* In a TIFF ColorMap, all red come first, followed by\r\n\t* green and blue. All values must be converted from\r\n\t* 8 bit to 16 bit. \r\n\t*/\r\n /* Only the basic 1 and 3 values are supported */\r\n /* Ignored */\r\n /* Ignored */\r\n /* 2-dimensional coding is not supported */\r\n /* Ignored */\r\n /* Get the offset of the colorMap (use TYPE_LONG) */\r\n /* Set TIFF default values */\r\n /* Bilevel or Grayscale image */\r\n /* RGB image */\r\n /* SamplesPerPixel 3 is the only value supported */\r\n /* Palette Color image */\r\n /* Invalid type */\r\n /* Offset following the header and the directory */\r\n /* Extra space used by XResolution and YResolution values */\r\n /* The number of entries of the Color Map must match the bitsPerSample field */\r\n /* Extra space used by ColorMap values */\r\n /* Extra space used by BitsPerSample values */\r\n /* TIFF recommends storing the data in strips of no more than 8 Ko */\r\n /* TIFF header */\r\n /* Image File Directory */\r\n /* Offset of next IFD (0 for last IFD) */\r\n /* BitsPerSample 8,8,8 */\r\n /* XResolution and YResolution set to 300 dpi */\r\n /* ColorMap */\r\n /* Image Data */\r\n /* little endian */\r\n /* TIFF identifier */\r\n /* \r\n\t* Offset of the first IFD is chosen to be 8.\r\n\t* It is word aligned and immediately after this header.\r\n\t*/\r\n /* Scanline pad must be 1 */\r\n /* Palette must be black and white or white and black */\r\n /* 0 means a color index of 0 is imaged as white */\r\n","CloneableCompatibility":" ","GdiplusStartupInput":" ","TabItem":" /*\r\n\t* Bug in Windows.  In version 6.00 of COMCTL32.DLL, tab\r\n\t* items with an image and a label that includes '&' cause\r\n\t* the tab to draw incorrectly (even when doubled '&&').\r\n\t* The image overlaps the label.  The fix is to remove\r\n\t* all '&' characters from the string. \r\n\t*/\r\n /*\r\n\t* Bug in Windows.  In version 6.00 of COMCTL32.DLL, tab\r\n\t* items with an image and a label that includes '&' cause\r\n\t* the tab to draw incorrectly (even when doubled '&&').\r\n\t* The image overlaps the label.  The fix is to remove\r\n\t* all '&' characters from the string. \r\n\t*/\r\n","IUnknown":" ","PrintRenderer":" logical, unwrapped, content\r\n  wrapped content\r\n  printer client area\r\n  printer GC, there can be only one GC for each printer device\r\n  line background colors used during rendering\r\n  line styles colors used during rendering\r\n  bidi segments used during rendering on bidi platforms\r\n  wrapLines requires tab width to be known\r\n  line bidi segments\r\n ","Region":" ","ProgressAdapter":" ","CLabel":" $NON-NLS-1$   contains whatever tooltip is currently being displayed.\r\n  $NON-NLS-1$   checkWidget();\r\n  checkWidget();\r\n  checkWidget();\r\n  $NON-NLS-1$\r\n  shorten the text\r\n  determine horizontal position\r\n  draw a gradient behind the text\r\n  draw a background image behind the text\r\n  tile image to fill space\r\n  draw a background image behind the text\r\n  draw border\r\n  draw the image\r\n  draw the text\r\n  Are these settings the same as before?\r\n  Don't use gradients on low color displays\r\n  Are these settings the same as before?\r\n  Store the new settings\r\n  Refresh with the new settings\r\n  $NON-NLS-1$\r\n /*\r\n\t * The default background on carbon and some GTK themes is not a solid color \r\n\t * but a texture.  To show the correct default background, we must allow\r\n\t * the operating system to draw it and therefore, we can not use the \r\n\t * NO_BACKGROUND style.  The NO_BACKGROUND style is not required on platforms\r\n\t * that use double buffering which is true in both of these cases.\r\n\t */\r\n","SCRIPT_FONTPROPERTIES":" ","Slider":" the widget could be destroyed at this point\r\n /*\r\n\t* Feature in Windows.  Windows runs a modal message\r\n\t* loop when the user drags a scroll bar.  This means\r\n\t* that mouse down events won't get delivered until\r\n\t* after the loop finishes.  The fix is to run any\r\n\t* deferred messages, including mouse down messages\r\n\t* before calling the scroll bar window proc.\r\n\t*/\r\n /*\r\n\t* Set the intial values of the maximum\r\n\t* to 100 and the thumb to 10.  Note that\r\n\t* info.nPage needs to be 11 in order to\r\n\t* get a thumb that is 10.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  If the scroll bar is resized when it has focus,\r\n\t* the flashing cursor that is used to show that the scroll bar has\r\n\t* focus is not moved.  The fix is to post a fake WM_SETFOCUS to\r\n\t* get the scroll bar to recompute the size of the flashing cursor.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  Using SIF_DISABLENOSCROLL,\r\n\t* SetScrollInfo () can change enabled and disabled\r\n\t* state of the scroll bar causing a scroll bar that\r\n\t* was disabled by the application to become enabled.\r\n\t* The fix is to disable the scroll bar (again) when\r\n\t* the application has disabled the scroll bar.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  If the thumb is resized when it has focus,\r\n\t* the flashing cursor that is used to show that the scroll bar\r\n\t* has focus is not moved.  The fix is to post a fake WM_SETFOCUS\r\n\t* to get the scroll bar to recompute the size of the flashing\r\n\t* cursor.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  If a scroll bar control is given a border,\r\n\t* dragging the scroll bar thumb eats away parts of the border \r\n\t* while the thumb is dragged.  The fix is to clear border for\r\n\t* all scroll bars.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  If a scroll bar control is given a border,\r\n\t* dragging the scroll bar thumb eats away parts of the border \r\n\t* while the thumb is dragged.  The fix is to clear WS_BORDER.\r\n\t*/\r\n /*\r\n \t* Bug in Windows.  When a horizontal scroll bar is mirrored,\r\n \t* the native control does not correctly swap the arrow keys.\r\n \t* The fix is to swap them before calling the scroll bar window\r\n \t* proc.\r\n \t* \r\n \t* NOTE: This fix is not ideal.  It breaks when the bug is fixed\r\n \t* in the operating system.\r\n \t*/\r\n /*\r\n\t* Feature in Windows.  Windows uses the WS_TABSTOP\r\n\t* style for the scroll bar to decide that focus\r\n\t* should be set during WM_LBUTTONDBLCLK.  This is\r\n\t* not the desired behavior.  The fix is to clear\r\n\t* and restore WS_TABSTOP so that Windows will not\r\n\t* assign focus.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  Windows runs a modal message loop\r\n\t* when the user drags a scroll bar that terminates when\r\n\t* it sees an WM_LBUTTONUP.  Unfortunately the WM_LBUTTONUP\r\n\t* is consumed.  The fix is to send a fake mouse up and\r\n\t* release the automatic capture.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  Windows uses the WS_TABSTOP\r\n\t* style for the scroll bar to decide that focus\r\n\t* should be set during WM_LBUTTONDOWN.  This is\r\n\t* not the desired behavior.  The fix is to clear\r\n\t* and restore WS_TABSTOP so that Windows will not\r\n\t* assign focus.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  Windows runs a modal message loop\r\n\t* when the user drags a scroll bar that terminates when\r\n\t* it sees an WM_LBUTTONUP.  Unfortunately the WM_LBUTTONUP\r\n\t* is consumed.  The fix is to send a fake mouse up and\r\n\t* release the automatic capture.\r\n\t*/\r\n /* Do nothing when scrolling is ending */\r\n /* Move the thumb */\r\n /*\r\n\t* Feature in Windows.  Windows runs a modal message\r\n\t* loop when the user drags a scroll bar.  This means\r\n\t* that selection event must be sent because WM_HSCROLL\r\n\t* and WM_VSCROLL are sent from the modal message loop\r\n\t* so that they are delivered during inside the loop.\r\n\t*/\r\n","Gdip":" $NON-NLS-1$\r\n ","MenuListener":" ","TEXTMETRICA":" ","GUITHREADINFO":" RECT rcCaret;\r\n ","HDLAYOUT":" ","TypedListener":" /* Field set by Control */\r\n /* Fields set by Sash */\r\n /* Fields set by Decorations */\r\n /* Fields set by Text, RichText */\r\n /* Fields set by Control */\r\n","ImageLoaderEvent":" $NON-NLS-1$  ","Shell":" if ((style & SWT.ON_TOP) != 0) display.lockActiveWindow = true;\r\n  Display oldDisplay = display;\r\n /*\r\n\t\t* Bug in Windows.  When the WS_CAPTION bits are cleared using\r\n\t\t* SetWindowLong(), Windows does not resize the client area of\r\n\t\t* the window to get rid of the caption until the first resize.\r\n\t\t* The fix is to use SetWindowPos() with SWP_DRAWFRAME to force\r\n\t\t* the frame to be redrawn and resized.\r\n\t\t*/\r\n /*\r\n\t* Feature on WinCE PPC.  A new application becomes\r\n\t* the foreground application only if it has at least\r\n\t* one visible window before the event loop is started.\r\n\t* The workaround is to explicitely force the shell to\r\n\t* be the foreground window.\r\n\t*/\r\n /*\r\n\t* Bug in Windows XP.  Despite the fact that an icon has been\r\n\t* set for a window, the task bar displays the wrong icon the\r\n\t* first time the window is made visible with ShowWindow() after\r\n\t* a call to BringToTop(), when a long time elapses between the\r\n\t* ShowWindow() and the time the event queue is read.  The icon\r\n\t* in the window trimming is correct but the one in the task\r\n\t* bar does not get updated.  The fix is to call PeekMessage()\r\n\t* with the flag PM_NOREMOVE and PM_QS_SENDMESSAGE to respond\r\n\t* to a cross thread WM_GETICON.\r\n\t* \r\n\t* NOTE: This allows other cross thread messages to be delivered,\r\n\t* most notably WM_ACTIVATE.\r\n\t*/\r\n /*\r\n\t* Compute the list of controls to be activated and\r\n\t* deactivated by finding the first common parent\r\n\t* control.\r\n\t*/\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have destroyed some of the widgets. If\r\n\t* this happens, keep processing those widgets that\r\n\t* are not disposed.\r\n\t*/\r\n /*\r\n\t\t* Feature in Windows.  Despite the fact that the\r\n\t\t* tool tip text contains \\r\\n, the tooltip will\r\n\t\t* not honour the new line unless TTM_SETMAXTIPWIDTH\r\n\t\t* is set.  The fix is to set TTM_SETMAXTIPWIDTH to\r\n\t\t* a large value.\r\n\t\t*/\r\n /*\r\n\t* Ensure that the current position of the mouse\r\n\t* is inside the client area of the shell.  This\r\n\t* prevents tool tips from popping up over the\r\n\t* shell trimmings.\r\n\t*/\r\n /*\r\n\t* Ensure that the current position of the mouse\r\n\t* is inside the client area of the shell.  This\r\n\t* prevents tool tips from popping up over the\r\n\t* shell trimmings.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When ShowWindow() is called used to hide\r\n\t* a window, Windows attempts to give focus to the parent. If the\r\n\t* parent is disabled by EnableWindow(), focus is assigned to\r\n\t* another windows on the desktop.  This means that if you hide\r\n\t* a modal window before the parent is enabled, the parent will\r\n\t* not come to the front.  The fix is to change the modal state\r\n\t* before hiding or showing a window so that this does not occur.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  Calling ShowOwnedPopups() to hide the\r\n\t* child windows of a hidden window causes the application\r\n\t* to be deactivated.  The fix is to call ShowOwnedPopups()\r\n\t* to hide children before hiding the parent.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When a window that does not have a parent\r\n\t* is created, it is automatically added to the Windows Task Bar,\r\n\t* even when it has no title.  The fix is to use WS_EX_TOOLWINDOW\r\n\t* which does not cause the window to appear in the Task Bar.\r\n\t*/\r\n /*\r\n\t* Bug in Windows 98 and NT.  Creating a window with the\r\n\t* WS_EX_TOPMOST extended style can result in a dialog shell\r\n\t* being moved behind its parent.  The exact case where this\r\n\t* happens is a shell with two dialog shell children where\r\n\t* each dialog child has another hidden dialog child with\r\n\t* the WS_EX_TOPMOST extended style.  Clicking on either of\r\n\t* the visible dialogs causes them to become active but move\r\n\t* to the back, behind the parent shell.  The fix is to\r\n\t* disallow the WS_EX_TOPMOST extended style on Windows 98\r\n\t* and NT.\r\n\t*/\r\n /*\r\n\t* Feature in WinCE.  Calling CreateWindowEx () with WS_OVERLAPPED\r\n\t* and a parent window causes the new window to become a WS_CHILD of\r\n\t* the parent instead of a dialog child.  The fix is to use WS_POPUP\r\n\t* for a window with a parent.  \r\n\t* \r\n\t* Feature in WinCE PPC.  A window without a parent with WS_POPUP\r\n\t* always shows on top of the Pocket PC 'Today Screen'. The fix\r\n\t* is to not set WS_POPUP for a window without a parent on WinCE\r\n\t* devices.\r\n\t* \r\n\t* NOTE: WS_POPUP causes CreateWindowEx () to ignore CW_USEDEFAULT\r\n\t* and causes the default window location and size to be zero.\r\n\t*/\r\n /*\r\n\t* Use WS_OVERLAPPED for all windows, either dialog or top level\r\n\t* so that CreateWindowEx () will respect CW_USEDEFAULT and set\r\n\t* the default window location and size.\r\n\t* \r\n\t* NOTE:  When a WS_OVERLAPPED window is created, Windows gives\r\n\t* the new window WS_CAPTION style bits.  These two constants are\r\n\t* as follows:\r\n\t* \r\n\t* \tWS_OVERLAPPED = 0\r\n\t* \tWS_CAPTION = WS_BORDER | WS_DLGFRAME\r\n\t* \r\n\t*/\r\n /*\r\n\t\t* Note: this does not work when we get WM_ACTIVATE prior\r\n\t\t* to adding a listener.\r\n\t\t*/\r\n /* Restore SIP state when window is activated */\r\n /*\r\n\t* Bug in Windows XP.  When a Shell is deactivated, the\r\n\t* IME composition window does not go away. This causes\r\n\t* repaint issues.  The fix is to close the IME to cause\r\n\t* the composition string to be committed.\r\n\t* \r\n\t* Note. The IME needs to be reopened in order to preserve\r\n\t* the input method status.\r\n\t*/\r\n /*\r\n\t\t* Note in WinCE PPC:  Close the Shell when the \"Done Button\" has\r\n\t\t* been pressed. lParam is either 0 (PocketPC 2002) or the handle\r\n\t\t* to the Shell (PocketPC).\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows.  On PPC, the menu is not actually an HMENU.\r\n\t* By observation, it is a tool bar that is configured to look like\r\n\t* a menu.  Therefore, when the PPC menu sends WM_COMMAND messages,\r\n\t* lParam is not zero because the WM_COMMAND was not sent from a menu.\r\n\t* Sub menu item events originate from the menu bar.  Top menu items\r\n\t* events originate from a tool bar.  The fix is to detect the source\r\n\t* of the WM_COMMAND and set lParam to zero to pretend that the message\r\n\t* came from a real Windows menu, not a tool bar.\r\n\t*/\r\n /*\r\n\t* When the shell is a WS_CHILD window of a non-SWT\r\n\t* window, the destroy code does not get called because\r\n\t* the non-SWT window does not call dispose ().  Instead,\r\n\t* the destroy code is called here in WM_DESTROY.\r\n\t*/\r\n /*\r\n\t* Check for WM_MOUSEACTIVATE when an MDI shell is active\r\n\t* and stop the normal shell activation but allow the mouse\r\n\t* down to be delivered.\r\n\t*/\r\n /*\r\n\t* Get the current location of the cursor,\r\n\t* not the location of the cursor when the\r\n\t* WM_MOUSEACTIVATE was generated.  This is\r\n\t* strictly incorrect but is necessary in\r\n\t* order to support Activate and Deactivate\r\n\t* events for embedded widgets that have\r\n\t* their own event loop.  In that case, the\r\n\t* cursor location reported by GetMessagePos\r\n\t* is the one for our event loop, not the\r\n\t* embedded widget's event loop.\r\n\t*/\r\n /*\r\n\t* When a shell is created with SWT.ON_TOP and SWT.NO_FOCUS,\r\n\t* do not activate the shell when the user clicks on the\r\n\t* the client area or on the border or a control within the\r\n\t* shell that does not take focus.\r\n\t*/\r\n /*\r\n\t* When the normal activation was interruped in WM_MOUSEACTIVATE\r\n\t* because the active shell was an MDI shell, set the active window\r\n\t* to the top level shell but lock the active window and stop focus\r\n\t* changes.  This allows the user to interact the top level shell\r\n\t* in the normal manner.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the shell is disabled\r\n\t* by a Windows standard dialog (like a MessageBox\r\n\t* or FileDialog), clicking in the shell does not\r\n\t* bring the shell or the dialog to the front. The\r\n\t* fix is to detect this case and bring the shell\r\n\t* forward.\r\n\t*/\r\n /*\r\n\t* When the shell that contains a cursor is disabled,\r\n\t* WM_SETCURSOR is called with HTERROR.  Normally,\r\n\t* when a control is disabled, the parent will get\r\n\t* mouse and cursor events.  In the case of a disabled\r\n\t* shell, there is no enabled parent.  In order to\r\n\t* show the cursor when a shell is disabled, it is\r\n\t* necessary to override WM_SETCURSOR when called\r\n\t* with HTERROR to set the cursor but only when the\r\n\t* mouse is in the client area of the shell.\r\n\t*/\r\n /* \r\n\t\t\t* The SIP is in a new state.  Cache its new value.\r\n\t\t\t* Resize the Shell if it has the style SWT.RESIZE.\r\n\t\t\t* Note that SHHandleWMSettingChange resizes the\r\n\t\t\t* Shell and also updates the cached state.\r\n\t\t\t*/\r\n /*\r\n\t* Bug in Windows.  If the shell is hidden while the parent\r\n\t* is iconic,  Windows shows the shell when the parent is\r\n\t* deiconified.  This does not happen if the shell is hidden\r\n\t* while the parent is not an icon.  The fix is to track\r\n\t* visible state for the shell and refuse to show the shell\r\n\t* when the parent is shown.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the last visible window in\r\n\t* a process minimized, Windows swaps out the memory for\r\n\t* the process.  The assumption is that the user can no\r\n\t* longer interact with the window, so the memory can be\r\n\t* released to other applications.  However, for programs\r\n\t* that use a lot of memory, swapping the memory back in\r\n\t* can take a long time, sometimes minutes.  The fix is\r\n\t* to intercept WM_SYSCOMMAND looking for SC_MINIMIZE\r\n\t* and use ShowWindow() with SW_SHOWMINIMIZED to minimize\r\n\t* the window, rather than running the default window proc.\r\n\t* \r\n\t* NOTE:  The default window proc activates the next\r\n\t* top-level window in the Z-order while ShowWindow()\r\n\t* with SW_SHOWMINIMIZED does not.  There is no fix for\r\n\t* this at this time.\r\n\t*/\r\n","Control":" if (OS.GetFocus () != OS.SetFocus (handle)) return false;\r\n  }\r\n  widget could be disposed at this point\r\n  }\r\n  checkWidget ();\r\n  }\r\n  widget could be disposed at this point\r\n  widget could be disposed at this point\r\n  FALL THROUGH\r\n /* Ensure byteCount is a multiple of 2 bytes on UNICODE platforms */\r\n /* Use the character encoding for the default locale */\r\n /*\r\n\t* If a non-SWT child of the control has focus,\r\n\t* then this control is considered to have focus\r\n\t* even though it does not have focus in Windows.\r\n\t*/\r\n /*\r\n\t* This is not complete.  Need to check if the\r\n\t* widget is obscurred by a parent or sibling.\r\n\t*/\r\n /*\r\n\t\t* Bug in Windows.  For some reason, when GetWindow ()\r\n\t\t* with GW_HWNDPREV is used to query the previous window\r\n\t\t* in the z-order with the first child, Windows returns\r\n\t\t* the first child instead of NULL.  The fix is to detect\r\n\t\t* this case and move the control to the top.\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows.  During the processing of WM_KILLFOCUS,\r\n\t* when the focus window is queried using GetFocus(), it has\r\n\t* already been assigned to the new window.  The fix is to\r\n\t* remember the control that is losing or gaining focus and\r\n\t* answer it during WM_KILLFOCUS.  If a WM_SETFOCUS occurs\r\n\t* during WM_KILLFOCUS, the focus control needs to be updated\r\n\t* to the current control.  At any other time, the focus\r\n\t* control matches Windows.\r\n\t*/\r\n /*\r\n\t* It is possible that the shell may be\r\n\t* disposed at this point.  If this happens\r\n\t* don't send the activate and deactivate\r\n\t* events.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  If the receiver has focus, disabling\r\n\t* the receiver causes no window to have focus.  The fix is\r\n\t* to assign focus to the first ancestor window that takes\r\n\t* focus.  If no window will take focus, set focus to the\r\n\t* desktop.\r\n\t*/\r\n /*\r\n\t* Feature in WinCE.  The SWP_DRAWFRAME flag for SetWindowPos()\r\n\t* causes a WM_SIZE message to be sent even when the SWP_NOSIZE\r\n\t* flag is specified.  The fix is to set SWP_DRAWFRAME only when\r\n\t* not running on WinCE.\r\n\t*/\r\n /*\r\n\t * Feature in Windows.  When WM_SETREDRAW is used to turn\r\n\t * off drawing in a widget, it clears the WS_VISIBLE bits\r\n\t * and then sets them when redraw is turned back on.  This\r\n\t * means that WM_SETREDRAW will make a widget unexpectedly\r\n\t * visible.  The fix is to track the visibility state while\r\n\t * drawing is turned off and restore it when drawing is\r\n\t * turned back on.\r\n\t */\r\n /*\r\n\t* Feature in Windows.  If the receiver has focus, hiding\r\n\t* the receiver causes no window to have focus.  The fix is\r\n\t* to assign focus to the first ancestor window that takes\r\n\t* focus.  If no window will take focus, set focus to the\r\n\t* desktop.\r\n\t*/\r\n /* Shell Sort from K&R, pg 108 */\r\n /*\r\n\t\t\t\t* Use DLGC_HASSETSEL to determine that the control\r\n\t\t\t\t* is a text widget.  A text widget normally wants\r\n\t\t\t\t* all keys except VK_ESCAPE.  If this bit is not\r\n\t\t\t\t* set, then assume the control wants all keys,\r\n\t\t\t\t* including VK_ESCAPE.\r\n\t\t\t\t*/\r\n /*\r\n\t\t\t\t* Use DLGC_HASSETSEL to determine that the control is a\r\n\t\t\t\t* text widget.  If the control is a text widget, then\r\n\t\t\t\t* Ctrl+Tab and Shift+Tab should traverse out of the widget.\r\n\t\t\t\t* If the control is not a text widget, the correct behavior\r\n\t\t\t\t* is to give every character, including Tab, Ctrl+Tab and\r\n\t\t\t\t* Shift+Tab to the control.\r\n\t\t\t\t*/\r\n /*\r\n\t\t\t* On WinCE SP there is no tab key.  Focus is assigned\r\n\t\t\t* using the VK_UP and VK_DOWN keys, not with VK_LEFT\r\n\t\t\t* or VK_RIGHT.\r\n\t\t\t*/\r\n /*\r\n\t\t\t\t* Use DLGC_HASSETSEL to determine that the control is a\r\n\t\t\t\t* text widget.  If the control is a text widget, then\r\n\t\t\t\t* Ctrl+PgUp and Ctrl+PgDn should traverse out of the widget.\r\n\t\t\t\t*/\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have disposed the widget in the traverse\r\n\t* event.  If this happens, return true to stop further\r\n\t* event processing.\r\n\t*/\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have disposed the widget in focus in\r\n\t* or out events.  Ensure that a disposed widget is\r\n\t* not accessed.\r\n\t*/\r\n /*\r\n\t* It is possible (but unlikely), that application\r\n\t* code could have disposed the widget in focus in\r\n\t* or out events.  Ensure that a disposed widget is\r\n\t* not accessed.\r\n\t*/\r\n /* \r\n\t* If the font that the control is using is the\r\n\t* same one that was being used from the Control\r\n\t* Panel, then use the new Control Panel font.\r\n\t*/\r\n /*\r\n\t* Feature in Windows NT.  When CreateWindowEx() is called with\r\n\t* WS_EX_LAYOUTRTL or WS_EX_NOINHERITLAYOUT, CreateWindowEx()\r\n\t* fails to create the HWND. The fix is to not use these bits.\r\n\t*/\r\n /* Force clipping of siblings by setting WS_CLIPSIBLINGS */\r\n /*\r\n\t* When the WM_COMMAND message is sent from a\r\n\t* menu, the HWND parameter in LPARAM is zero.\r\n\t*/\r\n /* Ignore WM_INITMENUPOPUP for an accelerator */\r\n /*\r\n\t* If the high order word of LPARAM is non-zero,\r\n\t* the menu is the system menu and we can ignore\r\n\t* WPARAM.  Otherwise, use WPARAM to find the menu.\r\n\t*/\r\n /*\r\n\t\t\t* It is possible (but unlikely), that application\r\n\t\t\t* code could have disposed the widget in the hide\r\n\t\t\t* event.  If this happens, stop searching up the\r\n\t\t\t* ancestor list because there is no longer a link\r\n\t\t\t* to follow.\r\n\t\t\t*/\r\n /*\r\n\t* The shell and the new menu may be disposed because of\r\n\t* sending the hide event to the ancestor menus but setting\r\n\t* a field to null in a disposed shell is not harmful.\r\n\t*/\r\n /* Send the show event */\r\n /*\r\n\t* Feature in Windows.  When the user types Alt+<key>\r\n\t* and <key> does not match a mnemonic in the System\r\n\t* menu or the menu bar, Windows beeps.  This beep is\r\n\t* unexpected and unwanted by applications that look\r\n\t* for Alt+<key>.  The fix is to detect the case and\r\n\t* stop Windows from beeping by closing the menu.\r\n\t*/\r\n /*\r\n\t\t\t* When the user cancels any menu that is not the\r\n\t\t\t* menu bar, assume a mnemonic key was pressed to open\r\n\t\t\t* the menu from WM_SYSCHAR.  When the menu was invoked\r\n\t\t\t* using the mouse, this assumption is wrong but not\r\n\t\t\t* harmful.  This variable is only used in WM_SYSCHAR\r\n\t\t\t* and WM_SYSCHAR is only sent after the user has pressed\r\n\t\t\t* a mnemonic.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* It is possible (but unlikely), that application\r\n\t\t\t* code could have disposed the widget in the hide\r\n\t\t\t* event.  If this happens, stop searching up the\r\n\t\t\t* parent list because there is no longer a link\r\n\t\t\t* to follow.\r\n\t\t\t*/\r\n /*\r\n\t\t* The shell may be disposed because of sending the hide\r\n\t\t* event to the last active menu menu but setting a field\r\n\t\t* to null in a destroyed widget is not harmful.\r\n\t\t*/\r\n /*\r\n\t\t\t\t\t\t* It is possible (but unlikely), that application\r\n\t\t\t\t\t\t* code could have disposed the widget in the hide\r\n\t\t\t\t\t\t* event or the item about to be armed.  If this\r\n\t\t\t\t\t\t* happens, stop searching up the ancestor list\r\n\t\t\t\t\t\t* because there is no longer a link to follow.\r\n\t\t\t\t\t\t*/\r\n /*\r\n\t\t\t\t\t* The shell and/or the item could be disposed when\r\n\t\t\t\t\t* processing hide events from above.  If this happens,\r\n\t\t\t\t\t* ensure that the shell is not accessed and that no\r\n\t\t\t\t\t* arm event is sent to the item.\r\n\t\t\t\t\t*/\r\n /*\r\n\t* Check to see if the command is a system command or\r\n\t* a user menu item that was added to the System menu.\r\n\t* When a user item is added to the System menu,\r\n\t* WM_SYSCOMMAND must always return zero.\r\n\t*/\r\n /* Process the System Command */\r\n /*\r\n\t\t\t\t* When lParam is not zero, Alt+<key> was pressed.  If the\r\n\t\t\t\t* application is interested in keystrokes and there is a\r\n\t\t\t\t* menu bar, check to see whether the key that was pressed\r\n\t\t\t\t* matches a mnemonic on the menu bar.  Normally, Windows\r\n\t\t\t\t* matches the first character of a menu item as well as\r\n\t\t\t\t* matching the mnemonic character.  To allow the application\r\n\t\t\t\t* to see the keystrokes in this case, avoid running the default\r\n\t\t\t\t* window proc.\r\n\t\t\t\t* \r\n\t\t\t\t* NOTE: When the user types Alt+Space, the System menu is\r\n\t\t\t\t* activated.  In this case the application should not see\r\n\t\t\t\t* the keystroke.\r\n\t\t\t\t*/\r\n /*\r\n\t\t\t* When lParam is zero, one of F10, Shift+F10, Ctrl+F10 or\r\n\t\t\t* Ctrl+Shift+F10 was pressed.  If there is no menu bar and\r\n\t\t\t* the focus control is interested in keystrokes, give the\r\n\t\t\t* key to the focus control.  Normally, F10 with no menu bar\r\n\t\t\t* moves focus to the System menu but this can be achieved\r\n\t\t\t* using Alt+Space.  To allow the application to see F10,\r\n\t\t\t* avoid running the default window proc.\r\n\t\t\t* \r\n\t\t\t* NOTE:  When F10 is pressed, WM_SYSCOMMAND is sent to the\r\n\t\t\t* shell, not the focus control.  This is undocumented Windows\r\n\t\t\t* behavior.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* Do not allow keyboard traversal of the menu bar\r\n\t\t\t* or scrolling when the shell is not enabled.\r\n\t\t\t*/\r\n /* Save the focus widget when the shell is minimized */\r\n /*\r\n\t* Bug in Windows.  When WM_SETREDRAW is used to turn off drawing\r\n\t* for a control and the control is moved or resized, Windows does\r\n\t* not redraw the area where the control once was in the parent.\r\n\t* The fix is to detect this case and redraw the area.\r\n\t*/\r\n","LocationListener":" ","NMTOOLBAR":" TBBUTTON tbButton;\r\n  RECT rcButton;\r\n /* Note in WinCE.  The field rcButton is not defined. */\r\n","TEXTMETRICW":" ","PngIhdrChunk":" been read.\r\n ","SWTError":" $NON-NLS-1$   $NON-NLS-1$\r\n ","NMLISTVIEW":" POINT ptAction;\r\n ","PngDecodingDataStream":" ","MenuItem":" /*\r\n\t\t\t* Bug in Windows.  For some reason, VkKeyScan\r\n\t\t\t* fails to map ESC to VK_ESCAPE and DEL to\r\n\t\t\t* VK_DELETE.  The fix is to map these keys\r\n\t\t\t* as a special case.\r\n\t\t\t*/\r\n /*public*/\r\n /* Check to make sure the new menu is valid */\r\n /* Assign the new menu */\r\n /*\r\n\t\t* Feature in Windows.  When SetMenuItemInfo () is used to\r\n\t\t* set a submenu and the menu item already has a submenu,\r\n\t\t* Windows destroys the previous menu.  This is undocumented\r\n\t\t* and unexpected but not necessarily wrong.  The fix is to\r\n\t\t* remove the item with RemoveMenu () which does not destroy\r\n\t\t* the submenu and then insert the item with InsertMenuItem ().\r\n\t\t*/\r\n /*\r\n\t\t* Bug in Windows.  When GetMenuItemInfo() is used to get the text,\r\n\t\t* for an item that has a bitmap set using MIIM_BITMAP, the text is\r\n\t\t* not returned.  This means that when SetMenuItemInfo() is used to\r\n\t\t* set the submenu and the current menu state, the text is lost.\r\n\t\t* The fix is to temporarily remove the bitmap and restore it after\r\n\t\t* the text and submenu have been set.\r\n\t\t*/\r\n /*\r\n\t\t\t* Restore the bitmap that was removed to work around a problem\r\n\t\t\t* in GetMenuItemInfo() and menu items that have bitmaps set with\r\n\t\t\t* MIIM_BITMAP.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* On WinCE, InsertMenuItem() is not available.  The fix is to\r\n\t\t\t* use SetMenuItemInfo() but this call does not set the menu item\r\n\t\t\t* state and submenu.  The fix is to use InsertMenu() to insert\r\n\t\t\t* the item, SetMenuItemInfo() to set the string and EnableMenuItem()\r\n\t\t\t* and CheckMenuItem() to set the state.\r\n\t\t\t*/\r\n /* Assign the new menu in the OS */\r\n /*\r\n\t\t* Bug in Windows 2000.  For some reason, when MIIM_TYPE is set\r\n\t\t* on a menu item that also has MIIM_BITMAP, the MIIM_TYPE clears\r\n\t\t* the MIIM_BITMAP style.  The fix is to reset both MIIM_BITMAP.\r\n\t\t* Note, this does not happen on Windows 98.\r\n\t\t*/\r\n /* Use the character encoding for the default locale */\r\n /*\r\n\t\t* Restore the bitmap that was removed to work around a problem\r\n\t\t* in GetMenuItemInfo() and menu items that have bitmaps set with\r\n\t\t* MIIM_BITMAP.\r\n\t\t*/\r\n /*\r\n\t\t* Bug in WinCE PPC.  Tool items on the menubar don't resize\r\n\t\t* correctly when the character '&' is used (even when it\r\n\t\t* is a sequence '&&').  The fix is to remove all '&' from\r\n\t\t* the string. \r\n\t\t*/\r\n /* Use the character encoding for the default locale */\r\n /*\r\n\t\t* Bug in Windows.  When a bitmap is included in the\r\n\t\t* menu bar, the HDC seems to already include the left\r\n\t\t* coordinate.  The fix is to ignore this value when\r\n\t\t* the item is in a menu bar.\r\n\t\t*/\r\n /*\r\n\t\t* Bug in Windows.  If a menu contains items that have\r\n\t\t* images and can be checked, Windows does not include\r\n\t\t* the width of the image and the width of the check when\r\n\t\t* computing the width of the menu.  When the longest item\r\n\t\t* does not have an image, the label and the accelerator\r\n\t\t* text can overlap.  The fix is to use SetMenuItemInfo()\r\n\t\t* to indicate that all items have a bitmap and then include\r\n\t\t* the width of the widest bitmap in WM_MEASURECHILD.\r\n\t\t*/\r\n /*\r\n\t\t* Feature in Windows.  On Windows 98, it is necessary\r\n\t\t* to add 4 pixels to the width of the image or the image\r\n\t\t* and text are too close.  On other Windows platforms,\r\n\t\t* this causes the text of the longest item to touch the\r\n\t\t* accelerator text.  The fix is to add only 2 pixels in\r\n\t\t* this case.\r\n\t\t*/\r\n","SashFormData":" $NON-NLS-2$\r\n ","TextLayout":" $NON-NLS-1$\r\n /*Script cache and analysis */\r\n /*Shape info (malloc when the run is shaped) */\r\n /*Place info (malloc when the run is placed) */\r\n /* ScriptBreak */\r\n /* ReleaseFont() */\r\n /*\r\n\t\t* Feature in Windows. The fallback font returned by the MLang service\r\n\t\t* can be disposed by some other client running in the same thread.\r\n\t\t* For example, disposing a Browser widget internally releases all fonts\r\n\t\t* in the MLang cache. The fix is to use GetObject() to detect if the \r\n\t\t* font was disposed and reshape the run.\r\n\t\t*/\r\n /*\r\n\t\t\t\t*  Bug in Windows. For some reason Uniscribe sets the fSoftBreak flag for the first letter\r\n\t\t\t\t*  after a letter with an accent. This cause a break line to be set in the middle of a word.\r\n\t\t\t\t*  The fix is to detect the case and ignore fSoftBreak forcing the algorithm keep searching.\r\n\t\t\t\t*/\r\n /* Update the run metrics if the last run is a hard break. */\r\n /* \r\n*  Compute the runs: itemize, shape, place, and reorder the runs.\r\n* \tBreak paragraphs into lines, wraps the text, and initialize caches.\r\n*/\r\n /* Release() */\r\n /*\r\n *  Itemize the receiver text\r\n */\r\n /* \r\n *  Merge styles ranges and script items \r\n */\r\n /*\r\n\t* Feature in Windows.  If the orientation is RTL Uniscribe will\r\n\t* resolve the level of line breaks to 1, this can cause the line \r\n\t* break to be reorder to the middle of the line. The fix is to set\r\n\t* the level to zero to prevent it to be reordered.\r\n\t*/\r\n /* \r\n *  Reorder the run \r\n */\r\n /* GetStrCodePages() */\r\n /* ReleaseFont() */\r\n /* MapFont() */\r\n /* \r\n * Generate glyphs for one Run.\r\n */\r\n","INITCOMMONCONTROLSEX":" ","GridData":" ","LineBackgroundListener":" ","PngHuffmanTable":" indexesByLength[n] : Index into the values array. First value with a code of length n + 1.\r\n  Sort the values. Primary key is code size. Secondary key is value.\r\n  and the length of the code is lengths[N].\r\n  a prefix to the longer codeValues.\r\n  This code is the (offset + 1)'th code of (codelength + 1);\r\n  so now we can look up the value for the Huffman code in the table.\r\n ","MENUBARINFO":" RECT  rcBar;\r\n ","VARDESC":" TYPEDESC elemdescVar.tdesc\r\n  PARAMDESC elemdescFunc.paramdesc\r\n ","LineStyleListener":" ","StyledTextContent":" ","Platform":" ","IOleInPlaceObject":" ","VerifyKeyListener":" ","OSVERSIONINFOA":" ","TableItem":" $NON-NLS-1$\r\n /*public*/\r\n /*\r\n\t\t* Feature in Windows.  Calling LVM_GETSUBITEMRECT with LVIR_LABEL\r\n\t\t* and zero for the column number gives the bounds of the first item\r\n\t\t* without including the bounds of the icon.  This is undocumented.\r\n\t\t* When called with values greater than zero, the icon bounds are\r\n\t\t* included and this behavior is documented.\r\n\t\t*/\r\n /*\r\n\t\t\t\t\t* Feature in Windows.  LVM_GETSUBITEMRECT returns an image width\r\n\t\t\t\t\t* even when the subitem does not contain an image.  The fix is to\r\n\t\t\t\t\t* adjust the rectangle to represent the area the table is drawing.\r\n\t\t\t\t\t*/\r\n /*\r\n\t* Bug in Windows.  In version 5.80 of COMCTL32.DLL, the top\r\n\t* of the rectangle returned by LVM_GETSUBITEMRECT is off by\r\n\t* the grid width when the grid is visible.  The fix is to\r\n\t* move the top of the rectangle up by the grid width.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  Despite the fact that every item in the\r\n\t* table always has LPSTR_TEXTCALLBACK, Windows caches the\r\n\t* bounds for the selected items.  This means that \r\n\t* when you change the string to be something else, Windows\r\n\t* correctly asks you for the new string but when the item\r\n\t* is selected, the selection draws using the bounds of the\r\n\t* previous item.  The fix is to reset LPSTR_TEXTCALLBACK\r\n\t* even though it has not changed, causing Windows to flush\r\n\t* cached bounds.\r\n\t*/\r\n /*\r\n\t\t* Bug in Windows.  Despite the fact that every item in the\r\n\t\t* table always has LPSTR_TEXTCALLBACK, Windows caches the\r\n\t\t* bounds for the selected items.  This means that \r\n\t\t* when you change the string to be something else, Windows\r\n\t\t* correctly asks you for the new string but when the item\r\n\t\t* is selected, the selection draws using the bounds of the\r\n\t\t* previous item.  The fix is to reset LPSTR_TEXTCALLBACK\r\n\t\t* even though it has not changed, causing Windows to flush\r\n\t\t* cached bounds.\r\n\t\t*/\r\n /* Ensure that the image list is created */\r\n /*\r\n\t\t* Bug in Windows.  Despite the fact that every item in the\r\n\t\t* table always has LPSTR_TEXTCALLBACK, Windows caches the\r\n\t\t* bounds for the selected items.  This means that \r\n\t\t* when you change the string to be something else, Windows\r\n\t\t* correctly asks you for the new string but when the item\r\n\t\t* is selected, the selection draws using the bounds of the\r\n\t\t* previous item.  The fix is to reset LPSTR_TEXTCALLBACK\r\n\t\t* even though it has not changed, causing Windows to flush\r\n\t\t* cached bounds.\r\n\t\t*/\r\n","Rectangle":" $NON-NLS-1$ ","StatusTextListener":" ","CAUUID":" ","Scrollable":" widget may be disposed at this point\r\n /*\r\n\t* Bug on WinCE.  lParam should be NULL when the message is not sent\r\n\t* by a scroll bar control, but it contains the handle to the window.\r\n\t* When the message is sent by a scroll bar control, it correctly\r\n\t* contains the handle to the scroll bar.  The fix is to check for\r\n\t* both.\r\n\t*/\r\n /*\r\n\t* Translate WM_MOUSEWHEEL to WM_VSCROLL or WM_HSCROLL.\r\n\t*/\r\n /*\r\n\t* When the native widget scrolls inside WM_MOUSEWHEEL, it\r\n\t* may or may not send a WM_VSCROLL or WM_HSCROLL to do the\r\n\t* actual scrolling.  This depends on the implementation of\r\n\t* each native widget.  In order to ensure that application\r\n\t* code is notified when the scroll bar moves, compare the\r\n\t* scroll bar position before and after the WM_MOUSEWHEEL.\r\n\t* If the native control sends a WM_VSCROLL or WM_HSCROLL,\r\n\t* then the application has already been notified.  If not\r\n\t* explicity send the event.\r\n\t*/\r\n /*\r\n\t* Bug on WinCE.  lParam should be NULL when the message is not sent\r\n\t* by a scroll bar control, but it contains the handle to the window.\r\n\t* When the message is sent by a scroll bar control, it correctly\r\n\t* contains the handle to the scroll bar.  The fix is to check for\r\n\t* both.\r\n\t*/\r\n /* \r\n\t\t\t\t* Note: On WinCE, the value in SB_THUMBPOSITION is relative to nMin.\r\n\t\t\t\t* Same for SB_THUMBPOSITION 'except' for the very first thumb track\r\n\t\t\t\t* message which has the actual value of nMin. This is a problem when\r\n\t\t\t\t* nMin is not zero.\r\n\t\t\t\t*/\r\n","FileFormat":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$  Destructively bit invert data in the given byte array.\r\n /* We do not currently support writing multi-image files,\r\n\t * so we use the first image data in the loader's array. */\r\n","IPersistStreamInit":" ","AccessibleTextAdapter":" ","ArmListener":" ","Item":" ","DROPFILES":" Offset of the file list from the beginning of this structure, in bytes.\r\n  POINT pt;   Nonclient area flag. If this member is TRUE, pt specifies the screen\r\n  Value that indicates whether the file contains ANSI or Unicode\r\n  contains Unicode characters.\r\n ","AccessibleTextListener":" ","SashFormLayout":" determine control sizes\r\n  get the ratios\r\n  keep just the right number of sashes\r\n  get the ratios\r\n ","ExtendedModifyEvent":" ","TableDragUnderEffect":" milli seconds\r\n  Some effects are mutually exclusive.  Make sure that only one of the mutually exclusive effects has been specified.\r\n  }\r\n ","Synchronizer":" /*\r\n\t * Only remember the syncThread for syncExec.\r\n\t */\r\n","CBanner":" y[t] = y0+3(y1-y0)t+3(y0+y2-2y1)t^2+(y3-y0+3y1-3y2)t^3\r\n  }\r\n  draw solid tail\r\n  Anti- aliasing\r\n  draw tail fading to background\r\n  draw border\r\n ","FileTransfer":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  each name is null terminated\r\n  there is an extra null terminator at the very end\r\n  The caller of this method must release the data when it is done with it.\r\n  get file names from IDataObject\r\n  How many files are there?\r\n  How long is the name ?\r\n  Get file name and append it to string\r\n  frees data associated with HDROP data\r\n ","HTMLTransfer":" $NON-NLS-1$\r\n  HTML Format is stored as a null terminated byte array\r\n ","OS2BMPFileFormat":" Round up to 4 byte multiple\r\n  Seek to the specified offset\r\n  BMP pads scanlines to multiples of 4 bytes\r\n  Start at last line\r\n  Fill in file header, except for bfsize, which is done later.\r\n  Signature\r\n  File size - filled in later\r\n  Reserved 1\r\n  Reserved 2\r\n  Offset to data\r\n  the stream and fill in the details later.\r\n  Calculate file size\r\n  Write the headers\r\n  Unload palette\r\n  Unload the data\r\n ","TableColumn":" /*\r\n\t\t* Bug in Windows.  When LVM_SETCOLUMNWIDTH is used with LVSCW_AUTOSIZE\r\n\t\t* where each item has I_IMAGECALLBACK but there are no images in the\r\n\t\t* table, the size computed by LVM_SETCOLUMNWIDTH is too small for the\r\n\t\t* first column, causing long items to be clipped with '...'.  The fix\r\n\t\t* is to increase the column width by a small amount.\r\n\t\t*/\r\n /*\r\n\t\t* Bug in Windows.  When LVM_SETCOLUMNWIDTH is used with LVSCW_AUTOSIZE\r\n\t\t* for a table with a state image list, the column is width does not\r\n\t\t* include space for the state icon.  The fix is to increase the column\r\n\t\t* width by the width of the image list.\r\n\t\t*/\r\n /*\r\n\t\t\t* Feature in Windows.  When LVSCW_AUTOSIZE_USEHEADER is used\r\n\t\t\t* with LVM_SETCOLUMNWIDTH to resize the last column, the last\r\n\t\t\t* column is expanded to fill the client area.  The fix is to\r\n\t\t\t* resize the table to be small, set the column width and then\r\n\t\t\t* restore the table to its original size.\r\n\t\t\t*/\r\n /*\r\n\t* Bug in Windows.  For some reason, when the title\r\n\t* of a column is changed after the column has been\r\n\t* created, the alignment must also be reset or the\r\n\t* text does not draw.  The fix is to query and then\r\n\t* set the alignment.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When a column header contains a\r\n\t* mnemonic character, Windows does not measure the\r\n\t* text properly.  This causes '...' to always appear\r\n\t* at the end of the text.  The fix is to remove\r\n\t* mnemonic characters and replace doubled mnemonics\r\n\t* with spaces.\r\n\t*/\r\n","TrayItem":" widget could be disposed at this point\r\n /* Icons need black pixels where the mask is transparent */\r\n /*\r\n\t* Feature in Windows.  When the user clicks on the tray\r\n\t* icon, another application may be the foreground window.\r\n\t* This means that the event loop is not running and can\r\n\t* cause problems.  For example, if a menu is shown, when\r\n\t* the user clicks outside of the menu to cancel it, the\r\n\t* menu is not hidden until an event is processed.  If\r\n\t* another application is the foreground window, then the\r\n\t* menu is not hidden.  The fix is to force the tray icon\r\n\t* message window to the foreground when sending an event.\r\n\t*/\r\n /*\r\n\t* Note that the size of the szTip field is different\r\n\t* in version 5.0 of shell32.dll.\r\n\t*/\r\n /*\r\n\t\t* It is possible (but unlikely), that application\r\n\t\t* code could have disposed the widget in the show\r\n\t\t* event.  If this happens, just return.\r\n\t\t*/\r\n","BITMAPINFOHEADER":" ","FocusListener":" ","Browser":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  dispatchDocument.Release();\r\n  dispatch.Release();\r\n  $NON-NLS-1$\r\n  may be -1\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$    $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$   $NON-NLS-1$   $NON-NLS-1$\r\n  $NON-NLS-1$   $NON-NLS-1$\r\n /* External Listener management */\r\n /* final document complete */\r\n /*\r\n\t\t\t\t\t\t * Note.  The completion of the page loading is detected as\r\n\t\t\t\t\t\t * described in the MSDN article \"Determine when a page is\r\n\t\t\t\t\t\t * done loading in WebBrowser Control\". \r\n\t\t\t\t\t\t */\r\n /*\r\n\t\t\t\t\t\t\t\t* Note. Internet Explorer appears to treat the data loaded with \r\n\t\t\t\t\t\t\t\t* nsIPersistStreamInit.Load as if it were encoded using the default\r\n\t\t\t\t\t\t\t\t* local charset.  There does not seem to be an API to set the\r\n\t\t\t\t\t\t\t\t* desired charset explicitely in this case.  The fix is to\r\n\t\t\t\t\t\t\t\t* prepend the UTF-8 Byte Order Mark signature to the data.\r\n\t\t\t\t\t\t\t\t*/\r\n /* \r\n\t\t\t\t\t\t\t\t\t* Note.  CreateStreamOnHGlobal is called with the flag fDeleteOnRelease.\r\n\t\t\t\t\t\t\t\t\t* If the call succeeds the buffer hGlobal is freed automatically\r\n\t\t\t\t\t\t\t\t\t* when the IStream object is released. If the call fails, free the buffer\r\n\t\t\t\t\t\t\t\t\t* hGlobal.\r\n\t\t\t\t\t\t\t\t\t*/\r\n /*\r\n\t\t\t\t\t* Feature in Internet Explorer.  OnToolBar FALSE is emitted \r\n\t\t\t\t\t* when both tool bar, address bar and menu bar must not be visible.\r\n\t\t\t\t\t* OnToolBar TRUE is emitted when either of tool bar, address bar\r\n\t\t\t\t\t* or menu bar is visible.\r\n\t\t\t\t\t*/\r\n /*\r\n\t\t\t* Dispose all arguments passed in the OleEvent.  This must be\r\n\t\t\t* done to properly release any IDispatch reference that was\r\n\t\t\t* automatically addRef'ed when constructing the OleEvent.  \r\n\t\t\t*/\r\n /*\r\n\t* If the html field is non-null then the about:blank page is already being\r\n\t* loaded, so no Stop or Navigate is required.  Just set the html that is to\r\n\t* be shown.\r\n\t*/\r\n /*\r\n\t* Navigate to the blank page and insert the given html when\r\n\t* receiving the next DocumentComplete notification.  See the\r\n\t* MSDN article \"Loading HTML content from a Stream\".\r\n\t* \r\n\t* Note.  Stop any pending request.  This is required to avoid displaying a\r\n\t* blank page as a result of consecutive calls to setUrl and/or setText.  \r\n\t* The previous request would otherwise render the new html content and\r\n\t* reset the html field before the browser actually navigates to the blank\r\n\t* page as requested below.\r\n\t* \r\n\t* Feature in Internet Explorer.  Stopping pending requests when no request\r\n\t* is pending causes a default page 'Action cancelled' to be displayed.  The\r\n\t* workaround is to not invoke 'stop' when no request has been set since\r\n\t* that instance was created.\r\n\t*/\r\n /*\r\n\t\t* Feature in Internet Explorer.  Stopping pending requests when no request has been\r\n\t\t* issued causes a default 'Action cancelled' page to be displayed.  Since Stop must\r\n\t\t* be issued here, the workaround is to first Navigate to the about:blank page before\r\n\t\t* issuing Stop so that the 'Action cancelled' page is not displayed.\r\n\t\t*/\r\n /*\r\n\t* Bug in Internet Explorer.  For some reason, Navigating to an xml document before\r\n\t* a previous Navigate has completed will leave the Browser in a bad state if the\r\n\t* Navigate to the xml document does not complete.  This bad state causes a GP when\r\n\t* the parent window is eventually disposed.  The workaround is to issue a Stop before\r\n\t* navigating to any xml document. \r\n\t*/\r\n","NMLINK":" LITEM item;\r\n ","PNGFileFormat":" Read and process chunks until the IEND chunk is encountered.\r\n  go through all the image's IDAT chunks.\r\n  then this is an invalid image.\r\n  All critical chunks must be supported.\r\n  137\r\n  P\r\n  N\r\n  G\r\n  <RETURN>\r\n  <LINEFEED>\r\n  <CTRL  <LINEFEED>\r\n  byte compressedValue = (byte)(value * multiplier);\r\n  double multiplier = (Compatibility.pow2(8) - 1)   byte compressedValue = (byte)(value * multiplier);\r\n /*\r\n\t\t\t* If the image uses 16-bit depth, it is converted\r\n\t\t\t* to an 8-bit depth image.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* If the image uses 16-bit depth, it is converted\r\n\t\t\t* to an 8-bit depth image.\r\n\t\t\t*/\r\n","TableCursor":" By default, invert the list selection colors\r\n  $NON-NLS-1$\r\n  Temporary code - need a better way to determine table trim\r\n  $NON-NLS-1$\r\n ","NMLVCUSTOMDRAW":" ","AccessibleAdapter":" ","TextChangedEvent":" ","PaletteData":" /* The RGB did not exist in the palette */\r\n","LRESULT":" ","FontMetrics":" handle.tmBreakChar == metric.tmBreakChar &&\r\n  handle.tmFirstChar ^ handle.tmLastChar ^ handle.tmDefaultChar ^ handle.tmBreakChar ^\r\n ","RowLayout":" ","StackLayout":" ","NMTTDISPINFOW":" ","MenuEvent":" ","MSG":" POINT pt;\r\n ","Pattern":" TODO - how about alpha?\r\n ","NMTTDISPINFOA":" ","Table":" case OS.WM_MOUSEWHEEL:\r\n  widget could be disposed at this point\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  checkWidget ();\r\n  $NON-NLS-1$\r\n  if ((style & SWT.FLAT) != 0) bits |= OS.LVS_NOSORTHEADER;\r\n  return LRESULT.ONE;\r\n  if (drawCount != 0 || !OS.IsWindowVisible (handle)) break;\r\n  $NON-NLS-1$\r\n /*\r\n\t\t* Bug in Windows.  For some reason, when the user clicks\r\n\t\t* on this control, the Windows hook WH_MSGFILTER is sent\r\n\t\t* despite the fact that an input event from a dialog box,\r\n\t\t* message box, menu, or scroll bar did not seem to occur.\r\n\t\t* The fix is to ignore the hook.\r\n\t\t*/\r\n /*\r\n\t\t* Feature in Windows.  Windows sends LVN_ITEMACTIVATE from WM_KEYDOWN\r\n\t\t* instead of WM_CHAR.  This means that application code that expects\r\n\t\t* to consume the key press and therefore avoid a SWT.DefaultSelection\r\n\t\t* event will fail.  The fix is to ignore LVN_ITEMACTIVATE when it is\r\n\t\t* caused by WM_KEYDOWN and send SWT.DefaultSelection from WM_CHAR.\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows.  It is not possible to create\r\n\t* a table that does not have scroll bars.  Therefore,\r\n\t* no matter what style bits are specified, set the\r\n\t* H_SCROLL and V_SCROLL bits so that the SWT style\r\n\t* will match the widget that Windows creates.\r\n\t*/\r\n /*\r\n\t\t* Bug in Windows.  Despite the fact that every item in the\r\n\t\t* table always has LPSTR_TEXTCALLBACK, Windows caches the\r\n\t\t* bounds for the selected items.  This means that \r\n\t\t* when you change the string to be something else, Windows\r\n\t\t* correctly asks you for the new string but when the item\r\n\t\t* is selected, the selection draws using the bounds of the\r\n\t\t* previous item.  The fix is to reset LPSTR_TEXTCALLBACK\r\n\t\t* even though it has not changed, causing Windows to flush\r\n\t\t* cached bounds.\r\n\t\t*/\r\n /*\r\n\t\t\t\t* Bug in Windows.  Despite the fact that every item in the\r\n\t\t\t\t* table always has LPSTR_TEXTCALLBACK, Windows caches the\r\n\t\t\t\t* bounds for the selected items.  This means that \r\n\t\t\t\t* when you change the string to be something else, Windows\r\n\t\t\t\t* correctly asks you for the new string but when the item\r\n\t\t\t\t* is selected, the selection draws using the bounds of the\r\n\t\t\t\t* previous item.  The fix is to reset LPSTR_TEXTCALLBACK\r\n\t\t\t\t* even though it has not changed, causing Windows to flush\r\n\t\t\t\t* cached bounds.\r\n\t\t\t\t*/\r\n /*\r\n\t\t\t* Bug in Windows.  Despite the fact that every item in the\r\n\t\t\t* table always has LPSTR_TEXTCALLBACK, Windows caches the\r\n\t\t\t* bounds for the selected items.  This means that \r\n\t\t\t* when you change the string to be something else, Windows\r\n\t\t\t* correctly asks you for the new string but when the item\r\n\t\t\t* is selected, the selection draws using the bounds of the\r\n\t\t\t* previous item.  The fix is to reset LPSTR_TEXTCALLBACK\r\n\t\t\t* even though it has not changed, causing Windows to flush\r\n\t\t\t* cached bounds.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* Bug in Windows.  Despite the fact that every item in the\r\n\t\t\t* table always has LPSTR_TEXTCALLBACK, Windows caches the\r\n\t\t\t* bounds for the selected items.  This means that \r\n\t\t\t* when you change the string to be something else, Windows\r\n\t\t\t* correctly asks you for the new string but when the item\r\n\t\t\t* is selected, the selection draws using the bounds of the\r\n\t\t\t* previous item.  The fix is to reset LPSTR_TEXTCALLBACK\r\n\t\t\t* even though it has not changed, causing Windows to flush\r\n\t\t\t* cached bounds.\r\n\t\t\t*/\r\n /*\r\n\t* Feature in Windows.  The height returned by LVM_APPROXIMATEVIEWRECT\r\n\t* includes the trim plus the height of the items plus one extra row.\r\n\t* The fix is to subtract the height of one row from the result height.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  In version 5.8 of COMCTL32.DLL,\r\n\t* if the font is changed for an item, the bounds for the\r\n\t* item are not updated, causing the text to be clipped.\r\n\t* The fix is to detect the version of COMCTL32.DLL, and\r\n\t* if it is one of the versions with the problem, then\r\n\t* use version 5.00 of the control (a version that does\r\n\t* not have the problem).  This is the recomended work\r\n\t* around from the MSDN.\r\n\t*/\r\n /* Set the checkbox image list */\r\n /*\r\n\t* Feature in Windows.  When the control is created,\r\n\t* it does not use the default system font.  A new HFONT\r\n\t* is created and destroyed when the control is destroyed.\r\n\t* This means that a program that queries the font from\r\n\t* this control, uses the font in another control and then\r\n\t* destroys this control will have the font unexpectedly\r\n\t* destroyed in the other control.  The fix is to assign\r\n\t* the font ourselves each time the control is created.\r\n\t* The control will not destroy a font that it did not\r\n\t* create.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When the first column is inserted\r\n\t* without setting the header text, Windows will never\r\n\t* allow the header text for the first column to be set.\r\n\t* The fix is to set the text to an empty string when\r\n\t* the column is inserted.\r\n\t*/\r\n /* Set the extended style bits */\r\n /*\r\n\t* Feature in Windows.  Windows does not explicitly set the orientation of\r\n\t* the header.  Instead, the orientation is inherited when WS_EX_LAYOUTRTL\r\n\t* is specified for the table.  This means that when both WS_EX_LAYOUTRTL\r\n\t* and WS_EX_NOINHERITLAYOUT are specified for the table, the header will\r\n\t* not be oriented correctly.  The fix is to explicitly set the orientation\r\n\t* for the header.\r\n\t* \r\n\t* NOTE: WS_EX_LAYOUTRTL is not supported on Windows NT.\r\n\t*/\r\n /*\r\n\t* Insert the column into the columns array before inserting\r\n\t* it into the widget so that the column will be present when\r\n\t* any callbacks are issued as a result of LVM_INSERTCOLUMN\r\n\t* or LVM_SETCOLUMN.\r\n\t*/\r\n /*\r\n\t* Ensure that resize listeners for the table and for columns\r\n\t* within the table are not called.  This can happen when the\r\n\t* first column is inserted into a table or when a new column\r\n\t* is inserted in the first position. \r\n\t*/\r\n /*\r\n\t\t* Grow the array faster when redraw is off or the\r\n\t\t* table is not visible.  When the table is painted,\r\n\t\t* the items array is resized to be smaller to reduce\r\n\t\t* memory usage.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  Despite the fact that the image list\r\n\t* index has never been set for the item, Windows always\r\n\t* assumes that the image index for the item is valid.\r\n\t* When an item is inserted, the image index is zero.\r\n\t* Therefore, when the first image is inserted and is\r\n\t* assigned image index zero, every item draws with this\r\n\t* image.  The fix is to set the image index when the\r\n\t* the item is created.\r\n\t*/\r\n /* Insert the item */\r\n /*\r\n\t* Force virtual tables to use custom draw.  This\r\n\t* is necessary to support colors and fonts for table\r\n\t* items.  When the application is queried for data,\r\n\t* setting the custom draw flag at that time is too\r\n\t* late.  The current item is not redrawn in order\r\n\t* to avoid recursion and NM_CUSTOMDRAW has already\r\n\t* been avoided because at the time of the message,\r\n\t* there were no items that required custom drawing.\r\n\t*/\r\n /*\r\n\t\t* An index of -1 will apply the change to all\r\n\t\t* items.  Ensure that indices are greater than -1.\r\n\t\t*/\r\n /*\r\n\t* An index of -1 will apply the change to all\r\n\t* items.  Ensure that index is greater than -1.\r\n\t*/\r\n /*\r\n\t\t* An index of -1 will apply the change to all\r\n\t\t* items.  Ensure that indices are greater than -1.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  When the state image list is larger than the\r\n\t* image list, Windows incorrectly positions the state images.  When\r\n\t* the table is scrolled, Windows draws garbage.  The fix is to force\r\n\t* the state image list to be the same size as the image list.\r\n\t*/\r\n /*\r\n* Not currently used.\r\n*/\r\n /*\r\n\t* The Windows table control uses CLR_DEFAULT to indicate\r\n\t* that it is using the default foreground color.  This\r\n\t* is undocumented.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  Under rare circumstances, LVM_GETTOPINDEX\r\n\t* can return a negative number.  When this happens, the table\r\n\t* is displaying blank lines at the top of the controls.  The\r\n\t* fix is to check for a negative number and return zero instead.\r\n\t*/\r\n /*\r\n\t\t* Bug in Windows.  Making any change to an item that\r\n\t\t* changes the item height of a table while the table\r\n\t\t* is scrolled can cause the lines to draw incorrectly.\r\n\t\t* This happens even when the lines are not currently\r\n\t\t* visible and are shown afterwards.  The fix is to\r\n\t\t* save the top index, scroll to the top of the table\r\n\t\t* and then restore the original top index.\r\n\t\t*/\r\n /* Turn off redraw and leave it off */\r\n /*\r\n\t* Feature in Windows 98.  When there are a large number\r\n\t* of columns and items in a table (>1000) where each\r\n\t* of the subitems in the table has a string, it is much\r\n\t* faster to delete each item with LVM_DELETEITEM rather\r\n\t* than using LVM_DELETEALLITEMS.  The fix is to detect\r\n\t* this case and delete the items, one by one.  The fact\r\n\t* that the fix is only necessary on Windows 98 was\r\n\t* confirmed using version 5.81 of COMCTL32.DLL on both\r\n\t* Windows 98 and NT.\r\n\t*\r\n\t* NOTE: LVM_DELETEALLITEMS is also sent by the table\r\n\t* when the table is destroyed.\r\n\t*/\r\n /*\r\n\t* Feature in Windows 98.  When there are a large number\r\n\t* of columns and items in a table (>1000) where each\r\n\t* of the subitems in the table has a string, it is much\r\n\t* faster to delete each item with LVM_DELETEITEM rather\r\n\t* than using LVM_DELETEALLITEMS.  The fix is to detect\r\n\t* this case and delete the items, one by one.  The fact\r\n\t* that the fix is only necessary on Windows 98 was\r\n\t* confirmed using version 5.81 of COMCTL32.DLL on both\r\n\t* Windows 98 and NT.\r\n\t*\r\n\t* NOTE: LVM_DELETEALLITEMS is also sent by the table\r\n\t* when the table is destroyed.\r\n\t*/\r\n /*\r\n\t\t* An index of -1 will apply the change to all\r\n\t \t* items.  Ensure that indices are greater than -1.\r\n\t \t*/\r\n /*\r\n\t* An index of -1 will apply the change to all\r\n\t* items.  Ensure that index is greater than -1.\r\n\t*/\r\n /*\r\n\t\t* An index of -1 will apply the change to all\r\n\t\t* items.  Indices must be greater than -1.\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows.  Inside WM_LBUTTONDOWN and WM_RBUTTONDOWN,\r\n\t* the widget starts a modal loop to determine if the user wants\r\n\t* to begin a drag/drop operation or marque select.  Unfortunately,\r\n\t* this modal loop eats the corresponding mouse up.  The fix is to\r\n\t* detect the cases when the modal loop has eaten the mouse up and\r\n\t* issue a fake mouse up.\r\n\t*\r\n\t* By observation, when the mouse is clicked anywhere but the check\r\n\t* box, the widget eats the mouse up.  When the mouse is dragged,\r\n\t* the widget does not eat the mouse up.\r\n\t*/\r\n /*\r\n\t* Force the table to have focus so that when the user\r\n\t* reselects the focus item, the LVIS_FOCUSED state bits\r\n\t* for the item will be set.  If the user did not click on\r\n\t* an item, then set focus to the table so that it will\r\n\t* come to the front and take focus in the work around\r\n\t* below.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the user selects outside of\r\n\t* a table item, Windows deselects all the items, even\r\n\t* when the table is multi-select.  While not strictly\r\n\t* wrong, this is unexpected.  The fix is to detect the\r\n\t* case and avoid calling the window proc.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When a table item is reselected\r\n\t* in a single-select table, Windows does not issue a\r\n\t* WM_NOTIFY because the item state has not changed.\r\n\t* This is strictly correct but is inconsistent with the\r\n\t* list widget and other widgets in Windows.  The fix is\r\n\t* to detect the case when an item is mark it as selected.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the background color is\r\n\t* changed, the table does not redraw until the next\r\n\t* WM_PAINT.  The fix is to force a redraw.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  If the table column widths are adjusted\r\n\t* in WM_SIZE or WM_POSITIONCHANGED using LVM_SETCOLUMNWIDTH\r\n\t* blank lines may be inserted at the top of the table.  A\r\n\t* call to LVM_GETTOPINDEX will return a negative number (this\r\n\t* is an impossible result).  Once the blank lines appear,\r\n\t* there seems to be no way to get rid of them, other than\r\n\t* destroying and recreating the table.  By observation, the\r\n\t* problem happens when the height of the table is less than\r\n\t* the two times the height of a line (this was tested using\r\n\t* different fonts and images).  It also seems that the bug\r\n\t* does not occur when the redraw is turned off for the table.\r\n\t* The fix is to turn off drawing when resizing a table that\r\n\t* is small enough to show the problem. \r\n\t*/\r\n /*\r\n\t\t* Bug in Windows.  When LVM_SETCOLUMNORDERARRAY is used to change\r\n\t\t* the column order, the header redraws correctly but the table does\r\n\t\t* not.  The fix is to force a redraw.\r\n\t\t*/\r\n /*\r\n\t* An index of -1 will apply the change to all\r\n\t* items.  Ensure that index is greater than -1.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  Making any change to an item that\r\n\t* changes the item height of a table while the table\r\n\t* is scrolled can cause the lines to draw incorrectly.\r\n\t* This happens even when the lines are not currently\r\n\t* visible and are shown afterwards.  The fix is to\r\n\t* save the top index, scroll to the top of the table\r\n\t* and then restore the original top index.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  Setting the font will cause the table\r\n\t* to be redrawn but not the column headers.  The fix is\r\n\t* to force a redraw of the column headers.\r\n\t*/\r\n /*\r\n\t* The Windows table control uses CLR_DEFAULT to indicate\r\n\t* that it is using the default foreground color.  This\r\n\t* is undocumented.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the foreground color is\r\n\t* changed, the table does not redraw until the next\r\n\t* WM_PAINT.  The fix is to force a redraw.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  Setting or clearing LVS_NOCOLUMNHEADER\r\n\t* causes the table to scroll to the beginning.  The fix is to\r\n\t* save and restore the top index causing the table to scroll\r\n\t* to the new location.\r\n\t*/\r\n /*\r\n\t\t* Bug in Windows.  When a virutal table contains items and\r\n\t\t* LVM_SETITEMCOUNT is used to set the new item count to zero,\r\n\t\t* Windows does not redraw the table.  Note that simply not\r\n\t\t* specifying LVSICF_NOINVALIDATEALL or LVSICF_NOSCROLL does\r\n\t\t* correct the problem.  The fix is to force a redraw.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  When both a header and grid lines are\r\n\t* displayed, the grid lines do not take into account the\r\n\t* height of the header and draw in the wrong place.  The\r\n\t* fix is to set the height of the table items to be the\r\n\t* height of the header so that the lines draw in the right\r\n\t* place.  The height of a table item is the maximum of the\r\n\t* height of the font or the height of image list.\r\n\t*\r\n\t* NOTE: In version 5.80 of COMCTL32.DLL, the bug is fixed.\r\n\t*/\r\n /*\r\n\t * Feature in Windows.  When WM_SETREDRAW is used to turn\r\n\t * off drawing in a widget, it clears the WS_VISIBLE bits\r\n\t * and then sets them when redraw is turned back on.  This\r\n\t * means that WM_SETREDRAW will make a widget unexpectedly\r\n\t * visible.  The fix is to track the visibility state while\r\n\t * drawing is turned off and restore it when drawing is turned\r\n\t * back on.\r\n\t */\r\n /* Set the width of the horizontal scroll bar */\r\n /*\r\n\t\t\t* Bug in Windows.  When LVM_SETIMAGELIST is used to remove the\r\n\t\t\t* image list by setting it to NULL, the item width and height\r\n\t\t\t* is not changed and space is reserved for icons despite the\r\n\t\t\t* fact that there are none.  The fix is to set the image list\r\n\t\t\t* to be very small before setting it to NULL.  This causes\r\n\t\t\t* Windows to reserve the smallest possible space when an image\r\n\t\t\t* list is removed.  In this case, the scroll width must be one\r\n\t\t\t* pixel larger.\r\n\t\t\t*/\r\n /*\r\n\t* NOTE: It is much faster to measure the strings and compute the\r\n\t* width of the scroll bar in non-virtual table rather than using\r\n\t* LVM_SETCOLUMNWIDTH with LVSCW_AUTOSIZE.\r\n\t*/\r\n /*\r\n\t\t\t* Bug in Windows.  When LVM_SETIMAGELIST is used to remove the\r\n\t\t\t* image list by setting it to NULL, the item width and height\r\n\t\t\t* is not changed and space is reserved for icons despite the\r\n\t\t\t* fact that there are none.  The fix is to set the image list\r\n\t\t\t* to be very small before setting it to NULL.  This causes\r\n\t\t\t* Windows to reserve the smallest possible space when an image\r\n\t\t\t* list is removed.\r\n\t\t\t*/\r\n /*\r\n\t\t* Bug in Windows.  For some reason, LVM_ENSUREVISIBLE can\r\n\t\t* scroll one item more or one item less when there is not\r\n\t\t* enough space to show a single table item.  The fix is\r\n\t\t* to detect the case and call LVM_ENSUREVISIBLE again with\r\n\t\t* the same arguments.  It seems that once LVM_ENSUREVISIBLE\r\n\t\t* has scrolled into the general area, it is able to scroll\r\n\t\t* to the exact item.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  When the table header is visible and\r\n\t* there is not enough space to show a single table item,\r\n\t* LVM_GETCOUNTPERPAGE can return a negative number instead\r\n\t* of zero.  The fix is to test for negative or zero.\r\n\t*/\r\n /* Use LVM_SCROLL to scroll the table */\r\n /*\r\n\t* Feature in Windows.  Calling LVM_GETSUBITEMRECT with -1 for the\r\n\t* row number gives the bounds of the item that would be above the\r\n\t* first row in the table.  This is undocumented and does not work\r\n\t* for the first column. In this case, to get the bounds of the\r\n\t* first column, get the bounds of the second column and subtract\r\n\t* the width of the first. The left edge of the second column is\r\n\t* also used as the right edge of the first.\r\n\t*/\r\n /*\r\n\t\t* Bug in Windows.  For some reason, LVM_ENSUREVISIBLE can\r\n\t\t* scroll one item more or one item less when there is not\r\n\t\t* enough space to show a single table item.  The fix is\r\n\t\t* to detect the case and call LVM_ENSUREVISIBLE again with\r\n\t\t* the same arguments.  It seems that once LVM_ENSUREVISIBLE\r\n\t\t* has scrolled into the general area, it is able to scroll\r\n\t\t* to the exact item.\r\n\t\t*/\r\n /*\r\n\t* Bug in Windows.  For some reason, when there is insufficient space\r\n\t* to show an item, LVM_ENSUREVISIBLE causes blank lines to be\r\n\t* inserted at the top of the widget.  A call to LVM_GETTOPINDEX will\r\n\t* return a negative number (this is an impossible result).  The fix \r\n\t* is to use LVM_GETCOUNTPERPAGE to detect the case when the number \r\n\t* of visible items is zero and use LVM_ENSUREVISIBLE with the\r\n\t* fPartialOK flag set to true to scroll the table.\r\n\t*/\r\n /*\r\n\t\t\t* NOTE: Call the window proc with WM_KEYDOWN rather than WM_CHAR\r\n\t\t\t* so that the key that was ignored during WM_KEYDOWN is processed.\r\n\t\t\t* This allows the application to cancel an operation that is normally\r\n\t\t\t* performed in WM_KEYDOWN from WM_CHAR.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* Feature in Windows.  Windows sends LVN_ITEMACTIVATE from WM_KEYDOWN\r\n\t\t\t* instead of WM_CHAR.  This means that application code that expects\r\n\t\t\t* to consume the key press and therefore avoid a SWT.DefaultSelection\r\n\t\t\t* event will fail.  The fix is to ignore LVN_ITEMACTIVATE when it is\r\n\t\t\t* caused by WM_KEYDOWN and send SWT.DefaultSelection from WM_CHAR.\r\n\t\t\t*/\r\n /*\r\n\t* Ensure that there is an accessible object created for this\r\n\t* control because support for checked item accessibility is\r\n\t* temporarily implemented in the accessibility package.\r\n\t*/\r\n /*\r\n\t\t\t* Ensure that the window proc does not process VK_SPACE\r\n\t\t\t* so that it can be handled in WM_CHAR.  This allows the\r\n\t\t\t* application to cancel an operation that is normally\r\n\t\t\t* performed in WM_KEYDOWN from WM_CHAR.\r\n\t\t\t*/\r\n /*\r\n\t* Bug in Windows.  When LVS_SHOWSELALWAYS is not specified,\r\n\t* Windows hides the selection when focus is lost but does\r\n\t* not redraw anything other than the text, leaving the image\r\n\t* and check box appearing selected.  The fix is to redraw\r\n\t* the table.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the user selects outside of\r\n\t* a table item, Windows deselects all the items, even\r\n\t* when the table is multi-select.  While not strictly\r\n\t* wrong, this is unexpected.  The fix is to detect the\r\n\t* case and avoid calling the window proc.\r\n\t*/\r\n /*\r\n\t\t* Note that when the table has LVS_EX_FULLROWSELECT and the\r\n\t\t* user clicks anywhere on a row except on the check box, all\r\n\t\t* of the bits are set.  The hit test flags are LVHT_ONITEM.\r\n\t\t* This means that a bit test for LVHT_ONITEMSTATEICON is not\r\n\t\t* the correct way to determine that the user has selected\r\n\t\t* the check box, equality is needed.\r\n\t\t*/\r\n /* Look for check/uncheck */\r\n /*\r\n\t* Feature in Windows.  For some reason, capturing\r\n\t* the mouse after processing the mouse event for the\r\n\t* widget interferes with the normal mouse processing\r\n\t* for the widget.  The fix is to avoid the automatic\r\n\t* mouse capture.\r\n\t*/\r\n /*\r\n\t\t* Note that when the table has LVS_EX_FULLROWSELECT and the\r\n\t\t* user clicks anywhere on a row except on the check box, all\r\n\t\t* of the bits are set.  The hit test flags are LVHT_ONITEM.\r\n\t\t* This means that a bit test for LVHT_ONITEMSTATEICON is not\r\n\t\t* the correct way to determine that the user has selected\r\n\t\t* the check box, equality is needed.\r\n\t\t*/\r\n /* Look for check/uncheck */\r\n /*\r\n\t* Feature in Windows.  Despite the fact that hot\r\n\t* tracking is not enabled, the hot tracking code\r\n\t* in WM_MOUSEHOVER is executed causing the item\r\n\t* under the cursor to be selected.  The fix is to\r\n\t* avoid calling the window proc.\r\n\t*/\r\n /* Resize the item array to match the item count */\r\n /*\r\n\t\t\t\t* Bug in Windows.  When a table has the LVS_EX_GRIDLINES extended\r\n\t\t\t\t* style and the user drags any column over the first column in the\r\n\t\t\t\t* table, making the size become zero, when the user drags a column\r\n\t\t\t\t* such that the size of the first column becomes non-zero, the grid\r\n\t\t\t\t* lines are not redrawn.  The fix is to detect the case and force\r\n\t\t\t\t* a redraw of the first column.\r\n\t\t\t\t*/\r\n /*\r\n\t\t\t\t\t\t\t\t* It is possible (but unlikely), that application\r\n\t\t\t\t\t\t\t\t* code could have disposed the widget in the resize\r\n\t\t\t\t\t\t\t\t* event.  If this happens, end the processing of the\r\n\t\t\t\t\t\t\t\t* Windows message by returning zero as the result of\r\n\t\t\t\t\t\t\t\t* the window proc.\r\n\t\t\t\t\t\t\t\t*/\r\n /*\r\n\t\t\t\t\t\t\t\t* It is possible (but unlikely), that application\r\n\t\t\t\t\t\t\t\t* code could have disposed the column in the move\r\n\t\t\t\t\t\t\t\t* event.  If this happens, process the move event\r\n\t\t\t\t\t\t\t\t* for those columns that have not been destroyed.\r\n\t\t\t\t\t\t\t\t*/\r\n /*\r\n\t\t* Feature in Windows.  On NT, the automatically created\r\n\t\t* header control is created as a UNICODE window, not an\r\n\t\t* ANSI window despite the fact that the parent is created\r\n\t\t* as an ANSI window.  This means that it sends UNICODE\r\n\t\t* notification messages to the parent window on NT for\r\n\t\t* no good reason.  The data and size in the NMHEADER and\r\n\t\t* HDITEM structs is identical between the platforms so no\r\n\t\t* different message is actually necessary.  Despite this,\r\n\t\t* Windows sends different messages.  The fix is to look\r\n\t\t* for both messages, despite the platform.  This works\r\n\t\t* because only one will be sent on either platform, never\r\n\t\t* both.\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows.  When the user selects outside of\r\n\t* a table item, Windows deselects all the items, even\r\n\t* when the table is multi-select.  While not strictly\r\n\t* wrong, this is unexpected.  The fix is to detect the\r\n\t* case and avoid calling the window proc.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  For some reason, capturing\r\n\t* the mouse after processing the mouse event for the\r\n\t* widget interferes with the normal mouse processing\r\n\t* for the widget.  The fix is to avoid the automatic\r\n\t* mouse capture.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  For some reason, the table does\r\n\t* not set the default focus rectangle to be the first\r\n\t* item in the table when it gets focus and there is\r\n\t* no selected item.  The fix to make the first item\r\n\t* be the focus item.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When a table is drawing grid lines and the\r\n\t* user scrolls vertically up or down by a line or a page, the\r\n\t* table does not redraw the grid lines for newly exposed items.\r\n\t* The fix is to invalidate the items.\r\n\t*/\r\n /*\r\n\t\t\t* The cached flag is used by both virtual and non-virtual\r\n\t\t\t* tables to indicate that Windows has asked at least once\r\n\t\t\t* for a table item.\r\n\t\t\t*/\r\n /*\r\n\t\t\t\t\t* Bug in Windows.  When pszText points to a zero length\r\n\t\t\t\t\t* NULL terminated string, Windows correctly draws the\r\n\t\t\t\t\t* empty string but the cache of the bounds for the item\r\n\t\t\t\t\t* is not reset.  This means that when the text for the\r\n\t\t\t\t\t* item is set and then reset to an empty string, the\r\n\t\t\t\t\t* selection draws using the bounds of the previous text.\r\n\t\t\t\t\t* The fix is to use a space rather than an empty string\r\n\t\t\t\t\t* when anything but a tool tip is requested (to avoid\r\n\t\t\t\t\t* a tool tip that is a single space).\r\n\t\t\t\t\t* \r\n\t\t\t\t\t* NOTE: This is only a problem for items in the first\r\n\t\t\t\t\t* column.  Assigning NULL to other columns stops Windows\r\n\t\t\t\t\t* from drawing the selection when LVS_EX_FULLROWSELECT\r\n\t\t\t\t\t* is set.\r\n\t\t\t\t\t*/\r\n /*\r\n\t\t\t\t\t* Feature in Windows.  When the font is set for one cell in a table,\r\n\t\t\t\t\t* Windows does not reset the font for the next cell.  As a result,\r\n\t\t\t\t\t* all subsequent cells are drawn using the new font.  The fix is to\r\n\t\t\t\t\t* reset the font to the default.\r\n\t\t\t\t\t* \r\n\t\t\t\t\t* NOTE: This does not happen for foreground and background.\r\n\t\t\t\t\t*/\r\n /* \r\n\t\t\t* Feature on Pocket PC.  The tree and table controls detect the tap\r\n\t\t\t* and hold gesture by default. They send a GN_CONTEXTMENU message to show\r\n\t\t\t* the popup menu.  This default behaviour is unwanted on Pocket PC 2002\r\n\t\t\t* when no menu has been set, as it still draws a red circle.  The fix\r\n\t\t\t* is to disable this default behaviour when no menu is set by returning\r\n\t\t\t* TRUE when receiving the Pocket PC 2002 specific NM_RECOGNIZEGESTURE\r\n\t\t\t* message.\r\n\t\t\t*/\r\n","PrintDialog":" /* Get driver and device from the DEVNAMES struct */\r\n /* Ensure size is a multiple of 2 bytes on UNICODE platforms */\r\n /* Create PrinterData object and set fields from PRINTDLG */\r\n /* Bulk-save the printer-specific settings in the DEVMODE struct */\r\n","StyledTextRenderer":" device to render on\r\n  width in pixels of a tab character\r\n  width in pixels of the space used to represent line delimiters\r\n  fixes bug 41773\r\n  clear the font cache\r\n  completely selected\r\n ","MenuAdapter":" ","SWT_AWT":" /* SWT Imports */\r\n /* AWT Imports */\r\n /*\r\n\t* Note that the jawt library is loaded explicitily\r\n\t* because it cannot be found by the library loader.\r\n\t* All exceptions are caught because the library may\r\n\t* have been loaded already.\r\n\t*/\r\n /* Initialize the default focus traversal policy */\r\n /*\r\n\t * Some JREs have implemented the embedded frame constructor to take an integer\r\n\t * and other JREs take a long.  To handle this binary incompatability, use\r\n\t * reflection to create the embedded frame.\r\n\t */\r\n /*\r\n\t* This is necessary to make lightweight components\r\n\t* directly added to the frame receive mouse events\r\n\t* properly.\r\n\t*/\r\n /*\r\n\t* Generate the appropriate events to activate and deactivate\r\n\t* the embedded frame. This is needed in order to make keyboard\r\n\t* focus work properly for lightweights.\r\n\t*/\r\n /*\r\n\t* TEMPORARY CODE\r\n\t* \r\n\t* For some reason, the graphics configuration of the embedded\r\n\t* frame is not initialized properly. This causes an exception\r\n\t* when the depth of the screen is changed.\r\n\t*/\r\n","DefaultContent":" stores text listeners for event sending\r\n  stores the actual text\r\n  the character position start of the gap\r\n  the character position after the end of the gap\r\n  the line on which the gap exists, the gap will always be associated\r\n  with one line\r\n  array of character positions and lengths representing\r\n  the number of lines of text\r\n  the expansion exponent, used to increase the lines array exponentially\r\n  the expansion exponent, used to increase the lines array exponentially\r\n  expand the lines by powers of 2\r\n  text is being deleted at the gap position\r\n  text is being inserted at the gap position\r\n  see if the next character is a LF\r\n  deleting text, see if part of a \\r\\n line delimiter is being deleted\r\n  see if char before delete position is \\r\r\n  see if char after delete position is \\n\r\n  inserting text, see if the \\r\\n line delimiter is being split\r\n  see if the next character is a LF\r\n  inserted text will be placed in the gap\r\n  and all of the newly inserted text\r\n  shrink gap\r\n  figure out the number of new lines that have been inserted\r\n  only insert an empty line if it is the last line in the text\r\n  line\r\n  last inserted line is a new line\r\n  make room for the new lines\r\n  shift down the lines after the replace line\r\n  insert the new lines\r\n  update the last inserted line\r\n  adjust the line length\r\n  adjust the offsets of the lines after the gapLine\r\n  remove the old gap from the lines information\r\n  removing the gap\r\n  adjust the line length\r\n  adjust the offsets of the lines after the gapLine\r\n  add the new gap to the lines information\r\n  see if the next character is a LF\r\n  gap is in the specified range, strip out the gap\r\n  line is before or after the gap\r\n  gap is in the specified range, strip out the gap\r\n  line is before or after the gap\r\n  position includes the gap\r\n  position is before the gap\r\n  last character) - for inserting\r\n  check for invalid replace operations\r\n  inform listeners\r\n  first delete the text to be replaced\r\n  then insert the new text\r\n  inform listeners\r\n  right or left\r\n  finding the first line delmiter after position\r\n  update the line where the deletion started\r\n  figure out the number of lines that have been deleted\r\n  the offset or length of the lines\r\n ","ImageList":" /* Create resources */\r\n /* Get the foreground pixels */\r\n /* Merge the alpha channel in place */\r\n /* Stretch */\r\n /* Free resources */\r\n /*\r\n\t\t* If the image has a palette with multiple entries having\r\n\t\t* the same color and one of those entries is the transparentPixel,\r\n\t\t* only the first entry becomes transparent. To avoid this\r\n\t\t* problem, temporarily change the image palette to a palette\r\n\t\t* where the transparentPixel is white and everything else is\r\n\t\t* black. \r\n\t\t*/\r\n /* Put back the original palette */\r\n /*\r\n\t\t\t* Note that the image size has to match the image list icon size. \r\n\t\t\t*/\r\n /* Note that the mask must always be replaced even for TRANSPARENCY_NONE */\r\n","Tray":" ","NMTVDISPINFO":" TVITEM item;\r\n ","TIFFRandomFileAccess":" /* store required bytes */\r\n /* Get cached bytes */\r\n /* Read required bytes */\r\n","OSVERSIONINFO":" /*final*/\r\n","CHOOSEFONT":" ","ACCEL":" ","TitleListener":" ","INPUT":" ","MouseTrackAdapter":" ","Printer":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n /* Use the character encoding for the default locale */\r\n /* Use the character encoding for the default locale */\r\n /* Use the character encoding for the default locale */\r\n /* Use the character encoding for the default locale */\r\n /* Use the character encoding for the default locale */\r\n","Cursor":" /*\r\n\t* IDC_HAND is supported only on Windows 2000 and Windows 98.\r\n\t* Create a hand cursor if running in other Windows platforms.\r\n\t*/\r\n /* Check the bounds. Mask must be the same size as source */\r\n /* Check the hotspots */\r\n /* Convert depth to 1 */\r\n /* Make sure source and mask scanline pad is 2 */\r\n /* Create the cursor */\r\n /* Check the hotspots */\r\n /* Create the icon */\r\n /*\r\n\t \t* The MSDN states that one should not destroy a shared\r\n\t \t* cursor, that is, one obtained from LoadCursor.\r\n\t \t* However, it does not appear to do any harm, so rather\r\n\t \t* than keep track of how a cursor was created, we just\r\n\t \t* destroy them all. If this causes problems in the future,\r\n\t \t* put the flag back in.\r\n\t\t*/\r\n","OleEnumFORMATETC":" register each of the interfaces that this object implements\r\n  Resets the enumeration sequence to the beginning.\r\n  Skips over the next specified number of elements in the enumeration sequence.\r\n ","FocusEvent":" ","IOleDocumentView":" ","SWTException":" $NON-NLS-1$   $NON-NLS-1$\r\n ","NOTIFYICONDATAW":" ","CREATESTRUCT":" ","Tree":" if ((oldStyle & OS.WS_VISIBLE) != 0) newStyle |= OS.WS_VISIBLE;\r\n  OS.SendMessage (handle, OS.WM_SETREDRAW, 1, 0);\r\n  $NON-NLS-1$\r\n  bits |= OS.TVS_NOTOOLTIPS;\r\n  OS.SendMessage (handle, OS.WM_SETREDRAW, 1, 0);\r\n  OS.SendMessage (handle, OS.WM_SETREDRAW, 1, 0);\r\n  TODO - column flashes when resized\r\n  if (OS.GetCapture () != handle) OS.SetCapture (handle);\r\n /*\r\n\t* Feature in Windows.  It is not possible to create\r\n\t* a tree that scrolls and does not have scroll bars.\r\n\t* The TVS_NOSCROLL style will remove the scroll bars\r\n\t* but the tree will never scroll.  Therefore, no matter\r\n\t* what style bits are specified, set the H_SCROLL and\r\n\t* V_SCROLL bits so that the SWT style will match the\r\n\t* widget that Windows creates.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When TVM_GETBKCOLOR is used more\r\n\t* than once to set the background color of a tree,\r\n\t* the background color of the lines and the plus/minus\r\n\t* does not change to the new color.  The fix is to set\r\n\t* the background color to the default before setting\r\n\t* the new color.\r\n\t*/\r\n /*\r\n\t\t* Bug in Windows.  For some reason, when the user clicks\r\n\t\t* on this control, the Windows hook WH_MSGFILTER is sent\r\n\t\t* despite the fact that an input event from a dialog box,\r\n\t\t* message box, menu, or scroll bar did not seem to occur.\r\n\t\t* The fix is to ignore the hook.\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows.  If redraw is turned off using WM_SETREDRAW \r\n\t* and a tree item that is not a child of the first root is selected or\r\n\t* scrolled using TVM_SELECTITEM or TVM_ENSUREVISIBLE, then scrolling\r\n\t* does not occur.  The fix is to detect this case, and make sure\r\n\t* that redraw is temporarly enabled.  To avoid flashing, DefWindowProc()\r\n\t* is called to disable redrawing.\r\n\t* \r\n\t* NOTE:  The code that actually works around the problem is in the\r\n\t* callers of this method.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  In version 5.8 of COMCTL32.DLL,\r\n\t* if the font is changed for an item, the bounds for the\r\n\t* item are not updated, causing the text to be clipped.\r\n\t* The fix is to detect the version of COMCTL32.DLL, and\r\n\t* if it is one of the versions with the problem, then\r\n\t* use version 5.00 of the control (a version that does\r\n\t* not have the problem).  This is the recomended work\r\n\t* around from the MSDN.\r\n\t*/\r\n /* Set the checkbox image list */\r\n /*\r\n\t* Feature in Windows.  When the control is created,\r\n\t* it does not use the default system font.  A new HFONT\r\n\t* is created and destroyed when the control is destroyed.\r\n\t* This means that a program that queries the font from\r\n\t* this control, uses the font in another control and then\r\n\t* destroys this control will have the font unexpectedly\r\n\t* destroyed in the other control.  The fix is to assign\r\n\t* the font ourselves each time the control is created.\r\n\t* The control will not destroy a font that it did not\r\n\t* create.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  For some reason, when HDM_INSERTITEM\r\n\t* is used to insert an item into a header without text,\r\n\t* if is not possible to set the text at a later time.\r\n\t* The fix is to insert the item with an empty string.\r\n\t*/\r\n /* When the first column is created, hide the horizontal scroll bar */\r\n /* Redraw to hide the items when the first column is created */\r\n /*\r\n\t* Bug in Windows.  When a child item is added to a parent item\r\n\t* that has no children outside of WM_NOTIFY with control code\r\n\t* TVN_ITEMEXPANDED, the tree widget does not redraw the +/-\r\n\t* indicator.  The fix is to detect the case when the first\r\n\t* child is added to a visible parent item and redraw the parent.\r\n\t*/\r\n /*\r\n\t* When the last column is deleted, show the horizontal\r\n\t* scroll bar.   Otherwise, left align the first column\r\n\t* and redraw the columns to the right.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When an item is removed that is not\r\n\t* visible in the tree because it belongs to a collapsed branch,\r\n\t* Windows redraws the tree causing a flash for each item that\r\n\t* is removed.  The fix is to detect whether the item is visible,\r\n\t* force the widget to be fully painted, turn off redraw, remove\r\n\t* the item and validate the damage caused by the removing of\r\n\t* the item.\r\n\t*/\r\n /*\r\n\t\t* If the item that was deleted was the last child of a tree item that\r\n\t\t* is visible, redraw the parent item to force the +/- to be updated.\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows.  When a tree is given a background color\r\n\t* using TVM_SETBKCOLOR and the tree is disabled, Windows draws\r\n\t* the tree using the background color rather than the disabled\r\n\t* colors.  This is different from the table which draws grayed.\r\n\t* The fix is to set the default background color while the tree\r\n\t* is disabled and restore it when enabled.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When a tree is given a background color\r\n\t* using TVM_SETBKCOLOR and the tree is disabled, Windows draws\r\n\t* the tree using the background color rather than the disabled\r\n\t* colors.  This is different from the table which draws grayed.\r\n\t* The fix is to set the default background color while the tree\r\n\t* is disabled and restore it when enabled.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  In some cases an expand or collapse message\r\n\t* can occurs from within TVM_DELETEITEM.  When this happens, the item\r\n\t* being destroyed has been removed from the list of items but has not\r\n\t* been deleted from the tree.  The fix is to check for null items and\r\n\t* remove them from the list.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  For some reason, when TVM_GETIMAGELIST\r\n\t* or TVM_SETIMAGELIST is sent, the tree issues NM_CUSTOMDRAW\r\n\t* messages.  This behavior is unwanted when the tree is being\r\n\t* disposed.  The fix is to ingore NM_CUSTOMDRAW messages by\r\n\t* clearing the custom draw flag.\r\n\t* \r\n\t* NOTE: This only happens on Windows XP.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When a tree is given a background color\r\n\t* using TVM_SETBKCOLOR and the tree is disabled, Windows draws\r\n\t* the tree using the background color rather than the disabled\r\n\t* colors.  This is different from the table which draws grayed.\r\n\t* The fix is to set the default background color while the tree\r\n\t* is disabled and restore it when enabled.\r\n\t*/\r\n /*\r\n\t* Ensure that the selection is visible when the tree is resized\r\n\t* from a zero size to a size that can show the selection.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  Under certain circumstances, when WM_SETCURSOR\r\n\t* is sent from SendMessage(), Windows GP's in the window proc for\r\n\t* the tree.  The fix is to avoid calling the tree window proc and\r\n\t* set the cursor for the tree outside of WM_SETCURSOR.\r\n\t* \r\n\t* NOTE:  This code assumes that the default cursor for the tree\r\n\t* is IDC_ARROW.\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  For some reason, when WM_SETREDRAW\r\n\t* is used to turn redraw on for a tree and the tree\r\n\t* contains no items, the last item in the tree does\r\n\t* not redraw properly.  If the tree has only one item,\r\n\t* that item is not drawn.  If another window is dragged\r\n\t* on top of the item, parts of the item are redrawn\r\n\t* and erased at random.  The fix is to ensure that this\r\n\t* case doesn't happen by inserting and deleting an item\r\n\t* when redraw is turned on and there are no items in\r\n\t* the tree.\r\n\t*/\r\n /* Select/deselect the first item */\r\n /*\r\n\t\t* Bug in Windows.  When TVM_SELECTITEM is used to select and\r\n\t\t* scroll an item to be visible and the client area of the tree\r\n\t\t* is smaller that the size of one item, TVM_SELECTITEM makes\r\n\t\t* the next item in the tree visible by making it the top item\r\n\t\t* instead of making the desired item visible.  The fix is to\r\n\t\t* detect the case when the client area is too small and make\r\n\t\t* the desired visible item be the top item in the tree.\r\n\t\t* \r\n\t\t* Note that TVM_SELECTITEM when called with TVGN_FIRSTVISIBLE\r\n\t\t* also requires the work around for scrolling.\r\n\t\t*/\r\n /*\r\n\t\t* Feature in Windows.  When the old and new focused item\r\n\t\t* are the same, Windows does not check to make sure that\r\n\t\t* the item is actually selected, not just focused.  The\r\n\t\t* fix is to force the item to draw selected by setting\r\n\t\t* the state mask, and to ensure that it is visible.\r\n\t\t*/\r\n /* Select/deselect the rest of the items */\r\n /*\r\n\t* Bug in Windows.  When TVM_ENSUREVISIBLE is used to ensure\r\n\t* that an item is visible and the client area of the tree is\r\n\t* smaller that the size of one item, TVM_ENSUREVISIBLE makes\r\n\t* the next item in the tree visible by making it the top item\r\n\t* instead of making the desired item visible.  The fix is to\r\n\t* detect the case when the client area is too small and make\r\n\t* the desired visible item be the top item in the tree.\r\n\t*/\r\n /*\r\n\t\t\t\t* Bug on WinCE.  lParam should be NULL when the message is not sent\r\n\t\t\t\t* by a scroll bar control, but it contains the handle to the window.\r\n\t\t\t\t* When the message is sent by a scroll bar control, it correctly\r\n\t\t\t\t* contains the handle to the scroll bar.  The fix is to check for\r\n\t\t\t\t* both.\r\n\t\t\t\t*/\r\n /* Keyboard messages */\r\n /* Mouse messages */\r\n /* Other messages */\r\n /*\r\n\t\t\t* Feature in Windows.  Windows sends NM_RETURN from WM_KEYDOWN\r\n\t\t\t* instead of using WM_CHAR.  This means that application code\r\n\t\t\t* that expects to consume the key press and therefore avoid a\r\n\t\t\t* SWT.DefaultSelection event from WM_CHAR will fail.  The fix\r\n\t\t\t* is to implement SWT.DefaultSelection in WM_CHAR instead of\r\n\t\t\t* using NM_RETURN.\r\n\t\t\t*/\r\n /*\r\n\t* Feature in Windows.  The tree control beeps\r\n\t* in WM_CHAR when the search for the item that\r\n\t* matches the key stroke fails.  This is the\r\n\t* standard tree behavior but is unexpected when\r\n\t* the key that was typed was ESC, CR or SPACE.\r\n\t* The fix is to avoid calling the tree window\r\n\t* proc in these cases.\r\n\t*/\r\n /*\r\n\t* Ensure that there is an accessible object created for this\r\n\t* control because support for checked item and tree column\r\n\t* accessibility is temporarily implemented in the accessibility\r\n\t* package.\r\n\t*/\r\n /*\r\n\t\t\t* Ensure that the window proc does not process VK_SPACE\r\n\t\t\t* so that it can be handled in WM_CHAR.  This allows the\r\n\t\t\t* application to cancel an operation that is normally\r\n\t\t\t* performed in WM_KEYDOWN from WM_CHAR.\r\n\t\t\t*/\r\n /*\r\n\t* Feature in Windows.  When multiple item have\r\n\t* the TVIS_SELECTED state, Windows redraws only\r\n\t* the focused item in the color used to show the\r\n\t* selection when the tree loses or gains focus.\r\n\t* The fix is to force Windows to redraw all the\r\n\t* visible items when focus is gained or lost.\r\n\t*/\r\n /*\r\n\t* In a multi-select tree, if the user is collapsing a subtree that\r\n\t* contains selected items, clear the selection from these items and\r\n\t* issue a selection event.  Only items that are selected and visible\r\n\t* are cleared.  This code also runs in the case when no item is selected.\r\n\t*/\r\n /* Look for check/uncheck */\r\n /* Get the selected state of the item under the mouse */\r\n /* Get the selected state of the last selected item */\r\n /* Check for CONTROL or drag selection */\r\n /* Do the selection */\r\n /*\r\n\t* Feature in Windows.  When the old and new focused item\r\n\t* are the same, Windows does not check to make sure that\r\n\t* the item is actually selected, not just focused.  The\r\n\t* fix is to force the item to draw selected by setting\r\n\t* the state mask.  This is only necessary when the tree\r\n\t* is single select.\r\n\t*/\r\n /* Check for CONTROL and reselect the last item */\r\n /* Check for SHIFT or normal select and delect/reselect items */\r\n /* Reselect the last item that was unselected */\r\n /* Issue notification */\r\n /*\r\n\t* Feature in Windows.  Inside WM_LBUTTONDOWN and WM_RBUTTONDOWN,\r\n\t* the widget starts a modal loop to determine if the user wants\r\n\t* to begin a drag/drop operation or marque select.  Unfortunately,\r\n\t* this modal loop eats the corresponding mouse up.  The fix is to\r\n\t* detect the cases when the modal loop has eaten the mouse up and\r\n\t* issue a fake mouse up.\r\n\t*/\r\n /*\r\n\t\t* Feature in Windows.  On NT, the automatically created\r\n\t\t* header control is created as a UNICODE window, not an\r\n\t\t* ANSI window despite the fact that the parent is created\r\n\t\t* as an ANSI window.  This means that it sends UNICODE\r\n\t\t* notification messages to the parent window on NT for\r\n\t\t* no good reason.  The data and size in the NMHEADER and\r\n\t\t* HDITEM structs is identical between the platforms so no\r\n\t\t* different message is actually necessary.  Despite this,\r\n\t\t* Windows sends different messages.  The fix is to look\r\n\t\t* for both messages, despite the platform.  This works\r\n\t\t* because only one will be sent on either platform, never\r\n\t\t* both.\r\n\t\t*/\r\n /*\r\n\t* Feature in Windows.  The receiver uses WM_RBUTTONDOWN\r\n\t* to initiate a drag/drop operation depending on how the\r\n\t* user moves the mouse.  If the user clicks the right button,\r\n\t* without moving the mouse, the tree consumes the corresponding\r\n\t* WM_RBUTTONUP.  The fix is to avoid calling the window proc for\r\n\t* the tree.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When the user selects a tree item\r\n\t* with the right mouse button, the item remains selected\r\n\t* only as long as the user does not release or move the\r\n\t* mouse.  As soon as this happens, the selection snaps\r\n\t* back to the previous selection.  This behavior can be\r\n\t* observed in the Explorer but is not instantly apparent\r\n\t* because the Explorer explicity sets the selection when\r\n\t* the user chooses a menu item.  If the user cancels the\r\n\t* menu, the selection snaps back.  The fix is to avoid\r\n\t* calling the window proc and do the selection ourselves.\r\n\t* This behavior is consistent with the table.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  For some reason, when WM_PRINT is used\r\n\t* to capture an image of a hierarchy that contains a tree with\r\n\t* columns, the clipping that is used to stop the first column\r\n\t* from drawing on top of subsequent columns stops the first\r\n\t* column and the tree lines from drawing.  This does not happen\r\n\t* during WM_PAINT.  The fix is to draw without clipping and\r\n\t* then draw the rest of the columns on top.  Since the drawing\r\n\t* is happening in WM_PRINTCLIENT, the redrawing is not visible.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  When multiple item have\r\n\t* the TVIS_SELECTED state, Windows redraws only\r\n\t* the focused item in the color used to show the\r\n\t* selection when the tree loses or gains focus.\r\n\t* The fix is to force Windows to redraw all the\r\n\t* visible items when focus is gained or lost.\r\n\t*/\r\n /*\r\n\t* Feature in Windows.  Tree controls send WM_CTLCOLOREDIT\r\n\t* to allow application code to change the default colors.\r\n\t* This is undocumented and conflicts with TVM_SETTEXTCOLOR\r\n\t* and TVM_SETBKCOLOR, the documented way to do this.  The\r\n\t* fix is to ignore WM_CTLCOLOREDIT messages from trees.\r\n\t*/\r\n /*\r\n\t\t\t* Feature in Windows.  When a new tree item is inserted\r\n\t\t\t* using TVM_INSERTITEM, a TVN_GETDISPINFO is sent before\r\n\t\t\t* TVM_INSERTITEM returns and before the item is added to\r\n\t\t\t* the items array.  The fix is to check for null.\r\n\t\t\t* \r\n\t\t\t* NOTE: This only happens on XP with the version 6.00 of\r\n\t\t\t* COMCTL32.DLL,\r\n\t\t\t*/\r\n /*\r\n\t\t\t\t\t* Feature in Windows.  When a new tree item is inserted\r\n\t\t\t\t\t* using TVM_INSERTITEM and the tree is using custom draw,\r\n\t\t\t\t\t* a NM_CUSTOMDRAW is sent before TVM_INSERTITEM returns\r\n\t\t\t\t\t* and before the item is added to the items array.  The\r\n\t\t\t\t\t* fix is to check for null.\r\n\t\t\t\t\t* \r\n\t\t\t\t\t* NOTE: This only happens on XP with the version 6.00 of\r\n\t\t\t\t\t* COMCTL32.DLL,\r\n\t\t\t\t\t*/\r\n /*\r\n\t\t\t\t\t* Feature in Windows.  Under certain circumstances, Windows\r\n\t\t\t\t\t* sends CDDS_ITEMPOSTPAINT for an empty rectangle.  This is\r\n\t\t\t\t\t* not a problem providing that graphics do not occur outside\r\n\t\t\t\t\t* the rectangle.  The fix is to test for the rectangle and\r\n\t\t\t\t\t* draw nothing.\r\n\t\t\t\t\t* \r\n\t\t\t\t\t* NOTE:  This seems to happen when both I_IMAGECALLBACK\r\n\t\t\t\t\t* and LPSTR_TEXTCALLBACK are used at the same time with\r\n\t\t\t\t\t* TVM_SETITEM.\r\n\t\t\t\t\t*/\r\n /*\r\n\t\t\t\t\t\t\t\t* Feature in Windows.  When the mouse is pressed and the\r\n\t\t\t\t\t\t\t\t* selection is first drawn for a tree, the item is drawn\r\n\t\t\t\t\t\t\t\t* selected, but the TVIS_SELECTED bits for the item are\r\n\t\t\t\t\t\t\t\t* not set.  When the user moves the mouse slightly and\r\n\t\t\t\t\t\t\t\t* a drag and drop operation is not started, the item is\r\n\t\t\t\t\t\t\t\t* drawn again and this time TVIS_SELECTED is set.  This\r\n\t\t\t\t\t\t\t\t* means that an item that is in a tree that has the style\r\n\t\t\t\t\t\t\t\t* TVS_FULLROWSELECT and that also contains colored cells\r\n\t\t\t\t\t\t\t\t* will not draw the entire row selected until the user\r\n\t\t\t\t\t\t\t\t* moves the mouse.  The fix is to test for the selection\r\n\t\t\t\t\t\t\t\t* colors and guess that the item is selected.\r\n\t\t\t\t\t\t\t\t* \r\n\t\t\t\t\t\t\t\t* NOTE: This code doesn't work when the foreground and\r\n\t\t\t\t\t\t\t\t* background of the tree are set to the selection colors\r\n\t\t\t\t\t\t\t\t* but this does not happen in a regular application.\r\n\t\t\t\t\t\t\t\t*/\r\n /*\r\n\t\t\t\t\t\t\t\t* Bug in Windows.  When DrawText() is used with DT_VCENTER\r\n\t\t\t\t\t\t\t\t* and DT_ENDELLIPSIS, the ellipsis can draw outside of the\r\n\t\t\t\t\t\t\t\t* rectangle when the rectangle is empty.  The fix is avoid\r\n\t\t\t\t\t\t\t\t* all text drawing for empty rectangles.\r\n\t\t\t\t\t\t\t\t*/\r\n /* Restore the old selection state of both items */\r\n /* Save the old selection state for both items */\r\n /*\r\n\t\t\t* Bug in Windows.  When TVM_SETINSERTMARK is used to set\r\n\t\t\t* an insert mark for a tree and an item is expanded or\r\n\t\t\t* collapsed near the insert mark, the tree does not redraw\r\n\t\t\t* the insert mark properly.  The fix is to hide and show\r\n\t\t\t* the insert mark whenever an item is expanded or collapsed.\r\n\t\t\t*/\r\n /*\r\n\t\t\t* Bug in Windows.  When TVM_SETINSERTMARK is used to set\r\n\t\t\t* an insert mark for a tree and an item is expanded or\r\n\t\t\t* collapsed near the insert mark, the tree does not redraw\r\n\t\t\t* the insert mark properly.  The fix is to hide and show\r\n\t\t\t* the insert mark whenever an item is expanded or collapsed.\r\n\t\t\t*/\r\n /*\r\n\t\t\t\t* Feature in Windows.  In some cases, TVM_ITEMEXPANDING\r\n\t\t\t\t* is sent from within TVM_DELETEITEM for the tree item\r\n\t\t\t\t* being destroyed.  By the time the message is sent,\r\n\t\t\t\t* the item has already been removed from the list of\r\n\t\t\t\t* items.  The fix is to check for null. \r\n\t\t\t\t*/\r\n /*\r\n\t\t\t\t\t\t* Bug in Windows.  When the numeric keypad asterisk\r\n\t\t\t\t\t\t* key is used to expand every item in the tree, Windows\r\n\t\t\t\t\t\t* sends TVN_ITEMEXPANDING to items in the tree that\r\n\t\t\t\t\t\t* have already been expanded.  The fix is to detect\r\n\t\t\t\t\t\t* that the item is already expanded and ignore the\r\n\t\t\t\t\t\t* notification.\r\n\t\t\t\t\t\t*/\r\n /* \r\n\t\t\t* Feature in Pocket PC.  The tree and table controls detect the tap\r\n\t\t\t* and hold gesture by default. They send a GN_CONTEXTMENU message to show\r\n\t\t\t* the popup menu.  This default behaviour is unwanted on Pocket PC 2002\r\n\t\t\t* when no menu has been set, as it still draws a red circle.  The fix\r\n\t\t\t* is to disable this default behaviour when no menu is set by returning\r\n\t\t\t* TRUE when receiving the Pocket PC 2002 specific NM_RECOGNIZEGESTURE\r\n\t\t\t* message.\r\n\t\t\t*/\r\n","BusyIndicator":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n ","PAINTSTRUCT":" public RECT rcPaint;\r\n ","StyledText":" selection background color\r\n  selection foreground color\r\n  native content (default or user specified)\r\n  line wrapping content, same as logicalContent if word wrap is off\r\n  listener for TextChanging, TextChanged and TextSet events from StyledTextContent\r\n  used for setStyles API when no LineStyleListener is registered\r\n  true=widget is using a user defined line style listener for line styles. false=widget is using the default line styler to store line styles\r\n  true=widget is using a user defined line background listener for line backgrounds. false=widget is using the default line styler to store line backgrounds\r\n  pixel based\r\n  pixel based\r\n  top visible line\r\n  offset of first character in top line\r\n  the client area height. Needed to calculate content width for new\r\n  the client area width. Needed during Resize callback to determine\r\n  line height=font height\r\n  number of characters in a tab\r\n  keep track of the horizontal caret position\r\n  when changing lines  x and y are start and end caret offsets of selection\r\n  x and y are start and end caret offsets of previous selection\r\n  position of selection anchor. 0 based offset from beginning of text\r\n  selection after last mouse double click\r\n  see getDoubleClickEnabled\r\n  insert  limits the number of characters the user can type in the widget. Unlimited by default.\r\n  workaround for bug 4791\r\n  \r\n  true=a double click ocurred. Don't do mouse swipe selection.\r\n  the direction of autoscrolling (up, down, right, left)\r\n  cache data of the\r\n  last text changing\r\n  event for use in the\r\n  text changed handler\r\n  apply the BIDI algorithm on text segments of the same color\r\n  left aligned header  centered header  right aligned header  copy of the widget content\r\n  client area to print on\r\n  printer color cache for line backgrounds and style\r\n  cached line backgrounds\r\n  cached line styles\r\n  cached bidi segments when running on a bidi platform\r\n  printer GC\r\n  width of a printer page in pixels\r\n  first page to print\r\n  last page to print\r\n  number of lines on a page\r\n  first (wrapped) line to print\r\n  last (wrapped) line to print\r\n  widget single line mode\r\n  selected text\r\n  indicates the printing gc should be mirrored\r\n  one inch margin around text\r\n  make the orientation of the printer gc match the control\r\n  close full page\r\n  close partial page\r\n  to the current one. Fixes bug 21698.\r\n  to the current one. Fixes bug 21698.\r\n  control word delimiter\r\n  Fixes bug 21698.\r\n  systems that don't support Unicode RTF.\r\n  set the font for the whole document to work around this.\r\n  font size is specified in half points\r\n  line starts before RTF write start\r\n  whole line is outside write range\r\n  skip over partial first line\r\n  style starts beyond line end or RTF write end\r\n  is guarded against above.\r\n  write any unstyled text\r\n  write styled text\r\n  copy to end of style or end of write range or end of line\r\n  guard against invalid styles and let style processing continue\r\n  write unstyled text at the end of the line\r\n  offset of first character that will be written\r\n  offset of last character that will be written.\r\n  0 based from the beginning of the widget text.\r\n  line starts before write start\r\n  whole line is outside write range\r\n  parent widget, used to create a GC for line measuring\r\n  width in pixel of each line in the document, -1 for unknown width\r\n  content to use for line width calculation\r\n  number of lines in lineWidth array\r\n  maximum line width of all measured lines\r\n  index of the widest line\r\n  shift up the lines\r\n  has the longest line been removed?\r\n  shift the lines down to make room for new lines\r\n  reset the new lines\r\n  have new lines been inserted above the longest line?\r\n  width is no longer valid\r\n  entire text deleted?\r\n  lines ever being visible.\r\n  need to recalculate maximum content width for all lines\r\n  calculated above.\r\n  do a full rewrap if all lines are reset\r\n  wrapping of one of the visible lines has changed\r\n  number of visible lines has changed\r\n  check for cases which will require a full redraw\r\n  be performed if a visible region is affected.  fixes bug 42947.\r\n  not affect the word wrapping. fixes bug 14047.\r\n  for ensuring that the bg  in its upper and lower case form\r\n  never happen because we use claimBottomFreeSpace)\r\n  Fixes bug 15088.\r\n  Fixes 1GEYJM0\r\n  client area (window is scrolled right).\r\n  clear the margin background\r\n  therefore make sure redraw range is valid.\r\n  redraw old selection, if any\r\n  don't wrap live content. Fixes bug 38344.\r\n  that does not required wrapping. Fixes bug 31195.\r\n  time-consuming process.\r\n  Use default values if no text is defined.\r\n  Rethrow all other errors. Fixes bug 17578.\r\n  LF occurs before CR!\r\n  CR  CR occurs before LF or no LF present?\r\n  no more line breaks?\r\n  text copied thus far (because there only is one line)\r\n  Navigation\r\n  Selection\r\n  Cut, Copy, Paste\r\n  Cut, Copy, Paste Wordstar style\r\n  Miscellaneous\r\n  Rethrow all other errors. Fixes bug 17578.\r\n  Fixes bug 21030.\r\n  If we're already autoscrolling in the given direction do nothing\r\n  down a cursor key (i.e., arrowUp, arrowDown).\r\n  end of the line\r\n  don't recognize CR as a line break.\r\n  line mode. fixes 4820.\r\n  only the delete key was pressed\r\n  only the backspace key was pressed\r\n  fixes 4820.\r\n  not in single line mode. fixes 4820.\r\n  double click word select the previous  could be incorrectly reset. Fixes 1GKM3XS\r\n  (e.g., mouse x < 0 && mouse y > caret line y)\r\n  find the previous  mouse word select only on same line mouse cursor is on\r\n  do nothing if in single line mode. fixes 5673\r\n  line is scrolled. fixes bug 5602.\r\n  scroll one page down or to the bottom\r\n  from content.getLineAtOffset(caretOffset) when in word wrap mode\r\n  restore the original horizontal caret position\r\n  go to end of line if in single line mode. fixes 5673\r\n  from content.getLineAtOffset(caretOffset) when in word wrap mode\r\n  scroll one page up or to the top\r\n  from content.getLineAtOffset(caretOffset) when in word wrap mode\r\n  restore the original horizontal caret position\r\n  shrink selection\r\n  test whether selection actually changed. Fixes 1G71EO1\r\n  grow selection\r\n  check if selection has reversed direction\r\n  shrink selection\r\n  test whether selection actually changed. Fixes 1G71EO1\r\n  grow selection\r\n  check if selection has reversed direction\r\n  only go to next line if not in single line mode. fixes 5673\r\n  from content.getLineAtOffset(caretOffset) when in word wrap mode\r\n  reset columnX on selection\r\n  repeat scrolls lots of lines\r\n  from content.getLineAtOffset(caretOffset) when in word wrap mode\r\n  save the original horizontal caret position\r\n  reset columnX on selection\r\n  from content.getLineAtOffset(caretOffset) when in word wrap mode\r\n  save the original horizontal caret position\r\n  reset columnX on selection\r\n  reset columnX on selection\r\n  Force symmetrical movement for word next and previous. Fixes 14536\r\n  would be on a different line. fixes 5673\r\n  wrapping lines, stay on bottom line when on line boundary\r\n  adjust y position for pixel based scrolling\r\n  calculate the number of lines that are fully visible\r\n  if word wrap is on, the line offset and text may be visual (wrapped)\r\n  is y above first line or is x before first column?\r\n  does the referenced line exist?\r\n  test segment index consistency\r\n  ensure that last segment index is line end offset\r\n  add offset for last non-colored segment in line, if any\r\n  styles cached by the widget\r\n  do nothing if redraw range is completely invisible\r\n  only redraw visible lines\r\n  + 1 to redraw whole bottom line, including line break\r\n  redraw entire center lines if redraw range includes more than two lines\r\n  character key pressed\r\n  key subtracts 64 from the value of the key that it modifies\r\n  see if we have a control character\r\n  special key pressed (e.g., F1)\r\n  key on some keyboards.  See bug 20953.\r\n  produces characters on motif.\r\n  produces characters on the mac.\r\n  -ignore DEL\r\n  Rethrow all other errors. Fixes bug 17578.\r\n  position cursor\r\n  insert text\r\n  Rethrow all other errors. Fixes bug 17578.\r\n  adjust y position for pixel based scrolling and top margin\r\n  Check if there is work to do\r\n  fixes 1GB93QT\r\n  Fixes 1GEYJM0\r\n  fixes bug 8273\r\n  optimization and fixes bug 13999. see also handleTextChanging.\r\n  notify default line styler about text change\r\n  caretOffset.\r\n  from content.getLineAtOffset(caretOffset) when in word wrap mode\r\n  restore the original horizontal caret position\r\n  Navigation\r\n  from content.getLineAtOffset(caretOffset) when in word wrap mode\r\n  restore the original horizontal caret position\r\n  Selection\r\n  Modification\r\n  toggle insert  Miscellaneous\r\n  in between parts of the line delimiter.\r\n  Fix advancing flag for delete  always update the caret location. fixes 1G8FODP\r\n  fixes 1GBB8NJ\r\n  an Image with 0 width or 0 height.\r\n  renderHeight will be negative when only top margin needs redrawing\r\n  reset all lines in the redraw rectangle\r\n  only calculate the visible lines\r\n  clear background to right widget border. fixes bug 19595.\r\n  clear background to right widget border. fixes bug 19595.\r\n  no redraw necessary if redraw offset is 0\r\n  redraw last line if more than one line needs redrawing\r\n  destination x, y\r\n  destination x, y\r\n  source x, y\r\n  source x, y\r\n  redraw first changed line in case a line was split  redraw but could cause flash  display new text\r\n  those that are visible.\r\n  use default line styler if last user line styler was removed.\r\n  use default line styler if last user line styler was removed. Fixes 1G7B1X2\r\n  if the area is not visible, there is no need to redraw\r\n  fixes 1G8FODP\r\n  new default line styler\r\n  destination x, y\r\n  destination x, y\r\n  source x, y\r\n  source x, y\r\n  destination\r\n  destination x, y\r\n  destination x, y\r\n  source x, y\r\n  source x, y\r\n  invalidated area\r\n  restore the original horizontal caret index\r\n  illegal operation and an exception is thrown. Fixes 1GDKK3R\r\n  don't notify listeners about the selection change.\r\n  always update the caret location. fixes 1G8FODP\r\n  keep the same top line visible. fixes 5815\r\n  always set the caret location. Fixes 6685\r\n  if offset is out of range.\r\n  is temporarily invisible\r\n  if offset is out of range.\r\n  is temporarily invisible\r\n  maximum\r\n  thumb size\r\n  page size\r\n  avoids flashing on Motif, fixes 1G7RE1J and 1G5SE92\r\n  this API can not be used if the client is providing the line background\r\n  do nothing if redraw range is completely invisible\r\n  only redraw visible lines\r\n  thumb size\r\n  page size\r\n  avoids flashing on Motif, fixes 1G7RE1J and 1G5SE92\r\n  checkWidget test done in setSelectionRange\r\n  checkWidget test done in setSelectionRange\r\n  is thrown. Fixes 1GDKK3R\r\n  always update the caret location. fixes 1G8FODP\r\n  different?\r\n  this API can not be used if the client is providing the line styles\r\n  check the range, make sure it falls within the range of the text\r\n  clearing all styles\r\n  if the style is not visible, there is no need to redraw\r\n  fixes 1G8FODP\r\n  this API can not be used if the client is providing the line styles\r\n  reset all lines\r\n  reset all lines affected by the style change\r\n  current text\r\n  should only redraw affected area to avoid flashing\r\n  fixes 1G8FODP\r\n  reset all line widths when the tab width changes\r\n  destination x, y\r\n  destination x, y\r\n  source x, y\r\n  source x, y\r\n  restore the original horizontal caret index\r\n  always make 1  always make 1  not return the desired line causing scrolling to not set it correctly)\r\n  is selection from right-to-left?\r\n  calculate the logical start and end values for the selection\r\n  can the selection be fully displayed within the widget's visible width?\r\n  will not be visible\r\n  the start of the selection\r\n  endX value could change if showing startX caused a scroll to occur\r\n  selection ends before text change\r\n  clear selection fragment before text change\r\n  change. Selection is only affected if it intersects the change (1GDY217).\r\n  move selection to keep same text selected\r\n  always update the caret location. fixes 1G8FODP\r\n  selection intersects replaced text. set caret behind text change\r\n  always update the caret location. fixes 1G8FODP\r\n  count equals logical line count.\r\n  adjust the top index so that top line remains the same\r\n  the end of the preceeding line.\r\n  to be scrolled. causes flash otherwise.\r\n  happening to fix 8503.\r\n  call setCaretLocation after fixing vertical scroll offset.\r\n  word wrap may have changed on one of the visible lines\r\n /* Redraw the old or new right/bottom margin if needed */\r\n","Device":" $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$   $NON-NLS-1$\r\n  $NON-NLS-1$  /* Debugging */\r\n /* System Font */\r\n /* Font Enumeration */\r\n /* Scripts */\r\n /* Advanced Graphics */\r\n /*\r\n\t* TEMPORARY CODE. When a graphics object is\r\n\t* created and the device parameter is null,\r\n\t* the current Display is used. This presents\r\n\t* a problem because SWT graphics does not\r\n\t* reference classes in SWT widgets. The correct\r\n\t* fix is to remove this feature. Unfortunately,\r\n\t* too many application programs rely on this\r\n\t* feature.\r\n\t*\r\n\t* This code will be removed in the future.\r\n\t*/\r\n /*\r\n* TEMPORARY CODE.\r\n*/\r\n /* Initialize the system font slot */\r\n /*\r\n\t\t * Feature in Windows. If the lfHeight of the LOGFONT structure\r\n\t\t * is positive, the lfHeight measures the height of the entire\r\n\t\t * cell, including internal leading, in logical units. Since the\r\n\t\t * height of a font in points does not include the internal leading,\r\n\t\t * we must subtract the internal leading, which requires a TEXTMETRIC.\r\n\t\t */\r\n /* Add the log font to the list of log fonts */\r\n /*\r\n\t\t\t * Feature in Windows. If the lfHeight of the LOGFONT structure\r\n\t\t\t * is positive, the lfHeight measures the height of the entire\r\n\t\t\t * cell, including internal leading, in logical units. Since the\r\n\t\t\t * height of a font in points does not include the internal leading,\r\n\t\t\t * we must subtract the internal leading, which requires a TEXTMETRIC,\r\n\t\t\t * which in turn requires font creation.\r\n\t\t\t */\r\n /* Initialize the instance variables */\r\n /* Enumerate */\r\n /* Use the character encoding for the default locale */\r\n /* The user did not specify a face name, so they want all versions of all available face names */\r\n /* Create the fontData from the logfonts */\r\n /* Clean up */\r\n /* Initialize scripts list */\r\n /*\r\n\t * If we're not on a device which supports palettes,\r\n\t * don't create one.\r\n\t */\r\n /*\r\n\t\t* Feature on WinCE.  For some reason, certain 8 bit WinCE\r\n\t\t* devices return 0 for the number of reserved entries in\r\n\t\t* the system palette.  Their system palette correctly contains\r\n\t\t* the usual 20 system colors.  The workaround is to assume\r\n\t\t* there are 20 reserved system colors instead of 0.\r\n\t\t*/\r\n /* Create the palette and reference counter */\r\n /* 4 bytes header + 4 bytes per entry * numEntries entries */\r\n /* 2 bytes = special header */\r\n /* 2 bytes = number of colors, LSB first */\r\n /* \r\n\t* Create a palette which contains the system entries\r\n\t* as they are located in the system palette.  The\r\n\t* MSDN article 'Memory Device Contexts' describes\r\n\t* where system entries are located.  On an 8 bit\r\n\t* display with 20 reserved colors, the system colors\r\n\t* will be the first 10 entries and the last 10 ones.\r\n\t*/\r\n /* Copy all entries from the system palette */\r\n /* Lock the indices corresponding to the system entries */\r\n","Resource":" ","SIPINFO":" RECT rcVisibleDesktop\r\n  RECT rcSipRect\r\n ","PngIdatChunk":" ","EXCEPINFO":" ","NOTIFYICONDATAA":" ","NONCLIENTMETRICS":" ","NMHEADER":" ","MouseMoveListener":" ","NMTVCUSTOMDRAW":" the iLevel field does not appear on WinCE\r\n ","FillData":" ","MEASUREITEMSTRUCT":" ","IDispatch":" create an array to hold the addresses\r\n  free the memory\r\n  create a null terminated array of char for each String\r\n  get the address of the start of the array of char\r\n  copy the address to the array of addresses\r\n  keep track of the Global Memory so we can free it\r\n ","UDACCEL":" ","IOleControl":" ","IOleWindow":" ","FUNCDESC":" TYPEDESC elemdescFunc.tdesc\r\n  PARAMDESC elemdescFunc.paramdesc\r\n ","DropTarget":" Track application selections\r\n  workaround - There is no event for \"operation changed\" so track operation based on key state\r\n  maintain a reference to it.\r\n  interfaces\r\n  $NON-NLS-1$\r\n  Drag under effect\r\n  register each of the interfaces that this object implements\r\n  Remember the iDataObject because it is not passed into the DragOver callback\r\n  Get Data in a Java format\r\n  notify source of action taken\r\n  Scan across the width of the tree.\r\n  Scan across the width of the tree.\r\n  get allowed operations\r\n  get current operation\r\n  Get allowed transfer types\r\n  Loop over enumerator and save any types that match what we are looking for\r\n ","SCRIPT_PROPERTIES":" ","DisposeListener":" ","MOUSEINPUT":" ","DNDEvent":" ","CTabFolderLayout":" preferred width of tab area to show all tabs\r\n  chevron\r\n  preferred size of controls in tab items\r\n  resize content\r\n ","STGMEDIUM":" ","TEXTMETRIC":" ","LEDataInputStream":" Are there pushback bytes available?\r\n  Have we copied enough?\r\n ","OleAutomation":" get the IDispatch interface for the control\r\n  create a DISPPARAMS structure for the input parameters\r\n  store arguments in rgvarg\r\n  if arguments have ids, store the ids in rgdispidNamedArgs\r\n  invoke the method\r\n  free the Dispparams resources\r\n  save error string and cleanup EXCEPINFO\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  $NON-NLS-1$\r\n  extract exception info\r\n  cleanup EXCEPINFO struct\r\n ","KeyEvent":" remove trailing '}'\r\n ","WinBMPFileFormat":" BMP_RLE8_COMPRESSION\r\n  BMP_RLE4_COMPRESSION\r\n  BMP_RLE8_COMPRESSION\r\n  BMP_RLE4_COMPRESSION\r\n  Round up to 4 byte multiple\r\n  BMP_NO_COMPRESSION\r\n  Seek to the specified offset\r\n  BMP pads scanlines to multiples of 4 bytes\r\n  Compression can actually take twice as much space, in worst case\r\n  Start at last line\r\n  BMP pads scanlines to multiples of 4 bytes\r\n  Start at last line\r\n  Fill in file header, except for bfsize, which is done later.\r\n  Signature\r\n  File size - filled in later\r\n  Reserved 1\r\n  Reserved 2\r\n  Offset to data\r\n  the stream and fill in the details later.\r\n  Calculate file size\r\n  Write the headers\r\n  Unload palette\r\n  Unload the data\r\n /* find two consecutive bytes that are the same in the next 128 */\r\n /* if there is only one more byte in the scan line, include it */\r\n /* handled separately because 0,2 is a command */\r\n /* 1 byte == 2 pixels */\r\n /* n bytes = n*2 pixels */\r\n /* pad to word */\r\n /* store the intervening data */\r\n /* find the length of the next run (up to 127) and store it */\r\n /* n bytes = n*2 pixels */\r\n /* store the end of line or end of bitmap codes */\r\n /* find two consecutive bytes that are the same in the next 256 */\r\n /* if there is only one more byte in the scan line, include it */\r\n /* handled separately because 0,2 is a command */\r\n /* handled separately because 0,1 is a command */\r\n /* don't break, fall through */\r\n /* pad to word */\r\n /* store the intervening data */\r\n /* find the length of the next run (up to 255) and store it */\r\n /* store the end of line or end of bitmap codes */\r\n /* end of line */\r\n /* end of bitmap */\r\n /* delta */\r\n /* odd run lengths not currently supported */\r\n /* absolute mode run */\r\n /* word align sp? */\r\n /* end of line */\r\n /* end of bitmap */\r\n /* delta */\r\n /* absolute mode run */\r\n /* word align sp? */\r\n","DragUnderEffect":" ","SCRIPT_LOGATTR":" ","CHOOSECOLOR":" ","DirectoryDialog":" $NON-NLS-1$  $NON-NLS-1$\r\n /* Use the character encoding for the default locale */\r\n /* Use the character encoding for the default locale */\r\n /* Use the character encoding for the default locale */\r\n /* Get the owner HWND for the dialog */\r\n /* Copy the message to OS memory */\r\n /* Use the character encoding for the default locale */\r\n /* Make the parent shell be temporary modal */\r\n /*\r\n\t* Bug in Windows.  On some hardware configurations, SHBrowseForFolder()\r\n\t* causes warning dialogs with the message \"There is no disk in the drive\r\n\t* Please insert a disk into \\Device\\Harddisk0\\DR0\".  This is possibly\r\n\t* caused by SHBrowseForFolder() calling internally GetVolumeInformation().\r\n\t* MSDN for GetVolumeInformation() says:\r\n\t* \r\n\t* \"If you are attempting to obtain information about a floppy drive\r\n\t* that does not have a floppy disk or a CD-ROM drive that does not \r\n\t* have a compact disc, the system displays a message box asking the \r\n\t* user to insert a floppy disk or a compact disc, respectively. \r\n\t* To prevent the system from displaying this message box, call the \r\n\t* SetErrorMode function with SEM_FAILCRITICALERRORS.\"\r\n\t* \r\n\t* The fix is to save and restore the error mode using SetErrorMode()\r\n\t* with the SEM_FAILCRITICALERRORS flag around SHBrowseForFolder().\r\n\t*/\r\n /*\r\n\t* Bug in Windows.  When a WH_MSGFILTER hook is used to run code\r\n\t* during the message loop for SHBrowseForFolder(), running code\r\n\t* in the hook can cause a GP.  Specifically, SetWindowText()\r\n\t* for static controls seemed to make the problem happen.\r\n\t* The fix is to ignore the hook while the directory dialog\r\n\t* is open.\r\n\t* \r\n\t* NOTE:  This only happens in versions of the comctl32.dll\r\n\t* earlier than 6.0.\r\n\t*/\r\n /* Clear the temporary dialog modal parent */\r\n /* Use the character encoding for the default locale */\r\n /* Free the BrowseCallbackProc */\r\n /* Free the OS memory */\r\n /* Free the pointer to the ITEMIDLIST */\r\n /* void Free (struct IMalloc *this, void *pv); */\r\n /* Return the directory path */\r\n","CTabFolder2Adapter":" ","OleControlSite":" interfaces for this container\r\n  supporting Property Change attributes\r\n  supporting Event Sink attributes\r\n  supporting information for the Control COM object\r\n  check for licensing\r\n  Prepare the ClassFactory\r\n  Create Com Object\r\n  Prepare a storage medium\r\n  Open a storage object\r\n  Create ole object with storage object\r\n  Init sinks\r\n  Init site properties\r\n  get Event Sink I  get Event Sink I  have we connected to this kind of event sink before?\r\n  Get property change notification from control\r\n  Get access to the Control object\r\n  need to act on it\r\n  method7 Translate Accelerator - not implemented\r\n  register each of the interfaces that this object implements\r\n  method5 GetIDsOfNames - not implemented\r\n  !! We are getting the OLE_COLOR - should we change this to the COLORREF value?\r\n  Variant lfCharSet  = iDispFont.getProperty(COM.DISPID_FONT_CHARSET);\r\n  !! We are getting the OLE_COLOR - should we change this to the COLORREF value?\r\n  Copy the Window's handle into the memory passed in\r\n  indicate a false result\r\n  not implemented\r\n  need to act on it\r\n  border space or menubars\r\n  free resources associated with event sink\r\n  set the background of the ActiveX Control\r\n  iDispFont.setProperty(COM.DISPID_FONT_CHARSET, new Variant(fdata[0].getCharset));\r\n  set the font of the ActiveX Control\r\n  set the foreground of the ActiveX Control\r\n ","SelectionAdapter":" ","OSVERSIONINFOW":" ","IStorage":" we only support snbExclude = null\r\n  Number of elements in rgiidExclude\r\n  Array of interface identifiers (IIDs)\r\n  Points to a block of stream names in the storage object\r\n  Points to destination storage object\r\n  create a null terminated array of char\r\n  Pointer to the name of the new storage object\r\n  Access mode for the new storage object\r\n  Reserved; must be zero\r\n  Reserved; must be zero\r\n  Pointer to new storage object\r\n  create a null terminated array of char\r\n  Pointer to the name of the new stream\r\n  Access mode for the new stream\r\n  Reserved; must be zero\r\n  Reserved; must be zero\r\n  Pointer to new stream object\r\n  create a null terminated array of char\r\n  receives the IEnumSTATSTG interface\r\n  Reserved; must be zero\r\n  Reserved; must be NULL\r\n  Reserved; must be zero\r\n  Pointer to output variable that\r\n  create a null terminated array of char\r\n  we only support the case where snbExclude = null\r\n  Pointer to the name of the\r\n  Must be NULL.\r\n  Access mode for the new storage object\r\n  Must be NULL.\r\n  Reserved; must be zero\r\n  Pointer to opened storage object\r\n  create a null terminated array of char\r\n  that receives the IStream interface pointer\r\n  Pointer to name of stream to open\r\n  Reserved; must be NULL\r\n  Access mode for the new stream\r\n  Reserved; must be zero\r\n  Pointer to output variable\r\n  create a null terminated array of char\r\n  create a null terminated array of char\r\n  the specified element\r\n  Pointer to the name of the\r\n  Pointer to the new name for\r\n  CLSID to be assigned to the storage object\r\n ","ImageDataLoader":" ","SashForm":" a specific color\r\n  checkWidget();\r\n  checkWidget();\r\n ","IViewObject2":" ","NOTIFYICONDATA":" ","SHMENUBARINFO":" "}